<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java基础学习复习笔记整理</title>
      <link href="2021/05/31/java2021-05-31/"/>
      <url>2021/05/31/java2021-05-31/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-Java概述"><a href="#第一章-Java概述" class="headerlink" title="第一章 Java概述"></a>第一章 Java概述</h1><h2 id="1-1-Java历史"><a href="#1-1-Java历史" class="headerlink" title="1.1 Java历史"></a>1.1 Java历史</h2><p>Java诞生于SUN（Stanford University Network），09年SUN被Oracle（甲骨文）收购。</p><p>Java之父是詹姆斯.高斯林(James Gosling)。</p><p>1996年发布JDK1.0版。</p><p>目前最新的版本是Java12。我们学习的Java8。</p><h2 id="1-2-Java语言最主要的特点"><a href="#1-2-Java语言最主要的特点" class="headerlink" title="1.2 Java语言最主要的特点"></a>1.2 Java语言最主要的特点</h2><ul><li>特点一：面向对象</li></ul><p>两个基本概念：类、对象</p><p>三大特性：封装、继承、多态</p><ul><li>特点二：健壮性</li></ul><p>吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制</p><ul><li>特点三：跨平台性</li></ul><p>跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere”一次编写，处处运行。</p><p>原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM Java Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。因为有了JVM，同一个Java 程序在三个不同的操作系统中都可以执行。这样就实现了Java 程序的跨平台性。</p><p><img data-src="/upload_image/java2021_05_31/1557828366412.png" alt="1557828366412"></p><h2 id="1-3-Java环境搭建"><a href="#1-3-Java环境搭建" class="headerlink" title="1.3 Java环境搭建"></a>1.3 Java环境搭建</h2><h3 id="1-3-1-JDK、JRE、JVM"><a href="#1-3-1-JDK、JRE、JVM" class="headerlink" title="1.3.1 JDK、JRE、JVM"></a>1.3.1 JDK、JRE、JVM</h3><p>Java开发人员需要安装JDK。如果仅仅是运行Java程序，那么只需要按照JRE。</p><p>JDK（Java Development kits）：Java开发工具包。</p><p>JRE（Java Runtime Environment）：Java运行环境。</p><p>JVM（Java Virtual Machine）：Java虚拟机。</p><p>JDK = JRE + 开发工具（javac.exe,java.exe,javadoc.exe等）</p><p>JRE = JVM + 核心类库（常用类：String、日期时间、数学、集合、IO、网络、多线程等）</p><p><img data-src="/upload_image/java2021_05_31/1553593811117.png"></p><h3 id="1-3-2-Java环境搭建"><a href="#1-3-2-Java环境搭建" class="headerlink" title="1.3.2  Java环境搭建"></a>1.3.2  Java环境搭建</h3><p>1、安装JDK</p><p><img data-src="/upload_image/java2021_05_31/1553644600381.png"></p><p>2、配置JDK的开发工具目录到path环境变量中</p><p>​    例如：D:\ProgramFiles\Java\jdk1.8.0_51\bin;</p><p>​    注意：这个安装目录以你自己的安装目录为准</p><p><img data-src="/upload_image/java2021_05_31/1553644724825.png" alt="1553644724825"></p><p>（1）为什么配置path？</p><p>​    希望在命令行使用javac.exe等工具时，任意目录下都可以找到这个工具所在的目录。</p><p>（2）如何配置环境变量？</p><p>​    【计算机】右键【属性】，选择【高级系统设置】，选择【高级】，选择【环境变量】，选择【系统环境变量】，编辑path，在【<strong>path原有值</strong>】的前面加入D:\ProgramFiles\Java\jdk1.8.0_51\bin;</p><h2 id="1-4-第一个Java应用程序"><a href="#1-4-第一个Java应用程序" class="headerlink" title="1.4 第一个Java应用程序"></a>1.4 第一个Java应用程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Hello Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-1-Java程序的开发步骤"><a href="#1-4-1-Java程序的开发步骤" class="headerlink" title="1.4.1 Java程序的开发步骤"></a>1.4.1 Java程序的开发步骤</h3><p>三步：</p><p>1、编辑/编写源代码</p><p>要求：源文件必须是.java文件</p><p>2、编译</p><p>目的：把源文件编译为.class字节码文件（因为JVM只认识字节码）</p><p>工具：javac.exe</p><p>格式：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac 源文件名.java</span><br></pre></td></tr></table></figure><p>3、运行</p><p>工具：java.exe</p><p>格式：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java 类名</span><br><span class="line">java 字节码文件名</span><br></pre></td></tr></table></figure><p>要求：可以被运行的类，必须包含main方法</p><h3 id="1-4-2-Java程序的结构与格式"><a href="#1-4-2-Java程序的结构与格式" class="headerlink" title="1.4.2 Java程序的结构与格式"></a>1.4.2 Java程序的结构与格式</h3><p>结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类&#123;</span><br><span class="line">    方法&#123;</span><br><span class="line">        语句;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式：</p><p>（1）每一级缩进一个Tab键</p><p>（2）{}的左半部分在行尾，右半部分单独一行，与和它成对的”{“的行首对齐</p><h3 id="1-4-3-Java程序的入口"><a href="#1-4-3-Java程序的入口" class="headerlink" title="1.4.3 Java程序的入口"></a>1.4.3 Java程序的入口</h3><p>Java程序的入口是main方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-4-Java注释"><a href="#1-4-4-Java注释" class="headerlink" title="1.4.4 Java注释"></a>1.4.4 Java注释</h3><p>1、单行注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注释内容</span></span><br></pre></td></tr></table></figure><p>2、多行注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注释内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>3、文档注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">文档注释（后面注解部分讲解）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="1-5-编写Java程序时应该注意的问题"><a href="#1-5-编写Java程序时应该注意的问题" class="headerlink" title="1.5 编写Java程序时应该注意的问题"></a>1.5 编写Java程序时应该注意的问题</h2><p>1、字符编码问题</p><p>当cmd命令行窗口的字符编码与.java源文件的字符编码不一致，如何解决？</p><p><img data-src="/upload_image/java2021_05_31/1557881223916.png" alt="1557881223916"></p><p>解决方案一：</p><p>​    在Notepad++等编辑器中，修改源文件的字符编码</p><p><img data-src="/upload_image/java2021_05_31/1557881271819.png" alt="1557881271819"></p><p>解决方案二：</p><p>​    在使用javac命令式，可以指定源文件的字符编码</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding utf-<span class="number">8</span> Review01.java</span><br></pre></td></tr></table></figure><p>2、大小写问题</p><p>（1）源文件名：</p><p>​    不区分大小写，我们建议大家还是区分</p><p>（2）字节码文件名与类名</p><p>​    区分大小写</p><p>（3）代码中</p><p>​    区分大小写</p><p>3、源文件名与类名一致问题？</p><p>（1）源文件名是否必须与类名一致？public呢？</p><p>如果这个类不是public，那么源文件名可以和类名不一致。</p><p>如果这个类是public，那么要求源文件名必须与类名一致。</p><p>我们建议大家，不管是否是public，都与源文件名保持一致，而且一个源文件尽量只写一个类，目的是为了好维护。</p><p>（2）一个源文件中是否可以有多个类？public呢？</p><p>一个源文件中可以有多个类，编译后会生成多个.class字节码文件。</p><p>但是一个源文件只能有一个public的类。</p><p>（3）main必须在public的类中吗？</p><p>不是。</p><p>但是后面写代码时，基本上main习惯上都在public类中。</p><h1 id="第二章-Java的基础语法"><a href="#第二章-Java的基础语法" class="headerlink" title="第二章 Java的基础语法"></a>第二章 Java的基础语法</h1><h2 id="2-1-标识符"><a href="#2-1-标识符" class="headerlink" title="2.1 标识符"></a>2.1 标识符</h2><p>简单的说，凡是程序员自己命名的部分都可以称为标识符。</p><p>即给类、变量、方法、包等命名的字符序列，称为标识符。</p><p>1、标识符的命名规则</p><p>（1）Java的标识符只能使用26个英文字母大小写，0-9的数字，下划线_，美元符号$</p><p>（2）不能使用Java的关键字（包含保留字）和特殊值</p><p>（3）数字不能开头</p><p>（4）不能包含空格</p><p>（5）严格区分大小写</p><p>2、标识符的命名规范</p><p>（1）见名知意</p><p>（2）类名、接口名等：每个单词的首字母都大写，形式：XxxYyyZzz，</p><p>例如：HelloWorld，String，System等</p><p>（3）变量、方法名等：从第二个单词开始首字母大写，其余字母小写，形式：xxxYyyZzz，</p><p>例如：age,name,bookName,main</p><p>（4）包名等：每一个单词都小写，单词之间使用点.分割，形式：xxx.yyy.zzz，</p><p>例如：java.lang</p><p>（5）常量名等：每一个单词都大写，单词之间使用下划线_分割，形式：XXX_YYY_ZZZ，</p><p>例如：MAX_VALUE,PI</p><h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><h3 id="2-2-1-变量的概念"><a href="#2-2-1-变量的概念" class="headerlink" title="2.2.1 变量的概念"></a>2.2.1 变量的概念</h3><p>变量的作用：用来存储数据，代表内存的一块存储区域，变量中的值是可以改变的。</p><h3 id="2-2-2-变量的三要素"><a href="#2-2-2-变量的三要素" class="headerlink" title="2.2.2 变量的三要素"></a>2.2.2 变量的三要素</h3><p>1、数据类型</p><p>2、变量名</p><p>3、值</p><h3 id="2-2-3-变量的使用应该注意什么？"><a href="#2-2-3-变量的使用应该注意什么？" class="headerlink" title="2.2.3 变量的使用应该注意什么？"></a>2.2.3 变量的使用应该注意什么？</h3><p>1、先声明后使用</p><blockquote><p>如果没有声明，会报“找不到符号”错误</p></blockquote><p>2、在使用之前必须初始化</p><blockquote><p>如果没有初始化，会报“未初始化”错误</p></blockquote><p>3、变量有作用域</p><blockquote><p>如果超过作用域，也会报“找不到符号”错误</p></blockquote><p>4、在同一个作用域中不能重名</p><h3 id="2-2-4-变量的声明和赋值、使用的语法格式？"><a href="#2-2-4-变量的声明和赋值、使用的语法格式？" class="headerlink" title="2.2.4 变量的声明和赋值、使用的语法格式？"></a>2.2.4 变量的声明和赋值、使用的语法格式？</h3><p>1、变量的声明的语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据类型  变量名;</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">double</span> weight;</span><br><span class="line"><span class="keyword">char</span> gender;</span><br><span class="line"><span class="keyword">boolean</span> isMarry;</span><br></pre></td></tr></table></figure><p>2、变量的赋值的语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">变量名 = 值;</span><br><span class="line">例如：</span><br><span class="line">age = <span class="number">18</span>;</span><br><span class="line">name = <span class="string">&quot;柴林燕&quot;</span>; <span class="comment">//字符串的值必须用&quot;&quot;</span></span><br><span class="line">weight = <span class="number">44.4</span>;</span><br><span class="line">gender = <span class="string">&#x27;女&#x27;</span>;<span class="comment">//单字符的值必须使用&#x27;&#x27;</span></span><br><span class="line">isMarry = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>3、变量的使用的语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">通过变量名直接引用</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">(<span class="number">1</span>)输出变量的值</span><br><span class="line">System.out.print(name);</span><br><span class="line">System.out.print(<span class="string">&quot;姓名：&quot;</span> + name);<span class="comment">//&quot;&quot;中的内容会原样显示</span></span><br><span class="line">System.out.print(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">(<span class="number">2</span>)计算</span><br><span class="line">age = age + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1 id="2-3-数据类型"><a href="#2-3-数据类型" class="headerlink" title="2.3 数据类型"></a>2.3 数据类型</h1><h3 id="2-3-1-Java数据类型的分类"><a href="#2-3-1-Java数据类型的分类" class="headerlink" title="2.3.1 Java数据类型的分类"></a>2.3.1 Java数据类型的分类</h3><p>1、基本数据类型</p><p>​    8种：整型系列（byte,short,int,long）、浮点型(float,double)、单字符型（char）、布尔型（boolean）</p><p>2、引用数据类型</p><p>​    类、接口、数组、枚举…..</p><h3 id="2-3-2-Java的基本数据类型"><a href="#2-3-2-Java的基本数据类型" class="headerlink" title="2.3.2 Java的基本数据类型"></a>2.3.2 Java的基本数据类型</h3><p>1、整型系列</p><p>（1）byte：字节类型</p><p>占内存：1个字节</p><p>存储范围：-128~127</p><p>（2）short：短整型类型</p><p>占内存：2个字节</p><p>存储范围：-32768~32767</p><p>（3）int：整型</p><p>占内存：4个字节</p><p>存储范围：-2的31次方 ~ 2的31次方-1</p><p>（4）long：整型</p><p>占内存：8个字节</p><p>存储范围：-2的63次方 ~ 2的63次方-1</p><blockquote><p>注意：如果要表示某个常量数字它是long类型，那么需要在数字后面加L</p></blockquote><p>2、浮点型系列（小数）</p><p>（1）float：单精度浮点型</p><p>占内存：4个字节</p><p>精度：科学记数法的小数点后6~7位</p><blockquote><p>注意：如果要表示某个常量数字是float类型，那么需要在数字后面加F或f</p></blockquote><p>（2）double：双精度浮点型</p><p>占内存：8个字节</p><p>精度：科学记数法的小数点后15~16位</p><p>3、单字符类型</p><p>char：字符类型</p><p>占内存：2个字节</p><p>Java中使用的字符集：Unicode编码集</p><p>字符的三种表示方式：</p><p>（1）’一个字符’</p><p>例如：’A’，’0’，’尚’</p><p>（2）转义字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\n：换行</span><br><span class="line">\r：回车</span><br><span class="line">\t：Tab键</span><br><span class="line">\\：\</span><br><span class="line">\&quot;：”</span><br><span class="line">\&#39;：</span><br><span class="line">\b：删除键Backspace</span><br></pre></td></tr></table></figure><p>（3）\u字符的Unicode编码值的十六进制型</p><p>例如：\u5c1a代表’尚’</p><p>4、布尔类型</p><p>boolean：只能存储true或false</p><h3 id="2-3-3-进制（了解，可以暂时忽略）"><a href="#2-3-3-进制（了解，可以暂时忽略）" class="headerlink" title="2.3.3 进制（了解，可以暂时忽略）"></a>2.3.3 进制（了解，可以暂时忽略）</h3><p>1、进制的分类：</p><p>（1）十进制</p><p>​    数字组成：0-9</p><p>​    进位规则：逢十进一</p><p>（2）二进制</p><p>​    数字组成：0-1</p><p>​    进位规则：逢二进一</p><p>（3）八进制</p><p>​    数字组成：0-7</p><p>​    进位规则：逢八进一</p><p>（4）十六进制</p><p>​    数字组成：0-9，a<del>f（或A</del>F）</p><p>​    进位规则：逢十六进一</p><p>2、请分别用四种类型的进制来表示10，并输出它的结果：（了解）</p><p>（1）十进制：正常表示</p><p>System.out.println(10);</p><p>（2）二进制：0b或0B开头</p><p>System.out.println(0B10);</p><p>（3）八进制：0开头</p><p>System.out.println(010);</p><p>（4）十六进制：0x或0X开头</p><p>System.out.println(0X10);</p><p>3、为什么byte是-128~127？（理解）</p><p>1个字节：8位</p><p>0000 0001  ~  0111 111 ==&gt; 1~127</p><p>1000 0001 ~ 1111 1111 ==&gt; -127 ~ -1</p><p>0000 0000 ==&gt;0</p><p>1000 0000 ==&gt; -128（特殊规定）</p><blockquote><p><em>解释：</em>计算机数据的存储（了解）</p><p><em>计算机数据的存储使用二进制补码形式存储，并且最高位是符号位，1是负数，0是正数。</em></p><p><em>规定：正数的补码与反码、原码一样，称为三码合一；</em></p><p>​        <em>负数的补码与反码、原码不一样：</em></p><p>​       <em>负数的原码：把十进制转为二进制，然后最高位设置为1</em></p><p>​       <em>负数的反码：在原码的基础上，最高位不变，其余位取反（0变1,1变0）</em></p><p>​       <em>负数的补码：反码+1</em></p><p><em>例如：byte类型（1个字节，8位）</em></p><p><em>25 ==&gt; 原码  0001 1001 ==&gt; 反码  0001 1001 –&gt;补码  0001 1001</em></p><p><em>-25 ==&gt;原码  1001 1001 ==&gt; 反码1110 0110 ==&gt;补码 1110 0111</em></p><p>底层是用加法代替减法：-128==》-127-1==》-127+(-1)</p><p>​                       -127- -1 ==&gt; -127 + 1</p></blockquote><p>4、学生疑惑解答？</p><p>（1）为什么float（4个字节）比long（8个字节）的存储范围大？</p><p>（2）为什么double（8个字节）比float（4个字节）精度范围大？</p><p>因为float、double底层也是二进制，先把小数转为二进制，然后把二进制表示为科学记数法，然后只保存：</p><p>（1）符号位（2）指数位（3）尾数位</p><blockquote><p><em>详见《float型和double型数据的存储方式.docx》</em></p></blockquote><h3 id="2-3-4-基本数据类型的转换"><a href="#2-3-4-基本数据类型的转换" class="headerlink" title="2.3.4 基本数据类型的转换"></a>2.3.4 基本数据类型的转换</h3><p>1、自动类型转换</p><p>（1）当把存储范围小的值（常量值、变量的值、表达式计算的结果值）赋值给了存储范围大的变量时，</p><p>byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double</p><p>​            char-&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="string">&#x27;A&#x27;</span>;<span class="comment">//char自动升级为int</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">10</span>;<span class="comment">//int自动升级为double</span></span><br></pre></td></tr></table></figure><p>（2）当存储范围小的数据类型与存储范围大的数据类型一起混合运算时，会按照其中最大的类型运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> sum = i + b + d;<span class="comment">//混合运算，升级为double</span></span><br></pre></td></tr></table></figure><p>（3）当byte,short,char数据类型进行算术运算时，按照int类型处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">byte</span> b3 = (<span class="keyword">byte</span>)(b1 + b2);<span class="comment">//b1 + b2自动升级为int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">System.out.println(c1 + c2);<span class="comment">//113 </span></span><br></pre></td></tr></table></figure><p>（4）boolean类型不参与</p><p>2、强制类型转换</p><p>（1）当把存储范围大的值（常量值、变量的值、表达式计算的结果值）赋值给了存储范围小的变量时，需要强制类型转换</p><p>double-&gt;float-&gt;long-&gt;int-&gt;short-&gt;byte</p><p>​                       -&gt;char</p><p>提示：有风险，可能会损失精度或溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">1.2</span>;</span><br><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>)d;<span class="comment">//损失精度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;<span class="comment">//溢出</span></span><br></pre></td></tr></table></figure><p>（2）boolean类型不参与</p><p>（3）当某个值想要提升数据类型时，也可以使用强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> shang = (<span class="keyword">double</span>)i/j;</span><br></pre></td></tr></table></figure><p>提示：这个情况的强制类型转换是没有风险的。</p><h3 id="2-3-5-特殊的数据类型转换"><a href="#2-3-5-特殊的数据类型转换" class="headerlink" title="2.3.5 特殊的数据类型转换"></a>2.3.5 特殊的数据类型转换</h3><p>1、任意数据类型的数据与String类型进行“+”运算时，结果一定是String类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;&quot;</span> + <span class="number">1</span> + <span class="number">2</span>);<span class="comment">//12</span></span><br></pre></td></tr></table></figure><p>2、但是String类型不能通过强制类型()转换，转为其他的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>)str;<span class="comment">//错误的</span></span><br></pre></td></tr></table></figure><h2 id="2-4-运算符"><a href="#2-4-运算符" class="headerlink" title="2.4 运算符"></a>2.4 运算符</h2><p>1、按照操作数个数的分类：</p><p>（1）一元运算符：操作数只有一个</p><p>例如：正号（+），负号（-），自增（++），自减（–），逻辑非（！），按位取反（~）</p><p>（2）二元运算符：操作数有两个</p><p>例如：加（+），减（-），乘（*），除（/），模（%）</p><p>​          大于（&gt;），小于（&lt;），大于等于（&gt;=），小于等于（&lt;=），等于（==），不等于（!=）</p><p>​    赋值（=，+=，-=，*=，/=，%=，&gt;&gt;=，&lt;&lt;=。。。）</p><p>​     逻辑与（&amp;），逻辑或（|），逻辑异或（^），短路与（&amp;&amp;），短路或（||）</p><p>​    左移（&lt;&lt;），右移（&gt;&gt;），无符号右移（&gt;&gt;&gt;），按位与（&amp;），按位或（|），按位异或（^）</p><p>（3）三元运算符：操作数三个</p><p>例如： ？ ：</p><p>2、Java基本数据类型的运算符：</p><p>（1）算术运算符</p><p>（2）赋值运算符</p><p>（3）比较运算符</p><p>（4）逻辑运算符</p><p>（5）条件运算符</p><p>（6）位运算符（难）</p><h3 id="2-4-1-算术运算符"><a href="#2-4-1-算术运算符" class="headerlink" title="2.4.1 算术运算符"></a>2.4.1 算术运算符</h3><p>加法：+</p><p>减法：-</p><p>乘法：*</p><p>除法：/</p><blockquote><p><em>注意：整数与整数相除，只保留整数部分</em></p></blockquote><p>取模：%   取余</p><blockquote><p>注意：取模结果的正负号只看被模数</p></blockquote><p>正号：+</p><p>负号：-</p><p>自增：++</p><p>自减：–</p><blockquote><p><strong>原则：自增与自减</strong></p><p><strong>++/–在前的，就先自增/自减，后取值</strong></p><p><strong>++/–在后的，就先取值，后自增/自减</strong></p><p>整个表达式的扫描，是从左往右扫描，如果后面的先计算的，那么前面的就暂时先放到“操作数栈”中</p></blockquote><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i++;<span class="comment">//i=2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">++j;<span class="comment">//j=2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = a++;<span class="comment">//(1)先取a的值“1”放操作数栈(2)a再自增,a=2(3)再把操作数栈中的&quot;1&quot;赋值给b,b=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n = ++m;<span class="comment">//(1)m先自增,m=2(2)再取m的值“2”放操作数栈(3)再把操作数栈中的&quot;2&quot;赋值给n,n=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = i++ + ++i * i++;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从左往右加载</span></span><br><span class="line"><span class="comment">(1)先算i++</span></span><br><span class="line"><span class="comment">①取i的值“1”放操作数栈</span></span><br><span class="line"><span class="comment">②i再自增 i=2</span></span><br><span class="line"><span class="comment">（2）再算++i</span></span><br><span class="line"><span class="comment">①i先自增 i=3</span></span><br><span class="line"><span class="comment">②再取i的值“3”放操作数栈</span></span><br><span class="line"><span class="comment">（3）再算i++</span></span><br><span class="line"><span class="comment">①取i的值“3”放操作数栈</span></span><br><span class="line"><span class="comment">②i再自增 i=4</span></span><br><span class="line"><span class="comment">（4）先算乘法</span></span><br><span class="line"><span class="comment">用操作数栈中3 * 3 = 9，并把9压会操作数栈</span></span><br><span class="line"><span class="comment">（5）再算求和</span></span><br><span class="line"><span class="comment">用操作数栈中的 1 + 9 = 10</span></span><br><span class="line"><span class="comment">（6）最后算赋值</span></span><br><span class="line"><span class="comment">j = 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="2-4-2-赋值运算符"><a href="#2-4-2-赋值运算符" class="headerlink" title="2.4.2 赋值运算符"></a>2.4.2 赋值运算符</h3><p>基本赋值运算符：=</p><p>扩展赋值运算符：+=，-=，*=，/=，%=…</p><blockquote><p>注意：所有的赋值运算符的=左边一定是一个变量</p><p>扩展赋值运算符=右边的计算结果的类型如果比左边的大的话会强制类型转换，所以结果可能有风险。</p><p>扩展赋值运算符的计算：（1）赋值最后算（2）加载数据的顺序是把左边的变量的值先加载，再去与右边的表达式进行计算</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">5</span>;</span><br><span class="line">j *= i++ + j++;<span class="comment">//j = j *(i++ + j++);</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(1)先加载j的值“5”</span></span><br><span class="line"><span class="comment">(2)在计算i++</span></span><br><span class="line"><span class="comment">①先加载i的值“1”</span></span><br><span class="line"><span class="comment">②再i自增，i=2</span></span><br><span class="line"><span class="comment">(3)再计算j++</span></span><br><span class="line"><span class="comment">①先加载j的值&quot;5&quot;</span></span><br><span class="line"><span class="comment">②再j自增，j=6</span></span><br><span class="line"><span class="comment">(4)算  加法</span></span><br><span class="line"><span class="comment">i + 5 = 6</span></span><br><span class="line"><span class="comment">(5)算乘法</span></span><br><span class="line"><span class="comment">5 * 6 = 30</span></span><br><span class="line"><span class="comment">(6)赋值</span></span><br><span class="line"><span class="comment">j = 30</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="2-4-3-比较运算符"><a href="#2-4-3-比较运算符" class="headerlink" title="2.4.3 比较运算符"></a>2.4.3 比较运算符</h3><p>大于：&gt;</p><p>小于：&lt;</p><p>大于等于：&gt;=</p><p>小于等于：&lt;=</p><p>等于：==        注意区分赋值运算符的=</p><p>不等于：!=</p><blockquote><p>注意：比较表达式的运算结果一定只有true/false</p><p>比较表达式可以作为（1）条件（2）逻辑运算符的操作数</p></blockquote><h3 id="2-4-4-逻辑运算符"><a href="#2-4-4-逻辑运算符" class="headerlink" title="2.4.4 逻辑运算符"></a>2.4.4 逻辑运算符</h3><blockquote><p>逻辑运算符的操作数必须是布尔值，结果也是布尔值</p></blockquote><p>逻辑与：&amp;<br>    运算规则：只有左右两边都为true，结果才为true。<br>    例如：true &amp; true 结果为true<br>           false &amp; true 结果为false<br>            true &amp; false 结果为false<br>            false &amp; false 结果为false<br>逻辑或：|<br>    运算规则：只要左右两边有一个为true，结果就为true。<br>    例如：true | true 结果为true<br>           false | true 结果为true<br>           true | false 结果为true<br>            false | false 结果为false<br>逻辑异或：^<br>    运算规则：只有左右两边不同，结果才为true。<br>    例如：true ^ true 结果为false<br>            false ^ true 结果为true<br>            true ^ false 结果为true<br>            false ^ false 结果为false            </p><p>逻辑非：!<br>    运算规则：布尔值取反<br>    例如：!true 为false<br>            !false 为true</p><p>短路与：&amp;&amp;<br>    运算规则：只有左右两边都为true，结果才为true。<br>    例如：true &amp; true 结果为true<br>            true &amp; false 结果为false<br>            false &amp; ?  结果就为false<br>    它和逻辑与不同的是当&amp;&amp;左边为false时，右边就不看了。</p><p>短路或：||<br>    运算规则：只要左右两边有一个为true，结果就为true。<br>    例如：true | ? 结果为treu<br>           false | true 结果为true<br>            false | false 结果为false<br>    它和逻辑或不同的是当||左边为true时，右边就不看了。</p><blockquote><p>开发中一般用短路与和短路或比较多</p></blockquote><p>面试题：&amp;&amp; 和 &amp;的区别？</p><blockquote><p>&amp;&amp;当左边为false，右边不计算</p><p>&amp;不管左边是true还是false，右边都要计算</p></blockquote><h3 id="2-4-5-条件运算符"><a href="#2-4-5-条件运算符" class="headerlink" title="2.4.5 条件运算符"></a>2.4.5 条件运算符</h3><p> ? : </p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件表达式 ? 结果表达式<span class="number">1</span> : 结果表达式<span class="number">2</span></span><br></pre></td></tr></table></figure><p>运算规则：</p><p>整个表达式的结果：当条件表达式为true时，就取结果表达式1的值，否则就取结果表达式2的值</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）<span class="keyword">boolean</span>类型</span><br><span class="line"><span class="keyword">boolean</span> marry = <span class="keyword">true</span>;</span><br><span class="line">System.out.println(marry? <span class="string">&quot;已婚&quot;</span> : <span class="string">&quot;未婚&quot;</span>);</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）求最值</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> max = i&gt;=j ? i : j;</span><br><span class="line"><span class="comment">//当i&gt;=j时，max就赋值为i的值，否则就赋值为j的值</span></span><br></pre></td></tr></table></figure><h3 id="2-4-6-位运算符"><a href="#2-4-6-位运算符" class="headerlink" title="2.4.6 位运算符"></a>2.4.6 位运算符</h3><p>左移：&lt;&lt;</p><p>​    运算规则：左移几位就相当于乘以2的几次方</p><p>右移：&gt;&gt;</p><p>​    运算规则：右移几位就相当于除以2的几次方</p><p>无符号右移：&gt;&gt;&gt;</p><p>​    运算规则：往右移动后，左边空出来的位直接补0，不看符号位</p><p>按位与：&amp;</p><p>​    运算规则：</p><p>​        1 &amp; 1 结果为1</p><p>​        1 &amp; 0 结果为0</p><p>​        0 &amp; 1 结果为0</p><p>​        0 &amp; 0 结果为0</p><p>按位或：|</p><p>​    运算规则：</p><p>​        1 | 1 结果为1</p><p>​        1 | 0 结果为1</p><p>​        0 | 1 结果为1</p><p>​        0 &amp; 0 结果为0</p><p>按位异或：^</p><p>​    运算规则：</p><p>​        1 ^ 1 结果为0</p><p>​        1 ^ 0 结果为1</p><p>​        0 ^ 1 结果为1</p><p>​        0 ^ 0 结果为0</p><p>按位取反：~</p><p>​     运算规则：~0就是1  </p><p>​               ~1就是0</p><blockquote><p>如何区分&amp;,|,^是逻辑运算符还是位运算符？</p><p>如果操作数是boolean类型，就是逻辑运算符，如果操作数是整数，那么就位运算符。</p></blockquote><h3 id="2-4-7-运算符优先级"><a href="#2-4-7-运算符优先级" class="headerlink" title="2.4.7 运算符优先级"></a>2.4.7 运算符优先级</h3><p><img data-src="/upload_image/java2021_05_31/1553858424335.png" alt="1553858424335"></p><p>提示说明：</p><p>（1）表达式不要太复杂</p><p>（2）先算的使用()</p><h3 id="2-4-8-运算符操作数类型说明"><a href="#2-4-8-运算符操作数类型说明" class="headerlink" title="2.4.8 运算符操作数类型说明"></a>2.4.8 运算符操作数类型说明</h3><p>1、算术运算符</p><p>数字和单个字符可以使用算术运算符。</p><p>其中+，当用于字符串时，表示拼接。</p><p>2、赋值运算符</p><p>右边的常量值、表达式的值、变量的值的类型必须与左边的变量一致或兼容（可以实现自动类型转换）或使用强制类型转换可以成功。</p><p>3、比较运算符</p><p>其他的比较运算符都是只能用于8种基本数据类型。</p><p>其中的==和!=可以用于引用数据类型的比较，用于比较对象的地址。（后面讲）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">System.out.println(i==j);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">&#x27;帅&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">&#x27;帅&#x27;</span>;</span><br><span class="line">System.out.println(c1 == c2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>4、逻辑运算符</p><p>逻辑运算符的操作数必须是boolean值</p><p>5、条件运算符</p><p>?前面必须是条件，必须是boolean值</p><p>结果表达式1和结果表达式2要保持类型一致或兼容</p><p>6、位运算符</p><p>一般用于整数系列</p><blockquote><p>以上运算符都是针对基本数据类型设计的。</p><p>能够用于引用数据类型只有基本的赋值运算符=，和比较运算符中的==和!=。其他运算符都不能用于引用数据类型。</p><p>其中字符串类型还有一个+，表示拼接。</p></blockquote><h1 id="第三章-流程控制语句结构"><a href="#第三章-流程控制语句结构" class="headerlink" title="第三章 流程控制语句结构"></a>第三章 流程控制语句结构</h1><p>流程控制语句结构分为：</p><p>1、顺序结构：从上到下依次执行</p><p>2、分支结构：多个分支选择其中一个分支执行</p><p>3、循环结构：重复执行某些代码</p><h2 id="3-1-顺序结构"><a href="#3-1-顺序结构" class="headerlink" title="3.1 顺序结构"></a>3.1 顺序结构</h2><p>执行过程：从上到下顺序执行</p><h3 id="3-1-1-输出语句"><a href="#3-1-1-输出语句" class="headerlink" title="3.1.1 输出语句"></a>3.1.1 输出语句</h3><p>1、System.out.print(输出内容); #输出内容后不换行</p><p>2、System.out.println(输出内容);  #输出内容后换行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#输出常量</span><br><span class="line">System.out.print(<span class="number">1</span>);</span><br><span class="line">System.out.print(<span class="string">&#x27;尚&#x27;</span>);</span><br><span class="line">System.out.print(<span class="number">44.4</span>);</span><br><span class="line">System.out.print(<span class="keyword">true</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line"></span><br><span class="line">#输出变量</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;尚&#x27;</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">44.4</span>;</span><br><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line">String school = <span class="string">&quot;尚硅谷&quot;</span>;</span><br><span class="line">System.out.print(a);</span><br><span class="line">System.out.print(c);</span><br><span class="line">System.out.print(d);</span><br><span class="line">System.out.print(b);</span><br><span class="line">System.out.print(school);</span><br><span class="line"></span><br><span class="line">#输出拼接结果</span><br><span class="line">System.out.print(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">System.out.print(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line">System.out.print(<span class="string">&quot;d = &quot;</span> + d);</span><br><span class="line">System.out.print(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">System.out.print(<span class="string">&quot;school = &quot;</span> + school);</span><br></pre></td></tr></table></figure><h3 id="3-1-2-输入语句"><a href="#3-1-2-输入语句" class="headerlink" title="3.1.2 输入语句"></a>3.1.2 输入语句</h3><p>键盘输入代码的三个步骤：</p><p>1、准备Scanner类型的变量</p><p>2、提示输入xx</p><p>3、接收输入内容</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、准备Scanner类型的变量</span></span><br><span class="line">java.util.Scanner input = <span class="keyword">new</span> java.util.Scanner(System.in);<span class="comment">//System.in默认代表键盘输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、提示输入xx</span></span><br><span class="line">System.out.print(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、接收输入内容</span></span><br><span class="line"><span class="keyword">int</span> num = input.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//列出各种数据类型的输入</span></span><br><span class="line"><span class="keyword">int</span> num = input.nextInt();</span><br><span class="line"><span class="keyword">long</span> bigNum = input.nextLong();</span><br><span class="line"><span class="keyword">double</span> d = input.nextDouble();</span><br><span class="line"><span class="keyword">boolean</span> b = input.nextBoolean();</span><br><span class="line">String s = input.next();</span><br><span class="line"><span class="keyword">char</span> c = input.next().charAt(<span class="number">0</span>);<span class="comment">//先按照字符串接收，然后再取字符串的第一个字符（下标为0）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-2-分支结构"><a href="#3-2-分支结构" class="headerlink" title="3.2 分支结构"></a>3.2 分支结构</h2><p>分支结构：根据条件选择性的执行某些代码</p><p>分为：</p><p>1、条件判断：if…else系列</p><p>2、选择结构：switch…case系列</p><h3 id="3-2-1-条件判断"><a href="#3-2-1-条件判断" class="headerlink" title="3.2.1 条件判断"></a>3.2.1 条件判断</h3><h4 id="1、单分支结构"><a href="#1、单分支结构" class="headerlink" title="1、单分支结构"></a>1、单分支结构</h4><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    当条件表达式成立(<span class="keyword">true</span>)时需要执行的语句块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>​    条件成立，就执行{}其中的语句块，不成立就不执行。</p><blockquote><p>注意：</p><p>（1）if(条件表达式)中的条件表达式的结果必须是boolean类型</p><p>（2）当{}中的语句只有一个语句（简单的语句，也可以是一个复合语句）时，可以省略{}，但是我们不建议省略</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略&#123;&#125;的情况</span></span><br><span class="line"><span class="keyword">if</span>(score&lt;<span class="number">0</span> || score&gt;<span class="number">100</span>)</span><br><span class="line">System.out.println(<span class="string">&quot;输入有误！&quot;</span>);<span class="comment">//简单的语句</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//复合语句</span></span><br><span class="line"><span class="keyword">if</span>(score==<span class="number">100</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;满分&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">80</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">60</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> year = <span class="number">2019</span>;</span><br><span class="line"><span class="keyword">int</span> days = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">if</span>(year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span>!=<span class="number">0</span> || year%<span class="number">400</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    days= <span class="number">29</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、双分支结构"><a href="#2、双分支结构" class="headerlink" title="2、双分支结构"></a>2、双分支结构</h4><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    当条件表达式成立(<span class="keyword">true</span>)时需要执行的语句块<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    当条件表达式不成立(<span class="keyword">false</span>)时需要执行的语句块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>​    当条件表达式成立(true)时执行语句块1，否则执行语句块2</p><blockquote><p>注意：</p><p>（1）if(条件表达式)中的条件表达式的结果必须是boolean类型</p><p>（2）当{}中的语句只有一个语句（简单的语句，也可以是一个复合语句）时，可以省略{}，但是我们不建议</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(num + <span class="string">&quot;是偶数&quot;</span>)；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     System.out.println(num + <span class="string">&quot;是奇数&quot;</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、多分支结构"><a href="#3、多分支结构" class="headerlink" title="3、多分支结构"></a>3、多分支结构</h4><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">1</span>)&#123;</span><br><span class="line">    当条件表达式<span class="number">1</span>成立的时候，执行的语句块<span class="number">1</span>；</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式<span class="number">2</span>)&#123;</span><br><span class="line">    当条件表达式<span class="number">1</span>不成立，</span><br><span class="line">      条件表达式<span class="number">2</span>成立的时候，执行的语句块<span class="number">2</span>；</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式<span class="number">3</span>)&#123;</span><br><span class="line">    当条件表达式<span class="number">1</span>不成立，</span><br><span class="line">       条件表达式<span class="number">2</span>也不成立，</span><br><span class="line">      条件表达式<span class="number">3</span>成立的时候，执行的语句块<span class="number">3</span>；</span><br><span class="line">&#125;</span><br><span class="line">。。。</span><br><span class="line">【<span class="keyword">else</span>&#123;</span><br><span class="line">当以上所有的条件表达式都不成立，需要执行的语句块n+<span class="number">1</span>;</span><br><span class="line">&#125;】</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>（1）多个条件顺序往下判断，如果上面有一个条件成立了，下面的条件就不看了</p><p>（2）多个分支也只会执行其中的一个</p><blockquote><p>注意：</p><p>（1）每一个条件表达式都必须是boolean值</p><p>（2）当{}中只有一个语句时，也可以省略{}，但不建议省略</p><p>（3）当多个条件是“互斥”关系（没有重叠部分），顺序可以随意；</p><p>​          当多个条件是“包含”关系（有重叠部分），顺序不能随意，小的在上，大的在下面</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">78</span>;</span><br><span class="line"><span class="keyword">if</span>(score==<span class="number">100</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;满分&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">80</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">60</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、嵌套"><a href="#4、嵌套" class="headerlink" title="4、嵌套"></a>4、嵌套</h4><p>执行过程：</p><p>​    当嵌套在if中，就是当外面的if成立时，才会看里面的条件判断；</p><p>​    当嵌套在else中，就当外面的else满足时，才会看里面的条件判断；</p><h3 id="3-2-2-选择结构"><a href="#3-2-2-选择结构" class="headerlink" title="3.2.2 选择结构"></a>3.2.2 选择结构</h3><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">        语句块<span class="number">1</span>;</span><br><span class="line">        【<span class="keyword">break</span>;】</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">        语句块<span class="number">2</span>;</span><br><span class="line">        【<span class="keyword">break</span>;】   </span><br><span class="line">    。。。</span><br><span class="line">   【<span class="keyword">default</span>:</span><br><span class="line">        语句块n+<span class="number">1</span>;</span><br><span class="line">        【<span class="keyword">break</span>;】</span><br><span class="line">     】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>（1）入口</p><p>①当switch(表达式)的值与case后面的某个常量值匹配，就从这个case进入；</p><p>②当switch(表达式)的值与case后面的所有常量值都不匹配，寻找default分支进入;</p><p>（2）一旦从“入口”进入switch，就会顺序往下执行，直到遇到“出口”</p><p>（3）出口</p><p>①自然出口：遇到了switch的结束}</p><p>②中断出口：遇到了break等</p><blockquote><p>注意：</p><p>（1）switch(表达式)的值的类型，只能是：4种基本数据类型（byte,short,int,char），两种引用数据类型（枚举、String）</p><p>（2）case后面必须是常量值，而且不能重复</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> month = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">switch</span>(month)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;春季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;夏季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;秋季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;冬季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;输入有误！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-循环结构"><a href="#3-3-循环结构" class="headerlink" title="3.3 循环结构"></a>3.3 循环结构</h2><p>循环结构：</p><p>​    “重复”执行某些代码</p><p>循环结构的分类：</p><p>1、for循环</p><p>2、while循环</p><p>3、do…while循环</p><h3 id="3-3-1-for循环"><a href="#3-3-1-for循环" class="headerlink" title="3.3.1 for循环"></a>3.3.1 for循环</h3><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    循环体语句块；</span><br><span class="line">    <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(初始化表达式; 循环条件; 迭代表达式)&#123;</span><br><span class="line">    循环体语句块；（需要重复执行的代码）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>（1）初始化表达式;</p><p>（2）判断循环条件;</p><p>（3）如果循环条件成立，先执行循环体语句块；然后执行迭代表达式，再回到（2）…</p><p>（4）如果循环条件不成立，会结束for；</p><p>​         或者在当前循环中遇到break语句，也会结束当前for循环;</p><blockquote><p>注意：</p><p>（1）for(;;)中的两个；是不能多也不能少</p><p>（2）循环条件必须是boolean类型</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历1-100之间的偶数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)&#123;<span class="comment">//每次循环的步幅是1</span></span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历1-100之间的偶数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">100</span>; i+=<span class="number">2</span>)&#123;<span class="comment">//每次循环的步幅是2</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-while循环"><a href="#3-3-2-while循环" class="headerlink" title="3.3.2 while循环"></a>3.3.2 while循环</h3><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">    循环体语句块;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">经典的形式：</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">循环体语句块;</span><br><span class="line">    <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>（1）先判断循环条件</p><p>（2）如果循环条件成立，就执行循环体语句块；然后回到（1）</p><p>（3）如果循环条件不成立，就结束while循环；</p><p>​     如果在循环体语句块中，遇到break，也会结束while循环；</p><blockquote><p>注意：</p><p>（1）while(循环条件)中循环条件必须是boolean类型</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历1-100之间的偶数</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(num&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">    num+=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-3-do…while循环"><a href="#3-3-3-do…while循环" class="headerlink" title="3.3.3 do…while循环"></a>3.3.3 do…while循环</h3><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体语句块;</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件);</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>（1）先执行一次循环体语句块；</p><p>（2）判断循环条件</p><p>（3）如果循环条件成立，再次执行循环体语句块；然后回到（2）…</p><p>（4）如果循环条件不成立，就结束do…while循环；</p><p>​         如果在循环体语句块中，遇到break，也会结束do…while循环；</p><blockquote><p>注意：</p><p>（1）while(循环条件)中循环条件必须是boolean类型</p><p>（2）do{}while();最后有一个分号</p><p>（3）do…while结构的循环体语句是至少会执行一次，这个和for和while是不一样的</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从键盘输入整数，统计正数、负数的个数，输入0结束</span></span><br><span class="line">java.util.Scanner input = <span class="keyword">new</span> java.util.Scanner(System.in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> positive = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> negative = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;请输入整数（0结束）：&quot;</span>);</span><br><span class="line">    num = input.nextInt();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        positive++;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        negatvie++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(num!=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;正数的个数：&quot;</span> + positive);</span><br><span class="line">System.out.println(<span class="string">&quot;负数的个数：&quot;</span> + negatvie);</span><br></pre></td></tr></table></figure><h3 id="3-3-4-三种循环的选择"><a href="#3-3-4-三种循环的选择" class="headerlink" title="3.3.4 三种循环的选择"></a>3.3.4 三种循环的选择</h3><p>原则：三种循环之间是可以互相转换的，都能实现循环的功能</p><p>建议（习惯上）：当我们次数比较明显的时候，或者说从几循环到几的时候，一般先考虑for；</p><p>​                当循环体语句块至少要执行一次的时候，一般先考虑do…while；</p><p>​                    当循环条件比较明显，但是次数不明显，循环体语句块也不是至少执行一次，那么可以考虑while结构；</p><p>三种循环结构都具有四要素：</p><p>（1）循环变量的初始化表达式</p><p>（2）循环条件</p><p>（3）循环变量的修改的迭代表达式</p><p>（4）循环体语句块</p><h3 id="3-3-5-跳转语句"><a href="#3-3-5-跳转语句" class="headerlink" title="3.3.5 跳转语句"></a>3.3.5 跳转语句</h3><p>1、break</p><p>用于：</p><p>（1）switch结构</p><p>作用：结束switch结构</p><p>（2）循环结构</p><p>作用：结束<strong>当前</strong>循环</p><p>2、continue </p><p>用于：</p><p>只能用于循环结构</p><p>作用：提前结束本次循环，继续下一次循环</p><p>3、return（后面讲）</p><h1 id="第四章-数组"><a href="#第四章-数组" class="headerlink" title="第四章 数组"></a>第四章 数组</h1><h2 id="4-1-数组的相关概念和名词（了解）"><a href="#4-1-数组的相关概念和名词（了解）" class="headerlink" title="4.1 数组的相关概念和名词（了解）"></a>4.1 数组的相关概念和名词（了解）</h2><p>1、数组(array)：</p><p>​    一组具有相同数据类型的数据的按照一定顺序排列的集合。</p><p>​       把有限的几个相同类型的变量使用一个名称来进行统一管理。</p><p>2、数组名：</p><p>​    （1）这个数组名，代表的是一组数</p><p>​    （2）这个数组名中存储的整个数组的“首地址”</p><p>3、下标(index)：</p><p>​    我们使用编号、索引、下标来区别表示一组数当中某一个。</p><p>​    范围：[0,数组长度-1]     </p><p>​    例如：for(int i = 0;  i&lt;arr.length; i++){}</p><p>4、元素(element)：</p><p>​    这一组中的的每一个数据都是元素。</p><p>​    如何表示数组元素？  数组名[下标]</p><p>5、数组的长度(length)</p><p>​    数组中元素的总个数。</p><p>​    如何获取数组长度？  数组名.length</p><blockquote><p>注意：名称是为了沟通的方便，概念不用一字不落背下来</p></blockquote><h2 id="4-2-数组的相关语法"><a href="#4-2-数组的相关语法" class="headerlink" title="4.2 数组的相关语法"></a>4.2 数组的相关语法</h2><h3 id="4-2-1-数组的声明"><a href="#4-2-1-数组的声明" class="headerlink" title="4.2.1 数组的声明"></a>4.2.1 数组的声明</h3><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//推荐</span></span><br><span class="line">元素的数据类型[] 数组名;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//也对，但是不推荐</span></span><br><span class="line">元素的数据类型  数组名[];</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要存储一组整数</span></span><br><span class="line"><span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要存储一组单字符</span></span><br><span class="line"><span class="keyword">char</span>[] array;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要存储一组字符串</span></span><br><span class="line">String[] array;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-数组的初始化"><a href="#4-2-2-数组的初始化" class="headerlink" title="4.2.2 数组的初始化"></a>4.2.2 数组的初始化</h3><p>初始化的目的：（1）确定数组的长度（2）为元素赋值</p><p>两种初始化方式：</p><p>1、动态初始化</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定数组长度</span></span><br><span class="line">数组名 = <span class="keyword">new</span> 元素的数据类型[长度];</span><br><span class="line"></span><br><span class="line"><span class="comment">//为元素赋值</span></span><br><span class="line">数组名[下标] = 值; <span class="comment">//这个值可以是个常量值，也可以是个表达式的计算结果，也可以是键盘输入的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果每个元素的赋值比较有规律，通常使用for循环赋值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;长度; i++)&#123;</span><br><span class="line">    数组名[下标] = 值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问：如果只指定数组长度，没有为元素手动赋值，那么元素有值吗？</p><p>有默认值</p><p>（1）基本数据类型</p><p>​    byte,short,int,long：0</p><p>​    float,double：0.0</p><p>​    char：\u0000</p><p>​    boolean：false</p><p>（2）引用数据类型</p><p>​    统统都是null</p></blockquote><p>2、静态初始化</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组名 = <span class="keyword">new</span> 元素的数据类型[]&#123;值列表&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int[] arr = new int[5]&#123;1,2,3,4,5&#125;;//错误的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更简洁</span></span><br><span class="line"><span class="comment">//当声明与静态初始化一起完成时，可以简化</span></span><br><span class="line">元素的数据类型[] 数组名 = &#123;值列表&#125;;</span><br></pre></td></tr></table></figure><p>适用场合：</p><p>​    当数组的元素是已知的有限个时，可以使用静态初始化。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] weeks = &#123;<span class="string">&quot;monday&quot;</span>,<span class="string">&quot;tuesday&quot;</span>,<span class="string">&quot;wednesday&quot;</span>,<span class="string">&quot;thursday&quot;</span>,<span class="string">&quot;friday&quot;</span>,<span class="string">&quot;saturday&quot;</span>,<span class="string">&quot;sunday&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] daysOfMonths = &#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] letters = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-数组的遍历"><a href="#4-2-3-数组的遍历" class="headerlink" title="4.2.3 数组的遍历"></a>4.2.3 数组的遍历</h3><p>for循环遍历数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;数组名.lenght; i++)&#123;</span><br><span class="line">    <span class="comment">//或赋值</span></span><br><span class="line">    数组名[i] = 值;</span><br><span class="line">    <span class="comment">//或显示</span></span><br><span class="line">    System.out.println(数组名[i])；</span><br><span class="line">    <span class="comment">//或其他操作</span></span><br><span class="line">    <span class="comment">//例如：判断是否是偶数</span></span><br><span class="line">    <span class="keyword">if</span>(数组名[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4-数组的内存分析"><a href="#4-2-4-数组的内存分析" class="headerlink" title="4.2.4 数组的内存分析"></a>4.2.4 数组的内存分析</h3><p>元素是基本数据类型的一维数组内存分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] arr &#x3D; &#123;1,2,3,4,5&#125;;</span><br></pre></td></tr></table></figure><p><img data-src="/upload_image/java2021_05_31/1558400311779.png" alt="1558400311779"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    arr[i] = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="/upload_image/java2021_05_31/1558400323314.png" alt="1558400323314"></p><h2 id="4-3-数组的相关算法"><a href="#4-3-数组的相关算法" class="headerlink" title="4.3 数组的相关算法"></a>4.3 数组的相关算法</h2><h3 id="4-3-1-数组找最值"><a href="#4-3-1-数组找最值" class="headerlink" title="4.3.1 数组找最值"></a>4.3.1 数组找最值</h3><p>1、数组中找最值</p><p>思路：</p><p>（1）先假设第一个元素最大/最小</p><p>（2）然后用max/min与后面的元素一一比较</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、数组中找最值及其下标</p><p>情况一：找最值及其第一次出现的下标</p><p>思路：</p><p>（1）先假设第一个元素最大/最小</p><p>（2）然后用max/min与后面的元素一一比较</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">        index = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; arr[maxIndex])&#123;</span><br><span class="line">        maxIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;最大值：&quot;</span> + arr[maxIndex]);</span><br></pre></td></tr></table></figure><p>情况二：找最值及其所有最值的下标（即可能最大值重复）</p><p>思路：</p><p>（1）先找最大值</p><p>①假设第一个元素最大</p><p>②用max与后面的元素一一比较</p><p>（2）遍历数组，看哪些元素和最大值是一样的</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历数组，看哪些元素和最大值是一样的</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(max == arr[i])&#123;</span><br><span class="line">        System.out.print(i+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-数组统计：求总和、均值、统计偶数个数等"><a href="#4-3-2-数组统计：求总和、均值、统计偶数个数等" class="headerlink" title="4.3.2 数组统计：求总和、均值、统计偶数个数等"></a>4.3.2 数组统计：求总和、均值、统计偶数个数等</h3><p>思路：遍历数组，挨个的累加，判断每一个元素</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//求总和、均值</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//因为0加上任何数都不影响结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    sum += arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> avg = (<span class="keyword">double</span>)sum/arr.length;</span><br></pre></td></tr></table></figure><p>示例代码2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求总乘积</span></span><br><span class="line"><span class="keyword">long</span> result = <span class="number">1</span>;<span class="comment">//因为1乘以任何数都不影响结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    result *= arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//统计偶数个数</span></span><br><span class="line"><span class="keyword">int</span> even = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        even++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-反转"><a href="#4-3-3-反转" class="headerlink" title="4.3.3 反转"></a>4.3.3 反转</h3><p>方法有两种：</p><p>1、借助一个新数组</p><p>2、首尾对应位置交换</p><p>第一种方式示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)先创建一个新数组</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)复制元素</span></span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newArr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[len -<span class="number">1</span> - i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)舍弃旧的，让arr指向新数组</span></span><br><span class="line">arr = newArr;<span class="comment">//这里把新数组的首地址赋值给了arr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)计算要交换的次数：  次数 = arr.length/2</span></span><br><span class="line"><span class="comment">//(2)首尾交换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length/<span class="number">2</span>; i++)&#123;<span class="comment">//循环的次数就是交换的次数</span></span><br><span class="line">    <span class="comment">//首  与  尾交换</span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[arr.length-<span class="number">1</span>-i];</span><br><span class="line">arr[arr.length-<span class="number">1</span>-i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-4-复制"><a href="#4-3-4-复制" class="headerlink" title="4.3.4 复制"></a>4.3.4 复制</h3><p>应用场景：</p><p>1、扩容</p><p>2、备份</p><p>3、截取</p><p>示例代码：扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要把arr数组扩容，增加1个位置</span></span><br><span class="line"><span class="comment">//(1)先创建一个新数组，它的长度 = 旧数组的长度+1</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)复制元素</span></span><br><span class="line"><span class="comment">//注意：i&lt;arr.length   因位arr比newArr短，避免下标越界</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)把新元素添加到newArr的最后</span></span><br><span class="line">newArr[newArr.length-<span class="number">1</span>] = 新值;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)如果下面继续使用arr，可以让arr指向新数组</span></span><br><span class="line">arr = newArr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：备份</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建一个长度和原来的数组一样的新数组</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、复制元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：截取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> end = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建一个新数组，新数组的长度 = end-start + 1;</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[end-start+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、赋值元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newArr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[start + i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newArr.length; i++)&#123;</span><br><span class="line">    System.out.println(newArr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-5-查找"><a href="#4-3-5-查找" class="headerlink" title="4.3.5 查找"></a>4.3.5 查找</h3><p>查找分为两种：</p><p>1、顺序查找：挨个看</p><p>​    对数组没要求</p><p>2、二分查找：对折对折再对折</p><p>​    对数组有要求，元素必须有大小顺序的</p><p>顺序查找示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] == value)&#123;</span><br><span class="line">        index = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(value + <span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(value + <span class="string">&quot;的下标是&quot;</span> + index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2、编写代码，使用二分查找法在数组中查找 int value = 2;是否存在，如果存在显示下标，不存在显示不存在。</span></span><br><span class="line"><span class="comment">已知数组：int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam2</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;<span class="comment">//数组是有序的</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="comment">//找到结束</span></span><br><span class="line">            <span class="keyword">if</span>(value == arr[mid])&#123;</span><br><span class="line">                index = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//没找到</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; arr[mid])&#123;<span class="comment">//往右继续查找</span></span><br><span class="line">                <span class="comment">//移动左边界，使得mid往右移动</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value &lt; arr[mid])&#123;<span class="comment">//往左边继续查找</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(value + <span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(value + <span class="string">&quot;的下标是&quot;</span> + index);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用for</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam2</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;<span class="comment">//数组是有序的</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>,right=arr.length-<span class="number">1</span>,mid = (left+right)/<span class="number">2</span>; left&lt;=right; mid = (left + right)/<span class="number">2</span>)&#123;</span><br><span class="line">             <span class="comment">//找到结束</span></span><br><span class="line">            <span class="keyword">if</span>(value == arr[mid])&#123;</span><br><span class="line">                index = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//没找到</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; arr[mid])&#123;<span class="comment">//往右继续查找</span></span><br><span class="line">                <span class="comment">//移动左边界，使得mid往右移动</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value &lt; arr[mid])&#123;<span class="comment">//往左边继续查找</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(value + <span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(value + <span class="string">&quot;的下标是&quot;</span> + index);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-6-排序"><a href="#4-3-6-排序" class="headerlink" title="4.3.6 排序"></a>4.3.6 排序</h3><p>数组的排序算法有千万种，我们只讲了两种：</p><p>1、冒泡排序</p><p>2、简单的直接排序</p><p>示例代码：冒泡：从小到大，从左到右两两比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;<span class="comment">//外循环的次数 = 轮数 = 数组的长度-1</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第1轮，i=1,从左到右两两比较，arr[0]与arr[1]。。。。。arr[3]与arr[4]</span></span><br><span class="line"><span class="comment">    第2轮，i=2,从左到右两两比较，arr[0]与arr[1]。。。。。arr[2]与arr[3]</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    arr[j]与arr[j+1]比较</span></span><br><span class="line"><span class="comment">    找两个关键点：（1）j的起始值：0（2）找j的终止值，依次是3,2,1,0，得出j&lt;arr.length-i</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr.length-i; j++)&#123;</span><br><span class="line">        <span class="comment">//两两比较</span></span><br><span class="line">        <span class="comment">//从小到大，说明前面的比后面的大，就交换</span></span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：从大到小，从右到左</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] arr = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;<span class="comment">//外循环的次数 = 轮数 = 数组的长度-1</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第1轮，i=1，从右到左两两比较，arr[8]与arr[7]，arr[7]与arr[6]....arr[1]与arr[0]</span></span><br><span class="line"><span class="comment">    第2轮，i=2，从右到左两两比较，arr[8]与arr[7]，arr[7]与arr[6]....arr[2]与arr[1]</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    第8轮，i=8，从右到左两两比较，arr[8]与arr[7]</span></span><br><span class="line"><span class="comment">       arr[j]与arr[j-1]</span></span><br><span class="line"><span class="comment">    找两个关键点：（1）j的起始值：8（2）找j的终止值，依次是1,2,3,。。。8，得出j&gt;=i</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">8</span>; j&gt;=i; j--)&#123;</span><br><span class="line">        <span class="comment">//从大到小，后面的元素 &gt; 前面的元素，就交换</span></span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">            arr[j-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例代码：简单的直接选择排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;<span class="comment">//外循环的次数 = 轮数 = 数组的长度-1</span></span><br><span class="line">    <span class="comment">//（1）找出本轮未排序元素中的最值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    未排序元素：</span></span><br><span class="line"><span class="comment">    第1轮：i=1,未排序，[0,4]</span></span><br><span class="line"><span class="comment">    第2轮：i=2,未排序，[1,4]</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    每一轮未排序元素的起始下标：0,1,2,3，正好是i-1的</span></span><br><span class="line"><span class="comment">    未排序的后面的元素依次：</span></span><br><span class="line"><span class="comment">    第1轮：[1,4]  j=1,2,3,4</span></span><br><span class="line"><span class="comment">    第2轮：[2,4]  j=2,3,4</span></span><br><span class="line"><span class="comment">    第3轮：[3,4]  j=3,4</span></span><br><span class="line"><span class="comment">    第4轮：[4,4]  j=4</span></span><br><span class="line"><span class="comment">    j的起点是i，终点都是4</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[i-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index = i-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;arr.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; max)&#123;</span><br><span class="line">            max = arr[j];</span><br><span class="line">            index = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（2）如果这个最值没有在它应该在的位置，就与这个位置的元素交换</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第1轮，最大值应该在[0]</span></span><br><span class="line"><span class="comment">    第2轮，最大值应该在[1]</span></span><br><span class="line"><span class="comment">    第3轮，最大值应该在[2]</span></span><br><span class="line"><span class="comment">    第4轮，最大值应该在[3]</span></span><br><span class="line"><span class="comment">    正好是i-1的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(index != i-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//交换arr[i-1]与arr[index]</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i-<span class="number">1</span>];</span><br><span class="line">        arr[i-<span class="number">1</span>] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">System.out.print(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-二维数组"><a href="#4-4-二维数组" class="headerlink" title="4.4 二维数组"></a>4.4 二维数组</h2><p>二维数组的标记：[][]</p><h3 id="4-4-1-相关的表示方式"><a href="#4-4-1-相关的表示方式" class="headerlink" title="4.4.1 相关的表示方式"></a>4.4.1 相关的表示方式</h3><p>（1）二维数组的长度/行数： </p><p>​    二维数组名.length</p><p>（2）二维数组的其中一行：</p><p>​    二维数组名[行下标]</p><p>​    行下标的范围：[0, 二维数组名.length-1]</p><p>（3）每一行的列数：</p><p>​    二维数组名[行下标].length</p><p>​       因为二维数组的每一行是一个一维数组</p><p>（4）每一个元素</p><p>​    二维数组名[行下标][列下标]</p><h3 id="4-4-2-二维数组的声明和初始化"><a href="#4-4-2-二维数组的声明和初始化" class="headerlink" title="4.4.2 二维数组的声明和初始化"></a>4.4.2 二维数组的声明和初始化</h3><p>1、二维数组的声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//推荐</span></span><br><span class="line"> 元素的数据类型[][] 二维数组的名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">元素的数据类型  二维数组名[][];</span><br><span class="line"><span class="comment">//不推荐</span></span><br><span class="line"> 元素的数据类型[]  二维数组名[];</span><br></pre></td></tr></table></figure><p>面试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] x, y[];</span><br><span class="line">&#x2F;&#x2F;x是一维数组，y是二维数组</span><br></pre></td></tr></table></figure><p>2、二维数组的初始化</p><p>（1）静态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">二维数组名 = <span class="keyword">new</span> 元素的数据类型[][]&#123;</span><br><span class="line">&#123;第一行的值列表&#125;, </span><br><span class="line">&#123;第二行的值列表&#125;,</span><br><span class="line">...</span><br><span class="line">&#123;第n行的值列表&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明与静态初始化一起完成</span></span><br><span class="line">元素的数据类型[][] 二维数组的名称 = &#123;</span><br><span class="line">&#123;第一行的值列表&#125;, </span><br><span class="line">&#123;第二行的值列表&#125;,</span><br><span class="line">...</span><br><span class="line">&#123;第n行的值列表&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（2）动态初始化（不规则：每一行的列数可能不一样）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）先确定总行数</span></span><br><span class="line">二维数组名 = <span class="keyword">new</span> 元素的数据类型[总行数][];</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）再确定每一行的列数</span></span><br><span class="line">二维数组名[行下标] = <span class="keyword">new</span> 元素的数据类型[该行的总列数];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)再为元素赋值</span></span><br><span class="line">二维数组名[行下标][列下标] = 值;</span><br></pre></td></tr></table></figure><p>（3）动态初始化（规则：每一行的列数是相同的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）确定行数和列数</span></span><br><span class="line">二维数组名 = <span class="keyword">new</span> 元素的数据类型[总行数][每一行的列数];</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）再为元素赋值</span></span><br><span class="line">二维数组名[行下标][列下标] = 值;</span><br></pre></td></tr></table></figure><h3 id="4-4-3-二维数组的遍历"><a href="#4-4-3-二维数组的遍历" class="headerlink" title="4.4.3 二维数组的遍历"></a>4.4.3 二维数组的遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0; i&lt;二维数组名.length; i++)&#123;</span><br><span class="line">    for(int j&#x3D;0; j&lt;二维数组名[i].length; j++)&#123;</span><br><span class="line">        System.out.print(二维数组名[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第五章-面向对象基础"><a href="#第五章-面向对象基础" class="headerlink" title="第五章 面向对象基础"></a>第五章 面向对象基础</h1><h2 id="5-1-类与对象"><a href="#5-1-类与对象" class="headerlink" title="5.1 类与对象"></a>5.1 类与对象</h2><p>1、类：一类具有相同特性的事物的抽象描述。</p><p>​      对象：类的一个个体，实例，具体的存在。</p><p>​     类是对象的设计模板。</p><p>2、如何声明类？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    成员列表：属性、方法、构造器、代码块、内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、如何创建对象？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名();  <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名(); <span class="comment">//有名对象</span></span><br></pre></td></tr></table></figure><h2 id="5-2-类的成员之一：属性"><a href="#5-2-类的成员之一：属性" class="headerlink" title="5.2 类的成员之一：属性"></a>5.2 类的成员之一：属性</h2><p>1、如何声明属性？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 数据类型  属性名;    <span class="comment">//属性有默认值</span></span><br><span class="line">    【修饰符】 数据类型  属性名 = 值; <span class="comment">//属性有初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：属性的类型可以是Java的任意类型，包括基本数据类型、引用数据类型（类、接口、数组等）</p></blockquote><p>总结：Java的数据类型</p><p>（1）基本数据类型</p><p>byte,short,int,long,float,double,char,boolean</p><p>（2）引用数据类型</p><p>①类：</p><p>​    例如：String、Student、Circle、System、Scanner、Math…</p><p>②接口：后面讲</p><p>③数组：</p><p>​    例如：int[]，String[]，char[]，int[][]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">这里把<span class="keyword">int</span>[]看成数组类型，是一种引用数据类型，右边赋值的是一个数组的对象</span><br><span class="line"></span><br><span class="line">元素的数据类型：<span class="keyword">int</span></span><br><span class="line">数组的数据类型：<span class="keyword">int</span>[]</span><br></pre></td></tr></table></figure><p>2、如何为属性赋值？</p><p>（1）在声明属性时显式赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 数据类型  属性名 = 值; <span class="comment">//属性有初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">char</span> gender = <span class="string">&#x27;男&#x27;</span>;<span class="comment">//显式赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStudent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + s1.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;性别：&quot;</span> + s1.gender);<span class="comment">//男</span></span><br><span class="line">        </span><br><span class="line">        s1.name = <span class="string">&quot;小薇&quot;</span>;<span class="comment">//修改属性的默认值</span></span><br><span class="line">        s1.gender = <span class="string">&#x27;女&#x27;</span>;<span class="comment">//修改属性的初始值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + s1.name);<span class="comment">//小薇</span></span><br><span class="line">        System.out.println(<span class="string">&quot;性别：&quot;</span> + s1.gender);<span class="comment">//女</span></span><br><span class="line">        </span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + s2.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;性别：&quot;</span> + s2.gender);<span class="comment">//男</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）创建对象之后赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 数据类型  属性名; <span class="comment">//属性有默认值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span>  类名();</span><br><span class="line"></span><br><span class="line"><span class="comment">//为对象的属性赋值</span></span><br><span class="line">对象名.属性名 = 值;</span><br></pre></td></tr></table></figure><p>3、如何访问属性的值？</p><p>（1）在本类的方法中访问</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;<span class="comment">//直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）在其他类的方法中访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCircle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        <span class="keyword">double</span> area = <span class="number">3.14</span> * c1.radius * c1.radius;<span class="comment">//对象名.属性名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、属性的特点</p><p>（1）属性有默认值</p><p>基本数据类型：</p><p>​    byte,short,int,long：0</p><p>​    float，double：0.0</p><p>​    char：\u0000</p><p>​    boolean：false</p><p>引用数据类型：</p><p>​    null</p><p>（2）每一个对象的属性是独立，互不干扰</p><p>5、对象属性的内存图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">char</span> gender = <span class="string">&#x27;男&#x27;</span>;<span class="comment">//显式赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStudent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + s1.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;性别：&quot;</span> + s1.gender);<span class="comment">//男</span></span><br><span class="line">        </span><br><span class="line">        s1.name = <span class="string">&quot;小薇&quot;</span>;</span><br><span class="line">        s1.gender = <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + s1.name);<span class="comment">//小薇</span></span><br><span class="line">        System.out.println(<span class="string">&quot;性别：&quot;</span> + s1.gender);<span class="comment">//女</span></span><br><span class="line">        </span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + s2.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;性别：&quot;</span> + s2.gender);<span class="comment">//男</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="/upload_image/java2021_05_31/1558659534754.png" alt="1558659534754"></p><h2 id="5-4-类的成员之二：方法"><a href="#5-4-类的成员之二：方法" class="headerlink" title="5.4 类的成员之二：方法"></a>5.4 类的成员之二：方法</h2><h3 id="5-4-1-方法的概念"><a href="#5-4-1-方法的概念" class="headerlink" title="5.4.1 方法的概念"></a>5.4.1 方法的概念</h3><p>方法（method）：代表一个独立的可复用的功能</p><p>目的/好处：</p><p>（1）复用</p><p>（2）简化代码</p><h3 id="5-4-2-方法的语法"><a href="#5-4-2-方法的语法" class="headerlink" title="5.4.2 方法的语法"></a>5.4.2 方法的语法</h3><p>1、方法的声明格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 返回值类型  方法名(【形参列表】)&#123;</span><br><span class="line">        方法体：实现功能的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>（1）【修饰符】：待讲</p><p>（2）返回值类型：</p><p>①void：表示无返回值</p><p>②非void：所有的Java数据类型都可以</p><p>（3）方法名：能很好的体现方法的功能</p><p>命名的规范：①见名知意②从第二个单词开始首字母大写</p><p>（4）【形参列表】：</p><p>​    在完成这个方法的功能时，需要一些数据，这些数据要由“调用者”来决定，那我们就可以设计形参。</p><p>​    语法格式：</p><p>​        ()：无参，空参</p><p>​        (数据类型  形参名)：一个形参</p><p>​        (数据类型1  形参名1,  ……,   数据类型n  形参名n)：n个形参</p><p>（5）方法体：实现方法的功能，最好一个方法就完成一个独立的功能。</p><p>2、方法的调用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本类同级别方法调用：直接调用</span></span><br><span class="line">【变量 = 】 方法名(【实参列表】);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在其他类的方法中调用</span></span><br><span class="line">【变量 = 】 对象名.方法名(【实参列表】);</span><br></pre></td></tr></table></figure><p>（1）是否传实参</p><p>看被调用的方法是否有形参</p><p>（2）是否接收返回值</p><p>看被调用的方法是否是void，如果是void，就不需要也不能接收，如果不是void，就可以接收。</p><p>3、方法的声明与调用的代码示例</p><p>（1）无参无返回值方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;半径：&quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printInfo();<span class="comment">//本类中调用无参无返回值方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;半径：&quot;</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCircle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        c1.printInfo(); <span class="comment">//其他类中调用无参无返回值方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）无参有返回值方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//  System.out.println(&quot;半径：&quot; + radius + &quot;，面积：&quot; + getArea());//本类中调用无参有返回值</span></span><br><span class="line">       <span class="keyword">double</span> area = getArea();<span class="comment">//本类中调用无参有返回值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;半径：&quot;</span> + radius + <span class="string">&quot;，面积：&quot;</span> + area);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCircle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        <span class="keyword">double</span> area = c1.getArea();</span><br><span class="line">        System.out.println(<span class="string">&quot;面积：&quot;</span> + area);</span><br><span class="line">        <span class="comment">//或</span></span><br><span class="line">        System.out.println(<span class="string">&quot;面积：&quot;</span> + c1.getArea());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）有参无返回值方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicTools</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printRectange</span><span class="params">(<span class="keyword">int</span> line, <span class="keyword">int</span> column, <span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=line; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=column; j++)&#123;</span><br><span class="line">                Sytem.out.print(sign);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printRectange(<span class="number">5</span>,<span class="number">10</span>,<span class="string">&#x27;%&#x27;</span>);<span class="comment">//本类中调用有参无返回值方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicTools</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printRectange</span><span class="params">(<span class="keyword">int</span> line, <span class="keyword">int</span> column, <span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=line; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=column; j++)&#123;</span><br><span class="line">                Sytem.out.print(sign);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GraphicTools tools = <span class="keyword">new</span> GraphicTools();</span><br><span class="line">        tools.printRectange(<span class="number">5</span>,<span class="number">10</span>,<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）有参有返回值方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">7</span>;</span><br><span class="line">        System.out.println(x + <span class="string">&quot;+&quot;</span> + y + <span class="string">&quot;=&quot;</span> + sum(x,y);<span class="comment">//本类中调用有参有返回值的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyMath my = <span class="keyword">new</span> MyMath();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(x + <span class="string">&quot;+&quot;</span> + y + <span class="string">&quot;=&quot;</span> + my.sum(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、方法声明与调用的原则</p><p>（1）方法必须先声明后调用</p><blockquote><p>如果调用方法时，如果方法名写错或调用一个不存在的方法，编译会报错</p></blockquote><p>（2）方法声明的位置必须在类中方法外</p><p>正确示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    方法<span class="number">2</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        方法<span class="number">2</span>()&#123;  <span class="comment">//错误</span></span><br><span class="line">        </span><br><span class="line">   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）方法的调用的位置有要求</p><p>正确示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        调用方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    调用方法  <span class="comment">//错误位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）方法的调用格式要与方法的声明格式对应</p><p>①是否要加“对象.”：看是否在本类中，还是其他类中</p><p>②是否要接收返回值：看被调用方法是否是void</p><p>③是否要传实参：看被调用方法是有形参列表</p><h3 id="5-4-3-方法的重载Overload"><a href="#5-4-3-方法的重载Overload" class="headerlink" title="5.4.3 方法的重载Overload"></a>5.4.3 方法的重载Overload</h3><p>概念：在同一个类中，出现了两个或多个的方法，它们的方法名称相同，形参列表不同，这样的形式称为方法的重载。和返回值类型无关。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求两个整数的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求三个整数的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(max(a,b),c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求两个小数的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-4-4-方法的参数传递机制"><a href="#5-4-4-方法的参数传递机制" class="headerlink" title="5.4.4 方法的参数传递机制"></a>5.4.4 方法的参数传递机制</h3><p>Java中方法的参数传递机制：值传递</p><p>（1）形参是基本数据类型时，实参给形参传递数据值，是copy的形式，形参对值的修改不影响实参。<br>（2）形参是引用数据类型时，实参给形参传递地址值，形参对对象的属性的修改，会影响实参对象的属性值，因为此时形参和实参就是指向同一个对象。<br>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[] args)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">        swap(x,y);<span class="comment">//调用完之后，x与y的值不变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(MyData my)</span></span>&#123;</span><br><span class="line">        my.num *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyData m = <span class="keyword">new</span> MyData();</span><br><span class="line">        m.num = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        change(m);<span class="comment">//调用完之后，m对象的num属性值就变为2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>陷阱1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">陷阱1：在方法中，形参 = 新new对象，那么就和实参无关了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(MyData my)</span></span>&#123;</span><br><span class="line">        my = <span class="keyword">new</span> MyData();<span class="comment">//形参指向了新对象</span></span><br><span class="line">        my.num *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyData m = <span class="keyword">new</span> MyData();</span><br><span class="line">        m.num = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        change(m);<span class="comment">//调用完之后，m对象的num属性值仍然为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>陷阱2：见字符串和包装类部分</p><h2 id="5-3-对象数组"><a href="#5-3-对象数组" class="headerlink" title="5.3 对象数组"></a>5.3 对象数组</h2><p>一维数组：</p><p>1、元素是基本数据类型</p><p>2、元素是引用数据类型，也称为对象数组，即数组的元素是对象</p><blockquote><p>注意：对象数组，首先要创建数组对象本身，即确定数组的长度，然后再创建每一个元素对象，如果不创建，数组的元素的默认值就是null，所以很容易出现空指针异常NullPointerException。</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> year;</span><br><span class="line"><span class="keyword">int</span> month;</span><br><span class="line"><span class="keyword">int</span> day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyDate[] arr = <span class="keyword">new</span> MyDate[<span class="number">3</span>];<span class="comment">//创建数组对象本身，指定数组的长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> MyDate();<span class="comment">//每一个元素要创建对象</span></span><br><span class="line">            arr[i].year = <span class="number">1990</span> + i;</span><br><span class="line">            arr[i].month = <span class="number">1</span> + i;</span><br><span class="line">            arr[i].day = <span class="number">1</span> + i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对象数组的内存图：</p><p><img data-src="/upload_image/java2021_05_31/1558745138315.png" alt="1558745138315"></p><h1 id="第六章-面向对象的基本特征"><a href="#第六章-面向对象的基本特征" class="headerlink" title="第六章 面向对象的基本特征"></a>第六章 面向对象的基本特征</h1><p>面向对象的基本特征：</p><p>1、封装</p><p>2、继承</p><p>3、多态</p><h2 id="6-1-封装"><a href="#6-1-封装" class="headerlink" title="6.1 封装"></a>6.1 封装</h2><p>1、好处：</p><p>（1）隐藏实现细节，方便使用者使用</p><p>（2）安全，可以控制可见范围</p><p>2、如何实现封装？</p><p>通过权限修饰符</p><blockquote><p>面试题：请按照可见范围从小到大（从大到小）列出权限修饰符？</p></blockquote><table><thead><tr><th>修饰符</th><th>本类</th><th>本包</th><th>其他包的子类</th><th>任意位置</th></tr></thead><tbody><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>缺省</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>权限修饰符可以修饰什么？</p><p>类（类、接口等）、属性、方法、构造器、内部类</p><p>类（外部类）：public和缺省</p><p>属性：4种</p><p>方法：4种</p><p>构造器：4种</p><p>内部类：4种</p><p>3、通常属性的封装是什么样的？</p><p>当然属性的权限修饰符可以是private、缺省、protected、public。但是我们大多数时候，见到的都是private，然后给它们配上get/set方法。</p><p>示例代码：标准Javabean的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性私有化</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> marry;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公共的get/set</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">        name = n;<span class="comment">//这里因为还没有学习this等，可能还会优化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMarry</span><span class="params">(<span class="keyword">boolean</span> m)</span></span>&#123;</span><br><span class="line">        marry = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMarry</span><span class="params">()</span></span>&#123;<span class="comment">//boolean类型的属性的get方法，习惯使用把get换成is</span></span><br><span class="line">        <span class="keyword">return</span> marry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-构造器"><a href="#6-2-构造器" class="headerlink" title="6.2 构造器"></a>6.2 构造器</h2><p>1、构造器的作用：<br>（1）和new一起使用创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用无参构造创建对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参构造创建对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名(实参列表);</span><br></pre></td></tr></table></figure><p>（2）可以在创建对象的同时为属性赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">        radius = r;<span class="comment">//为radius赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、声明构造器的语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 类名()&#123;<span class="comment">//无参构造</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    【修饰符】 类名(形参列表)&#123;<span class="comment">//有参构造</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、构造器的特点：</p><p>（1）所有的类都有构造器</p><p>（2）如果一个类没有显式/明确的声明一个构造器，那么编译器将会自动添加一个默认的无参构造</p><p>（3）如果一个类显式/明确的声明了构造器，那么编译器将不再自动添加默认的无参构造，如果需要，那么就需要手动添加</p><p>（4）构造器的名称必须与类名相同</p><p>（5）构造器没有返回值类型</p><p>（6）构造器可以重载</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">        radius = r;<span class="comment">//为radius赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-关键字this"><a href="#6-3-关键字this" class="headerlink" title="6.3 关键字this"></a>6.3 关键字this</h2><p>1、this关键字：</p><p>意思：当前对象</p><p>（1）如果出现在构造器中：表示正在创建的对象</p><p>（2）如果出现在成员方法中：表示正在调用这个方法的对象</p><p>2、this的用法：</p><p>（1）this.属性</p><p>当局部变量与成员变量同名时，那么可以在成员变量的而前面加“this.”用于区别</p><p>（2）this.方法</p><p>调用当前对象的成员方法，完全可以省略“this.”</p><p>（3）this()或this(实参列表)</p><p>this()表示调用本类的无参构造</p><p>this(实参列表)表示调用本类的有参构造</p><blockquote><p>this()或this(实参列表)要么没有，要么必须出现在构造器的首行</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、成员变量与局部变量的区别？</p><p>这里只讨论实例变量（关于类变量见static部分）</p><p>（1）声明的位置不同</p><p>成员变量：类中方法外</p><p>局部变量：方法中或代码中</p><p>​    ①方法的形参列表</p><p>​    ②方法体中局部变量</p><p>​    ③代码块中的局部变量</p><p>（2）运行时在内存中的存储位置不同</p><p>成员变量：堆</p><p>局部变量：栈</p><blockquote><p>基本数据类型的变量在栈中，引用数据类型的变量在堆中：不准确</p></blockquote><p>（3）修饰符</p><p>成员变量：有很多修饰符，例如：权限修饰符</p><p>局部变量：不能加权限修饰符，唯一的能加的是final</p><p>（4）初始化</p><p>成员变量：有默认值</p><p>局部变量：没有默认值，必须手动初始化</p><p>（5）生命周期</p><p>成员变量：随着对象的创建而创建，随着对象被回收而消亡，即与对象同生共死。每一个对象都是独立的。</p><p>局部变量：方法调用时才分配，方法运行结束就没有了。每一次方法调用，都是独立的</p><h2 id="6-4-包"><a href="#6-4-包" class="headerlink" title="6.4 包"></a>6.4 包</h2><p>1、包的作用：</p><p>（1）可以避免类重名</p><p>有了包之后，类的全名称就变为：包.类名</p><p>（2）分类组织管理众多的类</p><p>例如：java.lang包，java.util包，java.io包…..</p><p>（3）可以控制某些类型或成员的可见范围</p><p>如果某个类型或者成员的权限修饰缺省的话，那么就仅限于本包使用</p><p>2、声明包的语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>(1)必须在源文件的代码首行</p><p>(2)一个源文件只能有一个</p></blockquote><p>3、包的命名规范和习惯：<br>（1）所有单词都小写，每一个单词之间使用.分割<br>（2）习惯用公司的域名倒置</p><p>例如：com.atguigu.xxx;</p><blockquote><p>建议大家取包名时不要使用“java.xx”包</p></blockquote><p>4、使用其他包的类：</p><p>前提：被使用的类或成员的权限修饰符是&gt;缺省的</p><p>（1）使用类型的全名称</p><p>例如：java.util.Scanner input = new java.util.Scanner(System.in);</p><p>（2）使用import 语句之后，代码中使用简名称</p><p>5、import语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包.类名;</span><br><span class="line"><span class="keyword">import</span> 包.*;</span><br></pre></td></tr></table></figure><blockquote><p>注意：当使用两个不同包的同名类时，例如：java.util.Date和java.sql.Date。</p><p>一个使用全名称，一个使用简名称</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5-eclipse的使用"><a href="#6-5-eclipse的使用" class="headerlink" title="6.5 eclipse的使用"></a>6.5 eclipse的使用</h2><p>1、eclipse管理项目和代码的结构</p><p>workspace –&gt; project –&gt; 包–&gt;类…</p><p>一个工作空间可以有多个项目。</p><p>2、快捷键</p><p>常规快捷键：</p><p>Ctrl + S：保存</p><p>Ctrl + C：复制</p><p>Ctrl + V：粘贴</p><p>Ctrl + X：剪切</p><p>Ctrl + Y：反撤销</p><p>Ctrl + Z：撤销</p><p>Ctrl + A：全选</p><p>eclipse中默认的快捷键：</p><p>Ctrl + 1：快速修复</p><p>Alt + /：代码提示</p><p>Alt + ?：  Alt + Shift + /   方法的形参列表提示</p><p>Ctrl + D：删除选中行</p><p>Ctrl + Alt + ↓：向下复制行</p><p>Ctrl + Alt + ↑：向上复制行</p><p>Alt + ↓：与下面的行交换位置</p><p>Alt + ↑：与下面的行交换位置</p><p>Ctrl + Shift + F：快速格式</p><p>Ctrl + /：单行注释，再按一次取消</p><p>Ctrl + Shift + /：多行注释</p><p>Ctrl + Shift +\：取消多行注释</p><p>Shift + 回车：在光标下一行插入新航开始编辑</p><p>Ctrl + Shift + 回车：在光标上一行插入新航开始编辑</p><p>Alt + Shift + A：多行编辑     再按一次退出多行编辑模式</p><p>Alt + Shift + S：弹出自动生成代码的菜单选择，包括自动生成构造器、get/set、equals……</p><p>Ctrl + Shift + O：快速导包</p><p>Ctrl + Shift + T：打开某个类的源文件</p><p>Ctrl + O：打开某个类型的摘要outline</p><p>3、快速开发的代码模板</p><p>代码模板 + Alt + /</p><p>（1）main</p><p>public static void main(String[] args){</p><p>}</p><p>（2）sysout</p><p>System.out.println();</p><p>（3）for</p><p>for(int i=0; i&lt;数组名.lenght; i++){</p><p>}</p><p>其他详细使用见《JavaSE_柴林燕_相关工具.docx》</p><h2 id="6-6-面向对象的基本特征之二：继承"><a href="#6-6-面向对象的基本特征之二：继承" class="headerlink" title="6.6 面向对象的基本特征之二：继承"></a>6.6 面向对象的基本特征之二：继承</h2><p>1、为什么要继承？继承的好处？（理解）</p><p>（1）代码的复用</p><p>（2）代码的扩展</p><p>2、如何实现继承？</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 子类  <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、继承的特点</p><p>（1）子类会继承父类的所有特征（属性、方法）</p><p>但是，私有的在子类中是不能直接使用的</p><p>（2）子类不会继承父类的构造器</p><p>因为，父类的构造器是用于创建父类的对象的</p><p>（3）子类的构造器中又必须去调用父类的构造器</p><p>在创建子类对象的同时，为从父类继承的属性进行初始化用，可以借助父类的构造器中的代码为属性赋值。</p><p>（4）Java只支持单继承：一个子类只能有一个“直接”父类</p><p>（5）Java又支持多层继承：父类还可以有父类，特征会代代相传</p><p>（6）一个父类可以同时拥有很多个子类</p><h2 id="6-7-关键字super"><a href="#6-7-关键字super" class="headerlink" title="6.7 关键字super"></a>6.7 关键字super</h2><p>super关键字：引用父类的，找父类的xx</p><p>用法：</p><p>（1）super.属性</p><p>当子类声明了和父类同名的成员变量时，那么如果要表示某个成员变量是父类的，那么可以加“super.”</p><p>（2）super.方法</p><p>当子类重写了父类的方法，又需要在子类中调用父类被重写的方法，可以使用”super.”</p><p>（3）super()或super(实参列表)</p><p>super()：表示调用父类的无参构造</p><p>super(实参列表)：表示调用父类的有参构造</p><blockquote><p>注意：</p><p>（1）如果要写super()或super(实参列表)，必须写在子类构造器的首行</p><p>（2）如果子类的构造器中没有写：super()或super(实参列表)，那么默认会有 super()</p><p>（3）如果父类没有无参构造，那么在子类的构造器的首行“必须”写super(实参列表)</p></blockquote><h2 id="6-8-方法的重写"><a href="#6-8-方法的重写" class="headerlink" title="6.8 方法的重写"></a>6.8 方法的重写</h2><p>1、方法的重写（Override）</p><p>当子类继承了父类的方法时，又觉得父类的方法体的实现不适合于子类，那么子类可以选择进行重写。</p><p>2、方法的重写的要求</p><p>（1）方法名：必须相同</p><p>（2）形参列表：必须相同</p><p>（3）修饰符</p><p>​    权限修饰符： &gt;=</p><p>（4）返回值类型</p><p>​    如果是基本数据类型和void：必须相同</p><p>​    如果是引用数据类型：&lt;=</p><p>​    在Java中我们认为，在概念范围上：子类 &lt;父类</p><p>3、重载（Overload）与重写（Override）的区别</p><p>​    重载（Overload）：在同一个类中，方法名相同，形参列表不同，和返回值类型无关的两个或多个方法。</p><p>​    重写（Override）：在父子类之间。对方法签名的要求见上面。</p><p>特殊的重载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOverload</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="comment">//b对象可以调用几个a方法</span></span><br><span class="line">b.a();</span><br><span class="line">b.a(<span class="string">&quot;&quot;</span>);<span class="comment">//从b对象同时拥有两个方法名相同，形参不同的角度来说，算是重载</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-9-非静态代码块"><a href="#6-9-非静态代码块" class="headerlink" title="6.9 非静态代码块"></a>6.9 非静态代码块</h2><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        非静态代码块</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、作用</p><p>目的：在创建的过程中，为对象属性赋值，协助完成实例初始化的过程</p><p>3、什么时候执行？</p><p>（1）每次创建对象时都会执行</p><p>（2）优先于构造器执行</p><h2 id="6-10-实例初始化过程"><a href="#6-10-实例初始化过程" class="headerlink" title="6.10 实例初始化过程"></a>6.10 实例初始化过程</h2><p>1、概念描述</p><ul><li><p>实例初始化过程：实例对象创建的过程</p></li><li><p>实例初始化方法：实例对象创建时要执行的方法</p></li><li><p>实例初始化方法的由来：它是有编译器编译生成的</p></li><li><p>实例初始化方法的形式：<init>()或<init>(形参列表)</p></li><li><p>实例初始化方法的构成：</p><p>①属性的显式赋值代码</p><p>②非静态代码块的代码</p><p>③构造器的代码</p><blockquote><p>其中</p><p>①和②按顺序执行，从上往下</p><p>③在①和②的后面</p></blockquote></li></ul><p>因此一个类有几个构造器，就有几个实例初始化方法。</p><p>2、单个类实例初始化方法</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;非静态代码块1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String str = assign();<span class="comment">//调用方法，来为str进行显式赋值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;无参构造&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.str = str;</span><br><span class="line">System.out.println(<span class="string">&quot;有参构造&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;非静态代码块2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">assign</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;assign方法&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解：</p><p><img data-src="/upload_image/java2021_05_31/1558960549421.png" alt="1558960549421"></p><p>3、父子类的实例初始化</p><p>注意：</p><p>（1）原先super()和super(实参列表)说是调用父类的构造器，现在就要纠正为调用父类的实例初始化方法了</p><p>（2）原先super()和super(实参列表)说是必须在子类构造器的首行，现在要纠正为必须在子类实例初始化方法的首行</p><p>结论：</p><p>（1）执行顺序是先父类实例初始化方法，再子类实例初始化方法</p><p>（2）如果子类重写了方法，通过子类对象调用，一定是执行重写过的方法</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ba</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String str = assign();</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;(1)父类的非静态代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Ba</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;(2)父类的无参构造&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">assign</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;(3)父类的assign()&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;ba&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Er</span> <span class="keyword">extends</span> <span class="title">Ba</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String str = assign();</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;(4)子类的非静态代码块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Er</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//super()  ==&gt;调用父类的实例初始化方法，而且它在子类实例初始化方法的首行</span></span><br><span class="line">System.out.println(<span class="string">&quot;(5)子类的无参构造&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">assign</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;(6)子类的assign()&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;er&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Er();<span class="comment">//612645</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解：</p><p><img data-src="/upload_image/java2021_05_31/1558961723911.png" alt="1558961723911"></p><h2 id="6-11-面向对象的基本特征之三：多态"><a href="#6-11-面向对象的基本特征之三：多态" class="headerlink" title="6.11 面向对象的基本特征之三：多态"></a>6.11 面向对象的基本特征之三：多态</h2><p>1、多态：</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类 引用/变量 = 子类的对象;</span><br></pre></td></tr></table></figure><p>2、前提：</p><p>（1）继承</p><p>（2）方法的重写</p><p>（3）多态引用</p><p>3、现象：</p><p>​    编译时看左边/“父类”，运行时看右边/“子类”。</p><p>​    编译时，因为按父类编译，那么只能父类有的方法，子类扩展的方法是无法调用的；    </p><p>​    执行时一定是运行子类重写的过的方法体。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;走路&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;细嚼慢咽的吃饭&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;婀娜多姿走路&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shop</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;买买买...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;狼吞虎咽的吃饭&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;大摇大摆的走路&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;吞云吐雾&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Woman();<span class="comment">//多态引用</span></span><br><span class="line">        p.eat();<span class="comment">//执行子类重写</span></span><br><span class="line">        p.walk();<span class="comment">//执行子类重写</span></span><br><span class="line">        <span class="comment">//p.shop();//无法调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、应用：</p><p>（1）多态参数：形参是父类，实参是子类对象</p><p>（2）多态数组：数组元素类型是父类，元素存储的是子类对象</p><p>示例代码：多态参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> Woman());<span class="comment">//实参是子类对象</span></span><br><span class="line">        test(<span class="keyword">new</span> Man());<span class="comment">//实参是子类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Person p)</span></span>&#123;<span class="comment">//形参是父类类型</span></span><br><span class="line">        p.eat();</span><br><span class="line">        p.walk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：多态数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person[] arr = <span class="keyword">new</span> Person[<span class="number">2</span>];<span class="comment">//多态数组</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> Woman();</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> Man();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            all[i].eat();</span><br><span class="line">            all[i].walk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、向上转型与向下转型：父子类之间的转换</p><p>（1）向上转型：自动类型转换</p><p>​    当把子类的对象赋值给父类的变量时（即多态引用时），在编译时，这个对象就向上转型为父类。此时就看不见子类“特有、扩展”的方法。</p><p>（2）向下转型：强制转换。有风险，可能会报ClassCastException异常。</p><p>​    当需要把父类的变量赋值给一个子类的变量时，就需要向下转型。</p><p>​    <strong>要想转型成功，必须保证该变量中保存的对象的运行时类型是&lt;=强转的类型</strong></p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChineseWoman</span> <span class="keyword">extends</span> <span class="title">Woman</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//向上转型</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line">Woman m = (Woman)p1; </span><br><span class="line"><span class="comment">//p1变量中实际存储的对象就是Woman类型，和强转的Woman类型一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向上转型</span></span><br><span class="line">Person p2 = <span class="keyword">new</span> ChineseWoman();</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line">Woman w2 = (Woman) p2; </span><br><span class="line"><span class="comment">//p2变量中实际存储的对象是ChineseWoman类型，强制的类型是Woman，ChineseWoman&lt;Woman类型     </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、instanceof</p><p>表达式语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象/变量  <span class="keyword">instanceof</span>  类型</span><br></pre></td></tr></table></figure><p>运算结果：true 或 false</p><p>作用：</p><p>用来判断这个对象是否属于这个类型，或者说，是否是这个类型的对象或这个类型子类的对象</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChineseWoman</span> <span class="keyword">extends</span> <span class="title">Woman</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Woman w = <span class="keyword">new</span> Woman();</span><br><span class="line">        ChineseWoman c = <span class="keyword">new</span> ChineseWoman();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p <span class="keyword">instanceof</span> Woman)&#123;<span class="comment">//false</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(w <span class="keyword">instanceof</span> Woman)&#123;<span class="comment">//true</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c <span class="keyword">instanceof</span> Woman)&#123;<span class="comment">//true</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第七章-面向对象的高级特性"><a href="#第七章-面向对象的高级特性" class="headerlink" title="第七章 面向对象的高级特性"></a>第七章 面向对象的高级特性</h1><p>修饰符的学习围绕三个问题：</p><p>（1）单词的意思</p><p>（2）可以修饰什么？</p><p>（3）用它修饰后有什么不同？</p><h2 id="7-1-关键字：final"><a href="#7-1-关键字：final" class="headerlink" title="7.1 关键字：final"></a>7.1 关键字：final</h2><p>final：最终的</p><p>用法：</p><p>（1）修饰类（包括外部类、内部类类）</p><p>表示这个类不能被继承，没有子类</p><p>（2）修饰方法</p><p>表示这个方法不能被重写</p><p>（3）修饰变量（成员变量（类变量、实例变量），局部变量）</p><p>表示这个变量的值不能被修改</p><p>注意：如果某个成员变量用final修饰后，也得手动赋值，而且这个值一旦赋完，就不能修改了，即没有set方法</p><h2 id="7-2-关键字：native"><a href="#7-2-关键字：native" class="headerlink" title="7.2 关键字：native"></a>7.2 关键字：native</h2><p>native：本地的，原生的<br>用法：</p><p>​    只能修饰方法</p><p>​    表示这个方法的方法体代码不是用Java语言实现的。</p><p>​    但是对于Java程序员来说，可以当做Java的方法一样去正常调用它，或者子类重写它。</p><p>JVM内存的管理：</p><p><img data-src="/upload_image/java2021_05_31/1555119319865.png"></p><p>方法区：类的信息、常量、静态变量、动态编译生成的字节码信息</p><p>虚拟机栈：Java语言实现的方法的局部变量</p><p>本地方法栈：非Java语言实现的方法的局部变量，即native方法执行时的内存区域</p><p>堆：new出来的对象</p><p>程序计数器：记录每一个线程目前执行到哪一句指令</p><h2 id="7-3-关键字：static"><a href="#7-3-关键字：static" class="headerlink" title="7.3 关键字：static"></a>7.3 关键字：static</h2><p>static：静态的</p><p>用法：</p><p>1、成员方法：我们一般称为静态方法或类方法</p><p>（1）不能被重写</p><p>（2）被使用</p><p>本类中：其他方法中可以直接使用它</p><p>其他类中：可以使用“类名.方法”进行调用，也可以使用”对象名.方法”，推荐使用“类名.方法”</p><p>（3）在静态方法中，我们不能出现：this，super，非静态的成员</p><p>2、成员变量：我们一般称为静态变量或类变量</p><p>（1）静态变量的值是该类所有对象共享的</p><p>（2）静态变量存储在方法区</p><p>（3）静态变量对应的get/set也是静态的</p><p>（4）静态变量与局部变量同名时，就可以使用“类名.静态变量”进行区分</p><p>3、内部类：后面讲</p><p>4、代码块：静态代码块</p><p>5、静态导入（JDK1.5引入）</p><p>没有静态导入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">1000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(Utils.MAX_VALUE);</span><br><span class="line">        Utils.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用静态导入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">1000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.atguigu.utils.Utils.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(MAX_VALUE);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-4-静态代码块"><a href="#7-4-静态代码块" class="headerlink" title="7.4 静态代码块"></a>7.4 静态代码块</h2><p>1、语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        静态代码块;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、作用：</p><p>协助完成类初始化，可以为类变量赋值。</p><p>3、类初始化<clinit>()</p><p>类的初始化有：</p><p>①静态变量的显式赋值代码</p><p>②静态代码块中代码</p><p>其中①和②按顺序执行</p><p>注意：类初始化方法，一个类只有一个</p><p>4、类的初始化的执行特点：</p><p>（1）每一个类的<clinit>()只执行一次</p><p>（2）如果一个子类在初始化时，发现父类也没有初始化，会先初始化父类</p><p>（3）如果既要类初始化又要实例化初始化，那么一定是先完成类初始化的</p><h2 id="7-5-变量的分类与区别"><a href="#7-5-变量的分类与区别" class="headerlink" title="7.5  变量的分类与区别"></a>7.5  变量的分类与区别</h2><p>1、变量按照数据类型分：</p><p>（1）基本数据类型的变量，里面存储数据值</p><p>（2）引用数据类型的变量，里面存储对象的地址值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//a中存储的是数据值</span></span><br><span class="line"></span><br><span class="line">Student stu = <span class="keyword">new</span> Student();<span class="comment">//stu存储的是对象的地址值</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">//arr存储的是数组对象的地址值</span></span><br><span class="line">String str = <span class="string">&quot;hello&quot;</span>;<span class="comment">//str存储的是&quot;hello&quot;对象的地址值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、变量按照声明的位置不同：</p><p>（1）成员变量</p><p>（2）局部变量</p><p>3、成员变量与局部变量的区别</p><p>（1）声明的位置不同</p><p>成员变量：类中方法外</p><p>局部变量：（1）方法的()中，即形参（2）方法体的{}的局部变量（3）代码块{}中</p><p>（2）存储的位置不同</p><p>成员变量：</p><p>​    如果是静态变量（类变量），在方法区中</p><p>​    如果是非静态的变量（实例变量），在堆中</p><p> 局部变量：栈</p><p>（3）修饰符不同</p><p>成员变量：4种权限修饰符、static、final。。。。</p><p>局部变量：只有final</p><p>（4）生命周期</p><p>成员变量：</p><p>​    如果是静态变量（类变量），和类相同</p><p>​    如果是非静态的变量（实例变量），和所属的对象相同，每一个对象是独立</p><p>局部变量：每次执行都是新的</p><p>（5）作用域</p><p>成员变量：</p><p>​    如果是静态变量（类变量），在本类中随便用，在其他类中使用“类名.静态变量”</p><p>​    如果是非静态的变量（实例变量），在本类中只能在非静态成员中使用，在其他类中使用“对象名.非静态的变量”</p><p>局部变量：有作用域</p><h2 id="7-7-根父类"><a href="#7-7-根父类" class="headerlink" title="7.7  根父类"></a>7.7  根父类</h2><p>1、java.lang.Object类是类层次结构的根父类。包括数组对象。</p><p>（1）Object类中声明的所有的方法都会被继承到子类中，那么即所有的对象，都拥有Object类中的方法</p><p>（2）每一个对象的创建，最终都会调用到Object实例初始化方法<init>()</p><p>（3）Object类型变量、形参、数组，可以存储任意类型的对象</p><p>2、Object类的常用方法</p><p>（1）public String toString()：</p><p>①默认情况下，返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式”</p><p>②通常是建议重写，如果在eclipse中，可以用Alt +Shift + S–&gt;Generate toString()</p><p>③如果我们直接System.out.println(对象)，默认会自动调用这个对象的toString()</p><p>（2）public final Class&lt;?&gt; getClass()：获取对象的运行时类型</p><p>（3）protected void finalize()：当对象被GC确定为要被回收的垃圾，在回收之前由GC帮你调用这个方法。而且这个方法只会被调用一次。子类可以选择重写。</p><p>（4）public int hashCode()：返回每个对象的hash值。</p><p>规定：①如果两个对象的hash值是不同的，那么这两个对象一定不相等；</p><p>​    ②如果两个对象的hash值是相同的，那么这两个对象不一定相等。</p><p>主要用于后面当对象存储到哈希表等容中时，为了提高性能用的。</p><p>（5）public boolean equals(Object obj)：用于判断当前对象this与指定对象obj是否“相等”</p><p>①默认情况下，equals方法的实现等价于与“==”，比较的是对象的地址值</p><p>②我们可以选择重写，重写有些要求：</p><p>A：如果重写equals，那么一定要一起重写hashCode()方法，因为规定：</p><p>​    a：如果两个对象调用equals返回true，那么要求这两个对象的hashCode值一定是相等的；</p><p>​    b：如果两个对象的hashCode值不同的，那么要求这个两个对象调用equals方法一定是false；</p><p>​    c：如果两个对象的hashCode值相同的，那么这个两个对象调用equals可能是true，也可能是false</p><p>B：如果重写equals，那么一定要遵循如下几个原则：</p><p>​    a：自反性：x.equals(x)返回true</p><p>​    b：传递性：x.equals(y)为true, y.equals(z)为true，然后x.equals(z)也应该为true</p><p>​    c：一致性：只要参与equals比较的属性值没有修改，那么无论何时调用结果应该一致</p><p>​    d：对称性：x.equals(y)与y.equals(x)结果应该一样</p><p>​    e：非空对象与null的equals一定是false</p><h2 id="7-8-关键字：abstract"><a href="#7-8-关键字：abstract" class="headerlink" title="7.8 关键字：abstract"></a>7.8 关键字：abstract</h2><p>1、什么时候会用到抽象方法和抽象类？</p><p>当声明父类的时候，在父类中某些方法的方法体的实现不能确定，只能由子类决定。但是父类中又要体现子类的共同的特征，即它要包含这个方法，为了统一管理各种子类的对象，即为了多态的应用。</p><p>那么此时，就可以选择把这样的方法声明为抽象方法。如果一个类包含了抽象方法，那么这个类就必须是个抽象类。</p><p>2、抽象类的语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【权限修饰符】 <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">【权限修饰符】 <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、抽象方法的语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【其他修饰符】 <span class="keyword">abstract</span> 返回值类型  方法名(【形参列表】);</span><br></pre></td></tr></table></figure><p>抽象方法没有方法体</p><p>4、抽象类的特点</p><p>（1）抽象类不能直接实例化，即不能直接new对象</p><p>（2）抽象类就是用来被继承的，那么子类继承了抽象类后，必须重写所有的抽象方法，否则这个子类也得是抽象类</p><p>（3）抽象类也有构造器，这个构造的作用不是创建抽象类自己的对象用的，给子类在实例化过程中调用；</p><p>（4）抽象类也可以没有抽象方法，那么目的是不让你创建对象，让你创建它子类的对象</p><p>（5）抽象类的变量与它子类的对象也构成多态引用</p><p>5、不能和abstract一起使用的修饰符？</p><p>（1）final：和final不能一起修饰方法和类</p><p>（2）static：和static不能一起修饰方法</p><p>（3）native：和native不能一起修饰方法</p><p>（4）private：和private不能一起修饰方法</p><h2 id="7-9-接口"><a href="#7-9-接口" class="headerlink" title="7.9 接口"></a>7.9 接口</h2><p>1、接口的概念</p><p>接口是一种标准。注意关注行为标准（即方法）。</p><p>面向对象的开发原则中有一条：面向接口编程。</p><p>2、接口的声明格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">interface</span> 接口名</span>&#123;</span><br><span class="line">    接口的成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、类实现接口的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 实现类  <span class="keyword">implements</span> 父接口们</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 实现类 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 父接口们</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、接口继承接口的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">interface</span> 接口名 <span class="keyword">extends</span> 父接口们</span>&#123;</span><br><span class="line">    接口的成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、接口的特点</p><p>（1）接口不能直接实例化，即不能直接new对象</p><p>（2）只能创建接的实现类对象，那么接口与它的实现类对象之间可以构成多态引用。</p><p>（3）实现类在实现接口时，必须重写所有抽象的方法，否则这个实现类也得是抽象类。</p><p>（4）Java规定类与类之间，只能是单继承，但是Java的类与接口之间是多实现的关系，即一个类可以同时实现多个接口</p><p>（5）Java还支持接口与接口之间的多继承。</p><p>6、接口的成员</p><p>JDK1.8之前：</p><p>（1）全局的静态的常量：public static final，这些修饰符可以省略</p><p>（2）公共的抽象方法：public abstract，这些修饰符也可以省略</p><p>JDK1.8之后：</p><p>（3）公共的静态的方法：public static ,这个就不能省略了</p><p>（4）公共的默认的方法：public default，这个就不能省略了</p><p>7、默认方法冲突问题</p><p>（1） 当一个实现类同时实现了两个或多个接口，这个多个接口的默认方法的签名相同。</p><p>解决方案：</p><p>方案一：选择保留其中一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口名.<span class="keyword">super</span>.方法名(【实参列表】);</span><br></pre></td></tr></table></figure><p>方案二：完全重写</p><p>（2）当一个实现类同时继承父类，又实现接口，父类中有一个方法与接口的默认方法签名相同</p><p>解决方案：</p><p>方案一：默认方案，保留父类的</p><p>方案二：选择保留接口的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口名.<span class="keyword">super</span>.方法名(【实参列表】);</span><br></pre></td></tr></table></figure><p>方案三：完全重写</p><p>8、示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> MAX_SPEED = <span class="number">7900000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、常用的接口</p><p>（1）java.lang.Comparable接口：自然排序</p><p>​    抽象方法：int compareTo(Object obj)</p><p>（2）java.util.Comparator接口：定制排序</p><p>​    抽象方法：int compare(Object obj1 ,Object obj2)</p><p>（3）示例代码</p><p>如果员工类型，默认顺序，自然顺序是按照编号升序排列，那么就实现Comparable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略了构造器，get/set,toString</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id - ((Employee)obj).id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在后面又发现有新的需求，想要按照薪资排序，那么只能选择用定制排序，实现Comparator接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalaryComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span></span>&#123;</span><br><span class="line">        Employee e1 = (Employee)o1;</span><br><span class="line">        Employee e2 = (Employee)o2;</span><br><span class="line">        <span class="keyword">if</span>(e1.getSalary() &gt; e2.getSalary())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e1.getSalary() &lt; e2.getSalary())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-10-内部类"><a href="#7-10-内部类" class="headerlink" title="7.10 内部类"></a>7.10 内部类</h2><p>1、内部类的概念</p><p>声明在另外一个类里面的类就是内部类。</p><p>2、内部类的4种形式</p><p>（1）静态内部类</p><p>（2）非静态成员内部类</p><p>（3）有名字的局部内部类</p><p>（4）匿名内部类</p><h3 id="7-10-1-匿名内部类"><a href="#7-10-1-匿名内部类" class="headerlink" title="7.10.1 匿名内部类"></a>7.10.1 匿名内部类</h3><p>1、语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在匿名子类中调用父类的无参构造</span></span><br><span class="line"><span class="keyword">new</span> 父类()&#123;</span><br><span class="line">    内部类的成员列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在匿名子类中调用父类的有参构造</span></span><br><span class="line"><span class="keyword">new</span> 父类(实参列表)&#123;</span><br><span class="line">    内部类的成员列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口没有构造器，那么这里表示匿名子类调用自己的无参构造，调用默认父类Object的无参构造</span></span><br><span class="line"><span class="keyword">new</span> 父接口名()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、匿名内部类、匿名对象的区别？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>));<span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">Student stu = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>);<span class="comment">//这个对象有名字，stu</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//既有匿名内部类，又是一个匿名的对象</span></span><br><span class="line"><span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.test();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个匿名内部类的对象，使用obj这个名字引用它，既对象有名字，但是这个Object的子类没有名字</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3、使用的形式</p><p>（1）示例代码：继承式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//用父类与匿名内部类的对象构成多态引用</span></span><br><span class="line">        Father f = <span class="keyword">new</span> Father()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;用匿名内部类继承了Father这个抽象类，重写了test抽象方法&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        f.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）示例代码：实现式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//用父接口与匿名内部类的对象构成了多态引用</span></span><br><span class="line">        Flyable f = <span class="keyword">new</span> Flyable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;用匿名内部类实现了Flyable这个接口，重写了抽象方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）示例代码：用匿名内部类的匿名对象直接调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用匿名内部类的匿名对象直接调用方法&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.test();</span><br></pre></td></tr></table></figure><p>（4）示例代码：用匿名内部类的匿名对象直接作为实参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Student[] all = <span class="keyword">new</span> Student[<span class="number">3</span>];</span><br><span class="line">all[<span class="number">0</span>] = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>);</span><br><span class="line">all[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">&quot;李四&quot;</span>,<span class="number">22</span>);</span><br><span class="line">all[<span class="number">2</span>] = <span class="keyword">new</span> Student(<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用匿名内部类的匿名对象直接作为实参</span></span><br><span class="line"><span class="comment">//这个匿名内部类实现了Comparator接口</span></span><br><span class="line"><span class="comment">//这个匿名内部类的对象，是定制比较器的对象</span></span><br><span class="line">Arrays.sort(all, <span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Obeject o1, Object o2)</span></span>&#123;</span><br><span class="line">        Student s1 = (Student)o1;</span><br><span class="line">        Student s2 = (Student)o2;</span><br><span class="line">        <span class="keyword">return</span> s1.getAge() - s2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="7-10-2-静态内部类"><a href="#7-10-2-静态内部类" class="headerlink" title="7.10.2  静态内部类"></a>7.10.2  静态内部类</h3><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 外部类名  【<span class="keyword">extends</span> 外部类的父类】 【<span class="keyword">implements</span> 外部类的父接口们】</span>&#123;</span><br><span class="line">【其他修饰符】 <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  静态内部类 【<span class="keyword">extends</span> 静态内部类自己的父类】 【<span class="keyword">implements</span> 静态内部类的父接口们】</span>&#123;</span><br><span class="line">        静态内部类的成员列表;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">外部类的其他成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 使用注意事项</p><p>（1）包含成员是否有要求：</p><p>​        可以包含类的所有成员</p><p>（2）修饰符要求：</p><ul><li>​        权限修饰符：4种</li><li>​        其他修饰符：abstract、final</li></ul><p>（3）使用外部类的成员上是否有要求</p><ul><li>​        只能使用外部类的静态成员</li></ul><p>（4）在外部类中使用静态内部类是否有要求</p><ul><li>​        正常使用</li></ul><p>（5）在外部类的外面使用静态内部类是否有要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）如果使用的是静态内部类的静态成员</span><br><span class="line">外部类名.静态内部类名.静态成员</span><br><span class="line">（<span class="number">2</span>）如果使用的是静态内部类的非静态成员</span><br><span class="line">①先创建静态内部类的对象</span><br><span class="line">外部类名.静态内部类名 对象名 = <span class="keyword">new</span> 外部类名.静态内部类名(【实参列表】);</span><br><span class="line">②通过对象调用非静态成员</span><br><span class="line">对象名.xxx</span><br></pre></td></tr></table></figure><p>（6）字节码文件形式：外部类名$静态内部类名.class</p><p>3、示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer.Inner.test();</span><br><span class="line">        </span><br><span class="line">        Outer.Inner in = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-10-3-非静态内部类"><a href="#7-10-3-非静态内部类" class="headerlink" title="7.10.3  非静态内部类"></a>7.10.3  非静态内部类</h3><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 外部类名  【<span class="keyword">extends</span> 外部类的父类】 【<span class="keyword">implements</span> 外部类的父接口们】</span>&#123;</span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span>  非静态内部类 【<span class="keyword">extends</span> 非静态内部类自己的父类】 【<span class="keyword">implements</span> 非静态内部类的父接口们】</span>&#123;</span><br><span class="line">        非静态内部类的成员列表;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">外部类的其他成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 使用注意事项</p><p>（1）包含成员是否有要求：</p><p>​    不允许出现静态的成员</p><p>（2）修饰符要求</p><p>​    权限修饰符：4种</p><p>​    其他修饰符：abstract，final</p><p>（3）使用外部类的成员上是否有要求</p><p>​    都可以使用</p><p>（4）在外部类中使用非静态内部类是否有要求</p><p>​    在外部类的静态成员中不能使用非静态内部类</p><p>（5）在外部类的外面使用非静态内部类是否有要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用非静态内部类的非静态成员</span></span><br><span class="line"><span class="comment">//(1)创建外部类的对象</span></span><br><span class="line">外部类名  对象名<span class="number">1</span> = <span class="keyword">new</span>  外部类名(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)通过外部类的对象去创建或获取非静态内部类的对象</span></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line">外部类名.非静态内部类名  对象名<span class="number">2</span> = 对象名<span class="number">1.</span>new 非静态内部类名(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line">外部类名.非静态内部类名  对象名<span class="number">2</span> = 对象名<span class="number">1.</span>get非静态内部类对象的方法(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）通过非静态内部类调用它的非静态成员</span></span><br><span class="line">对象名<span class="number">2.</span>xxx</span><br></pre></td></tr></table></figure><p>（6）字节码文件形式：外部类名$非静态内部类名.class</p><p>3、示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">            System.out.println(j);<span class="comment">//可以</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// Inner in = new Inner();//不可以</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        </span><br><span class="line">        Outer.Inner in1 = out.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;     <span class="comment">//创建   </span></span><br><span class="line">        in1.method();</span><br><span class="line">        </span><br><span class="line">        Outer.Inner in2 = out.getInner();<span class="comment">//获取</span></span><br><span class="line">        in2.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-10-4-局部内部类"><a href="#7-10-4-局部内部类" class="headerlink" title="7.10.4  局部内部类"></a>7.10.4  局部内部类</h3><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 外部类名  【<span class="keyword">extends</span> 外部类的父类】 【<span class="keyword">implements</span> 外部类的父接口们】</span>&#123;</span><br><span class="line">【修饰符】 返回值类型  方法名(【形参列表】)&#123;</span><br><span class="line">        【修饰符】 <span class="class"><span class="keyword">class</span>  局部内部类 【<span class="keyword">extends</span> 局部内部类自己的父类】 【<span class="keyword">implements</span> 局部内部类的父接口们】</span>&#123;</span><br><span class="line">        局部内部类的成员列表;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">外部类的其他成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 使用注意事项</p><p>（1）包含成员是否有要求</p><p>​    不允许出现静态的成员</p><p>（2）修饰符要求</p><p>​    权限修饰符：不能</p><p>​    其他修饰符：abstract、final</p><p>（3）使用外部类的成员等上是否有要求</p><p>​    ①使用外部类的静态成员：随便用</p><p>​    ②使用外部类的非静态成员：能不能用要看所在的方法是否是静态的</p><p>​    ③使用所在方法的局部变量：必须 final修饰的</p><p>（4）在外部类中使用局部内部类是否有要求</p><p>​    有作用域</p><p>（5）在外部类的外面使用局部内部类是否有要求</p><p>​    没法使用</p><p>（6）字节码文件形式：外部类名$编号局部内部类名.class</p><p>3、示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">                System.out.println(j);<span class="comment">//可以</span></span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> k = <span class="number">30</span>;</span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">                System.out.println(j);<span class="comment">//不可以</span></span><br><span class="line">                System.out.println(k);<span class="comment">//可以</span></span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第八章-枚举与注解"><a href="#第八章-枚举与注解" class="headerlink" title="第八章  枚举与注解"></a>第八章  枚举与注解</h1><h2 id="8-1-枚举"><a href="#8-1-枚举" class="headerlink" title="8.1 枚举"></a>8.1 枚举</h2><p>1、枚举（JDK1.5引入的）</p><p>枚举类型的对象是有限、固定的几个常量对象。</p><p>2、语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形式一：枚举类型中只有常量对象列表</span></span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">enum</span> 枚举类型名</span>&#123;</span><br><span class="line">    常量对象列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形式二：枚举类型中只有常量对象列表</span></span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">enum</span> 枚举类型名</span>&#123;</span><br><span class="line">    常量对象列表;</span><br><span class="line">    </span><br><span class="line">    其他成员列表；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：常量对象列表必须在枚举类型的首行</p><p>回忆：首行</p><p>（1）super()或super(实参列表)：必须在子类构造器的首行</p><p>（2）this()或this(实参列表)：必须在本类构造器的首行</p><p>（3）package 包; 声明包的语句必须在源文件.java的代码首行</p><p>（4）枚举常量对象列表必须在枚举类型的首行</p><p>3、在其他类中如何获取枚举的常量对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个常量对象</span></span><br><span class="line">枚举类型名.常量对象名</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个常量对象</span></span><br><span class="line">枚举类型名.valueOf(<span class="string">&quot;常量对象名&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取所有常量对象</span></span><br><span class="line">枚举类型名[] all = 枚举类型名.values();</span><br></pre></td></tr></table></figure><p>4、枚举类型的特点</p><p>（1）枚举类型有一个公共的基本的父类，是java.lang.Enum类型，所以不能再继承别的类型</p><p>（2）枚举类型的构造器必须是私有的</p><p>（3）枚举类型可以实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyRunnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Gender</span> <span class="keyword">implements</span> <span class="title">MyRunnable</span></span>&#123;</span><br><span class="line">    NAN,NV;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Gender</span> <span class="keyword">implements</span> <span class="title">MyRunnable</span></span>&#123;</span><br><span class="line">    NAN&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,NV&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、父类java.lang.Enum类型</p><p>（1）构造器</p><p>protected Enum(String name, int ordinal)：由编译器自动调用</p><p>（2）String name()：常量对象名</p><p>（3）int ordinal()：返回常量对象的序号，第一个的序号是0</p><p>（4）String toString()：返回常量对象名，如果子类想重写，需要手动</p><p>（5）int compareTo(Object obj)：按照常量对象的顺序比较</p><h2 id="8-2-注解"><a href="#8-2-注解" class="headerlink" title="8.2 注解"></a>8.2 注解</h2><p>1、注解</p><p>它是代码级别的注释</p><p>2、标记符号：@</p><p>3、系统预定义的三个最基本的注解：</p><p>（1）@Override：表示某个方法是重写的方法</p><p>它只能用在方法上面，会让编译器对这个方法进行格式检查，是否满足重写的要求</p><p>（2）@SuppressWarnings(xx)：抑制警告</p><p>（3）@Deprecated：表示xx已过时</p><p>4、和文档注释相关的注解</p><p>（1）文档注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">文档注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>（2）常见的文档注释</p><p>@author：作者</p><p>@since：从xx版本加入的</p><p>@see：另请参考</p><p>@param：形参</p><p>@return：返回值</p><p>@throws或@exception：异常</p><p>5、JUnit相关的几个注解</p><p>（1）@Test：表示它是一个单元测试方法</p><p>这个方法需要是：public void xxx(){}</p><p>（2）@Before：表示在每一个单元测试方法之前执行</p><p>这个方法需要是：public void xxx(){}</p><p>（3）@After：表示在每一个单元测试方法之后执行</p><p>这个方法需要是：public void xxx(){}</p><p>（4）@BeforeClass：表示在类初始化阶段执行，而且只执行一次</p><p>这个方法需要是：public static void xxx(){}</p><p>（3）@AfterClass：表示在类的“卸载”阶段执行，而且只执行一次</p><p>这个方法需要是：public static void xxx(){}</p><p>6、元注解</p><p>（1）@Target(xx)：用它标记的注解能够用在xx位置</p><p>(xx)：由ElementType枚举类型的10个常量对象指定，例如：TYPE，METHOD，FIELD等</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;TYPE,METHOD,FIELD&#125;)</span></span><br></pre></td></tr></table></figure><p>（2）@Retention（xx）：用它标记的注解可以滞留到xx阶段</p><p>(xx)：由RetentionPolicy枚举类型的3个常量对象指定，分别是：SOURCE，CLASS，RUNTIME</p><p>唯有RUNTIME阶段的注解才能被反射读取到</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br></pre></td></tr></table></figure><p>（3）@Documentd：用它标记的注解可以读取到API中</p><p>（4）@Inherited：用它标记的注解可以被子类继承</p><p>7、自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@元注解</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@元注解</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    配置参数列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置参数的语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据类型  配置参数名();</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">数据类型  配置参数名() <span class="keyword">default</span> 默认值;</span><br></pre></td></tr></table></figure><p>关于配置参数：</p><p>（1）配置参数的类型有要求：</p><p>八种基本数据类型、String、枚举、Class类型、注解、它们的数组。</p><p>（2）如果自定义注解声明了配置参数，那么在使用这个注解时必须为配置参数赋值，除非它有默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@自定义注解名(配置参数名<span class="number">1</span>=值，配置参数名<span class="number">2</span>=值。。。)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果配置参数类型是数组，那么赋值时，可以用&#123;&#125;表示数组</span></span><br><span class="line">@自定义注解名(配置参数名<span class="number">1</span>=&#123;值&#125;，配置参数名<span class="number">2</span>=值。。。)</span><br></pre></td></tr></table></figure><p>（3）如果配置参数只有一个，并且名称是value，那么赋值时可以省略value=</p><p>（4）如果读取这个注解时，要获取配置参数的值的话，可以当成方法一样来访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自定义注解对象.配置参数();</span><br></pre></td></tr></table></figure><h1 id="第九章-异常"><a href="#第九章-异常" class="headerlink" title="第九章 异常"></a>第九章 异常</h1><h2 id="9-1-异常的类型的体系结构"><a href="#9-1-异常的类型的体系结构" class="headerlink" title="9.1 异常的类型的体系结构"></a>9.1 异常的类型的体系结构</h2><p>1、异常系列的超父类：java.lang.Throwable</p><p>（1）只有它或它子类的对象，才能被JVM或throw语句“抛”出</p><p>（2）也只有它或它子类的对象，才能被catch“捕获”</p><p>2、Throwable分为两大派别</p><p>（1）Error：严重的错误，需要停下来重新设计、升级解决这个问题</p><p>（2）Exception： 一般的异常，可以通过判断、检验进行避免，或者使用try…catch进行处理</p><p>3、Exception又分为两大类</p><p>（1）运行时异常：</p><p>​    它是RuntimeException或它子类的对象。</p><p>​    这种类型的异常，编译器不会提醒你，要进行throws或try…catch进行处理，但是运行时可能导致崩溃。</p><p>（2）编译时异常：</p><p>​    异常除了运行时异常以外的都是编译时异常。</p><p>​    这种类型的异常，编译器是强制要求你，throws或try…catch进行处理，否则编译不通过。</p><p>4、列出常见的异常类型</p><p>（1）运行时异常</p><p>RuntimeException、NullPointerException（空指针异常），ClassCastException（类型转换异常），ArithmeticException（算术异常），NubmerFormatException（数字格式化异常），IndexOutOfBoundsException（下标越界异常）（ArrayIndexOutOfBoundsException（数组下标越界异常）、StringIndexOutOfBoundsException（字符串下标越界异常））、InputMisMatchException（输入类型不匹配异常）。。。。</p><p>（2）编译时异常</p><p>FileNotFoundException（文件找不到异常）、IOException（输入输出异常）、SQLException（数据库sql语句执行异常）。。。</p><h2 id="9-2-异常的处理"><a href="#9-2-异常的处理" class="headerlink" title="9.2 异常的处理"></a>9.2 异常的处理</h2><p>1、在当前方法中处理：try…catch…finally</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形式一：try...catch</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;。。。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//形式二：try...finally</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    无论<span class="keyword">try</span>中是否有异常，也不管是不是有<span class="keyword">return</span>，都要执行的部分</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形式三：try..catch..finally</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;。。。</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    无论<span class="keyword">try</span>中是否有异常，也不管<span class="keyword">catch</span>是否可以捕获异常，也不管<span class="keyword">try</span>和<span class="keyword">catch</span>中是不是有<span class="keyword">return</span>，都要执行的部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行特点：</p><p>（1）如果try中的代码没有异常，那么try中的代码会正常执行，catch部分就不执行，finally中会执行</p><p>（2）如果try中的代码有异常，那么try中发生异常的代码的后面就不执行了，找对应的匹配的catch分支执行，finally中会执行</p><p><img data-src="/upload_image/java2021_05_31/1559610439025.png" alt="1559610439025"></p><p>2、finally与return混合使用时</p><p>（1）如果finally中有return，一定从finally中的return返回。</p><p>此时try和catch中的return语句，执行了一半，执行了第一个动作。所以，finally中的return语句会覆盖刚刚的返回值</p><p>return 返回值; 语句有两个动作：（1）把返回值放到“操作数栈”中，等当前方法结束后，这个“操作数栈”中的值会返回给调用处（2）结束当前方法的执行</p><p>（2）如果finally中没有return，finally中的语句会执行，但是不影响最终的返回值</p><p>即try和catch中的return语句两步拆开来走，先把（1）把返回值放到“操作数栈”中，（2）然后走finally中的语句（3）再执行return后半个动作，结束当前方法</p><p>3、在当前方法中不处理异常，明确要抛给调用者处理，使用throws</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 返回值类型  方法名(【形参列表】) <span class="keyword">throws</span> 异常列表&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时调用者，就知道需要处理哪些异常。</p><p>方法的重写的要求：</p><p>（1）方法名：相同</p><p>（2）形参列表：相同</p><p>（3）返回值类型：</p><p>​    基本数据类型和void：相同</p><p>​    引用数据类型：&lt;=</p><p>（4）修饰符：</p><p>​    权限修饰符：&gt;=</p><p>​    其他修饰符：static，final，private不能被重写</p><p>（5）throws：&lt;=</p><p>方法的重载：</p><p>（1）方法名：相同</p><p>（2）形参列表：必须不同</p><p>（3）返回值类型：无关</p><p>（4）修饰符：无关</p><p>（5）throws：无关</p><h2 id="9-3-手动抛出异常：throw"><a href="#9-3-手动抛出异常：throw" class="headerlink" title="9.3 手动抛出异常：throw"></a>9.3 手动抛出异常：throw</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> 异常对象;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AccountException(<span class="string">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure><p>throw抛出来的异常对象，和JVM抛出来的异常对象一样，也要用try..catch处理或者throws。</p><p>如果是运行时异常，编译器不会强制要求你处理，如果是编译时异常，那么编译器会强制要求你处理。</p><h2 id="9-4-自定义异常"><a href="#9-4-自定义异常" class="headerlink" title="9.4  自定义异常"></a>9.4  自定义异常</h2><p>1、必须继承Throwable或它的子类</p><p>我们见到比较多的是继承RuntimeException和Exception.</p><p>如果你继承RuntimeException或它的子类，那么你自定义的这个异常就是运行时异常。编译器就不会提醒你处理。</p><p>如果你继承Exception，那么它属于编译时异常，编译器会强制你处理。</p><p>2、建议大家保留两个构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">public</span> 自定义异常名()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line"><span class="keyword">public</span> 自定义异常名(String message)&#123;</span><br><span class="line">    <span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、自定义异常对象，必须手动抛出，用throw抛出</p><h2 id="9-5-关于异常的几个方法"><a href="#9-5-关于异常的几个方法" class="headerlink" title="9.5 关于异常的几个方法"></a>9.5 关于异常的几个方法</h2><p>（1）e.printStackTrace()：打印异常对象的详细信息，包括异常类型，message，堆栈跟踪信息。这个对于调试，或者日志跟踪是非常有用的</p><p>（2）e.getMessage()：只是获取异常的message信息</p><p>关于异常信息的打印：</p><p>用System.err打印和用e.printStackTrace()都是会标记红色的突出。</p><p>用System.out打印，当成普通信息打印。</p><p>这两个打印是两个独立的线程，顺序是不能精确控制的。</p><h1 id="第十章-多线程"><a href="#第十章-多线程" class="headerlink" title="第十章  多线程"></a>第十章  多线程</h1><h2 id="10-1-相关的概念"><a href="#10-1-相关的概念" class="headerlink" title="10.1 相关的概念"></a>10.1 相关的概念</h2><p>1、程序（Program）</p><p>​    为了实现一个功能，完成一个任务而选择一种编程语言编写的一组指令的集合。</p><p>2、进程（Process）</p><p>​    程序的一次运行。操作系统会给这个进程分配资源（内存）。</p><p>​    进程是操作系统分配资源的最小单位。</p><p>​    进程与进程之间的内存是独立，无法直接共享。</p><p>​    最早的DOS操作系统是单任务的，同一时间只能运行一个进程。后来现在的操作系统都是支持多任务的，可以同时运行多个进程。进程之间来回切换。成本比较高。</p><p>3、线程（Thread）</p><p>​    线程是进程中的其中一条执行路径。一个进程中至少有一个线程，也可以有多个线程。有的时候也把线程称为轻量级的进程。</p><p>​    同一个进程的多个线程之间有些内存是可以共享的（方法区、堆），也有些内存是独立的（栈（包括虚拟机栈和本地方法栈）、程序计数器）。</p><p>​    线程之间的切换相对进程来说成本比较低。</p><p>4、并行： 多个处理器同时可以执行多条执行路径。</p><p>5、并发：多个任务同时执行，但是可能存在先后关系。</p><h2 id="10-2-两种实现多线程的方式"><a href="#10-2-两种实现多线程的方式" class="headerlink" title="10.2  两种实现多线程的方式"></a>10.2  两种实现多线程的方式</h2><p>1、继承Thread类</p><p> 步骤：</p><p>（1）编写线程类，去继承Thread类</p><p>（2）重写public void run(){}</p><p>（3）创建线程对象</p><p>（4）调用start()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread my = <span class="keyword">new</span> MyThread();</span><br><span class="line">        my.start();<span class="comment">//有名字的线程对象启动</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> MyThread().start();<span class="comment">//匿名线程对象启动</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类的匿名对象启动</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类，但是通过父类的变量多态引用，启动线程</span></span><br><span class="line">        Thread t =  <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、实现Runnable接口</p><p>步骤：</p><p>（1）编写线程类，实现Runnable接口</p><p>（2）重写public void run(){}</p><p>（3）创建线程对象</p><p>（4）借助Thread类的对象启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//两个匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类的匿名对象作为实参直接传给Thread的构造器</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-3-线程的生命周期"><a href="#10-3-线程的生命周期" class="headerlink" title="10.3 线程的生命周期"></a>10.3 线程的生命周期</h2><p><img data-src="/upload_image/java2021_05_31/1559782705811.png" alt="1559782705811"></p><h2 id="10-4-Thread的相关API"><a href="#10-4-Thread的相关API" class="headerlink" title="10.4 Thread的相关API"></a>10.4 Thread的相关API</h2><p>1、构造器</p><ul><li>Thread()</li><li>Thread(String name)</li><li>Thread(Runnable target)</li><li>Thread(Runnable target, String name)</li></ul><p>2、其他方法</p><p>（1）public void run()</p><p>（2）public void start()</p><p>（3）获取当前线程对象：Thread.currentThread()</p><p>（4）获取当前线程的名称：getName()</p><p>（5）设置或获取线程的优先级：set/getPriority()</p><p>优先级的范围：[1,10]，Thread类中有三个常量：MAX_PRIORITY(10)，MIN_PRIORITY(1)，NORM_PRIORITY(5)</p><p>优先级只是影响概率。</p><p>（6）线程休眠：Thread.sleep(毫秒)</p><p>（7）打断线程：interrupt()</p><p>（8）暂停当前线程：Thread.yield()</p><p>（9）线程要加塞：join()</p><blockquote><p>xx.join()这句代码写在哪个线程体中，哪个线程被加塞，和其他线程无关。</p></blockquote><p>（10）判断线程是否已启动但未终止：isAlive()</p><h2 id="10-5-关键字：volatile"><a href="#10-5-关键字：volatile" class="headerlink" title="10.5 关键字：volatile"></a>10.5 关键字：volatile</h2><p>volatile：易变，不稳定，不一定什么时候会变</p><p>修饰：成员变量</p><p>作用：当多个线程同时去访问的某个成员变量时，而且是频繁的访问，再多次访问时，发现它的值没有修改，Java执行引擎就会对这个成员变量的值进行缓存。一旦缓存之后，这个时候如果有一个线程把这个成员变量的值修改了，Jav执行引擎还是从缓存中读取，导致这个值不是最新的。如果不希望Java执行引擎把这个成员变的值缓存起来，那么就可以在成员变量的前面加volatile，每次用到这个成员变量时，都是从主存中读取。</p><h2 id="10-6-关键字：synchronized（同步）"><a href="#10-6-关键字：synchronized（同步）" class="headerlink" title="10.6  关键字：synchronized（同步）"></a>10.6  关键字：synchronized（同步）</h2><p>1、什么情况下会发生线程安全问题？</p><p>（1）多个线程</p><p>（2）共享数据</p><p>（3）多个线程的线程体中，多条语句再操作这个共享数据时</p><p>2、如何解决线程安全问题？同步锁</p><p>形式一：同步代码块</p><p>形式二：同步方法</p><p>3、同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">    <span class="comment">//一次任务代码，这其中的代码，在执行过程中，不希望其他线程插一脚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁对象：</p><p>（1）任意类型的对象</p><p>（2）确保使用共享数据的这几个线程，使用同一个锁对象</p><p>4、同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> 【修饰符】 返回值类型  方法名(【形参列表】)<span class="keyword">throws</span> 异常列表&#123;</span><br><span class="line">    <span class="comment">//同一时间，只能有一个线程能进来运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁对象：</p><p>（1）非静态方法：this（谨慎）</p><p>（2）静态方法：当前类的Class对象</p><h2 id="10-7-线程通信"><a href="#10-7-线程通信" class="headerlink" title="10.7 线程通信"></a>10.7 线程通信</h2><p>1、为了解决“生产者与消费者问题”。</p><p>当一些线程负责往“数据缓冲区”放数据，另一个线程负责从“数据缓冲区”取数据。</p><p>问题1：生产者线程与消费者线程使用同一个数据缓冲区，就是共享数据，那么要考虑同步</p><p>问题2：当数据缓冲区满的时候，生产者线程需要wait()， 当消费者消费了数据后，需要notify或notifyAll</p><p>​        当数据缓冲区空的时候，消费者线程需要wait()， 当生产者生产了数据后，需要notify或notifyAll</p><p>2、java.lang.Object类中声明了：</p><p>（1）wait()：必须由“同步锁”对象调用</p><p>（2）notfiy()和notifyAll()：必须由“同步锁”对象调用</p><p>3、面试题：sleep()和wait的区别</p><p>（1）sleep()不释放锁，wait()释放锁</p><p>（2）sleep()在Thread类中声明的，wait()在Object类中声明</p><p>（3）sleep()是静态方法，是Thread.sleep()</p><p>​        wait()是非静态方法，必须由“同步锁”对象调用</p><p>（4）sleep()方法导致当前线程进入阻塞状态后，当时间到或interrupt()醒来</p><p>​     wait()方法导致当前线程进入阻塞状态后，由notify或notifyAll()</p><p>4、哪些操作会释放锁？</p><p>（1）同步代码块或同步方法正常执行完一次自动释放锁</p><p>（2）同步代码块或同步方法遇到return等提前结束</p><p>（3）wait()</p><p>5、不释放锁</p><p>（1）sleep()</p><p>（2）yield()</p><p>（3）suspend()</p><h1 id="第十一章-常用类"><a href="#第十一章-常用类" class="headerlink" title="第十一章 常用类"></a>第十一章 常用类</h1><h2 id="11-1-包装类"><a href="#11-1-包装类" class="headerlink" title="11.1 包装类"></a>11.1 包装类</h2><h3 id="11-1-1-包装类"><a href="#11-1-1-包装类" class="headerlink" title="11.1.1 包装类"></a>11.1.1 包装类</h3><p>当要使用只针对对象设计的API或新特性（例如泛型），那么基本数据类型的数据就需要用包装类来包装。</p><table><thead><tr><th>序号</th><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>1</td><td>byte</td><td>Byte</td></tr><tr><td>2</td><td>short</td><td>Short</td></tr><tr><td>3</td><td>int</td><td>Integer</td></tr><tr><td>4</td><td>long</td><td>Long</td></tr><tr><td>5</td><td>float</td><td>Float</td></tr><tr><td>6</td><td>double</td><td>Double</td></tr><tr><td>7</td><td>char</td><td>Character</td></tr><tr><td>8</td><td>boolean</td><td>Boolean</td></tr><tr><td>9</td><td>void</td><td>Void</td></tr></tbody></table><h3 id="11-1-2-装箱与拆箱"><a href="#11-1-2-装箱与拆箱" class="headerlink" title="11.1.2  装箱与拆箱"></a>11.1.2  装箱与拆箱</h3><p>JDK1.5之后，可以自动装箱与拆箱。</p><p>注意：只能与自己对应的类型之间才能实现自动装箱与拆箱。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line">Double d = <span class="number">1</span>;<span class="comment">//错误的，1是int类型</span></span><br></pre></td></tr></table></figure><p> 装箱：把基本数据类型转为包装类对象。</p><blockquote><p>转为包装类的对象，是为了使用专门为对象设计的API和特性</p></blockquote><p>拆箱：把包装类对象拆为基本数据类型。</p><blockquote><p>转为基本数据类型，一般是因为需要运算，Java中的大多数运算符是为基本数据类型设计的。比较、算术等</p></blockquote><p>总结：对象（引用数据类型）能用的运算符有哪些？</p><p>（1）instanceof</p><p>（2）=：赋值运算符</p><p>（3）==和!=：用于比较地址，但是要求左右两边对象的类型一致或者是有父子类继承关系。</p><p>（4）对于字符串这一种特殊的对象，支持“+”，表示拼接。</p><h3 id="11-1-3-包装类的一些API"><a href="#11-1-3-包装类的一些API" class="headerlink" title="11.1.3 包装类的一些API"></a>11.1.3 包装类的一些API</h3><p>1、基本数据类型和字符串之间的转换</p><p>（1）把基本数据类型转为字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//String str = a;//错误的</span></span><br><span class="line"><span class="comment">//方式一：</span></span><br><span class="line">String str = a + <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line">String str = String.valueOf(a);</span><br></pre></td></tr></table></figure><p>（2）把字符串转为基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = Integer.parseInt(<span class="string">&quot;整数的字符串&quot;</span>);</span><br><span class="line"><span class="keyword">double</span> a = Double.parseDouble(<span class="string">&quot;小数的字符串&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = Boolean.parseBoolean(<span class="string">&quot;true或false&quot;</span>);</span><br></pre></td></tr></table></figure><p>2、数据类型的最大最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer.MAX_VALUE和Integer.MIN_VALUE</span><br><span class="line">Long.MAX_VALUE和Long.MIN_VALUE</span><br><span class="line">Double.MAX_VALUE和Double.MIN_VALUE</span><br></pre></td></tr></table></figure><p>3、转大小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Character.toUpperCase(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">Character.toLowerCase(<span class="string">&#x27;X&#x27;</span>);</span><br></pre></td></tr></table></figure><p>4、转进制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer.toBinaryString(<span class="keyword">int</span> i) </span><br><span class="line">Integer.toHexString(<span class="keyword">int</span> i)</span><br><span class="line">Integer.toOctalString(<span class="keyword">int</span> i)</span><br></pre></td></tr></table></figure><h3 id="11-1-4-包装类对象的缓存问题"><a href="#11-1-4-包装类对象的缓存问题" class="headerlink" title="11.1.4 包装类对象的缓存问题"></a>11.1.4 包装类对象的缓存问题</h3><table><thead><tr><th>包装类</th><th>缓存对象</th></tr></thead><tbody><tr><td>Byte</td><td>-128~127</td></tr><tr><td>Short</td><td>-128~127</td></tr><tr><td>Integer</td><td>-128~127</td></tr><tr><td>Long</td><td>-128~127</td></tr><tr><td>Float</td><td>没有</td></tr><tr><td>Double</td><td>没有</td></tr><tr><td>Character</td><td>0~127</td></tr><tr><td>Boolean</td><td>true和false</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line">Integer j = <span class="number">1</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="number">128</span>;</span><br><span class="line">Integer j = <span class="number">128</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);<span class="comment">//新new的在堆中</span></span><br><span class="line">Integer j = <span class="number">1</span>;<span class="comment">//这个用的是缓冲的常量对象，在方法区</span></span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);<span class="comment">//新new的在堆中</span></span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);<span class="comment">//另一个新new的在堆中</span></span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//true，凡是和基本数据类型比较，都会先拆箱，按照基本数据类型的规则比较</span></span><br></pre></td></tr></table></figure><h2 id="11-2-字符串"><a href="#11-2-字符串" class="headerlink" title="11.2 字符串"></a>11.2 字符串</h2><h3 id="11-2-1-字符串的特点"><a href="#11-2-1-字符串的特点" class="headerlink" title="11.2.1 字符串的特点"></a>11.2.1 字符串的特点</h3><p>1、字符串String类型本身是final声明的，意味着我们不能继承String。</p><p>2、字符串的对象也是不可变对象，意味着一旦进行修改，就会产生新对象</p><blockquote><p>我们修改了字符串后，如果想要获得新的内容，必须重新接受。</p><p>如果程序中涉及到大量的字符串的修改操作，那么此时的时空消耗比较高。可能需要考虑使用StringBuilder或StringBuffer。</p></blockquote><p>3、String对象内部是用字符数组进行保存的</p><blockquote><p>JDK1.9之前有一个char[] value数组，JDK1.9之后byte[]数组</p></blockquote><p>4、String类中这个char[] values数组也是final修饰的，意味着这个数组不可变，然后它是private修饰，外部不能直接操作它，String类型提供的所有的方法都是用新对象来表示修改后内容的，所以保证了String对象的不可变。</p><p>5、就因为字符串对象设计为不可变，那么所以字符串有常量池来保存很多常量对象</p><p>常量池在方法区。</p><p>如果细致的划分：</p><p>（1）JDK1.6及其之前：方法区</p><p>（2）JDK1.7：堆</p><p>（3）JDK1.8：元空间</p><h3 id="11-2-2-字符串对象的比较"><a href="#11-2-2-字符串对象的比较" class="headerlink" title="11.2.2  字符串对象的比较"></a>11.2.2  字符串对象的比较</h3><p>1、==：比较是对象的地址</p><blockquote><p>只有两个字符串变量都是指向字符串的常量对象时，才会返回true</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str1 == str2<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>2、equals：比较是对象的内容，因为String类型重写equals，区分大小写</p><p>只要两个字符串的字符内容相同，就会返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">str1.equals(strs) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>3、equalsIgnoreCase：比较的是对象的内容，不区分大小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;HELLO&quot;</span>);</span><br><span class="line">str1.equalsIgnoreCase(strs) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>4、compareTo：String类型重写了Comparable接口的抽象方法，自然排序，按照字符的Unicode编码值进行比较大小的，严格区分大小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">str1.compareTo(str2) <span class="comment">//小于0的值</span></span><br></pre></td></tr></table></figure><p>5、compareToIgnoreCase：不区分大小写，其他按照字符的Unicode编码值进行比较大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;HELLO&quot;</span>);</span><br><span class="line">str1.compareToIgnoreCase(str2)  <span class="comment">//等于0</span></span><br></pre></td></tr></table></figure><h3 id="11-2-3-空字符的比较"><a href="#11-2-3-空字符的比较" class="headerlink" title="11.2.3 空字符的比较"></a>11.2.3 空字符的比较</h3><p>1、哪些是空字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String();</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p>空字符串：长度为0</p><p>2、如何判断某个字符串是否是空字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;&quot;</span>.equals(str))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str!=<span class="keyword">null</span>  &amp;&amp; str.isEmpty())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str!=<span class="keyword">null</span> &amp;&amp; str.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str!=<span class="keyword">null</span> &amp;&amp; str.length()==<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="11-2-4-字符串的对象的个数"><a href="#11-2-4-字符串的对象的个数" class="headerlink" title="11.2.4 字符串的对象的个数"></a>11.2.4 字符串的对象的个数</h3><p>1、字符串常量对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;hello&quot;</span>;<span class="comment">//1个，在常量池中</span></span><br></pre></td></tr></table></figure><p>2、字符串的普通对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String();</span><br><span class="line">String str22 = <span class="keyword">new</span> String(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//两个对象，一个是常量池中的空字符串对象，一个是堆中的空字符串对象</span></span><br></pre></td></tr></table></figure><p>3、字符串的普通对象和常量对象一起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//str3首先指向堆中的一个字符串对象，然后堆中字符串的value数组指向常量池中常量对象的value数组</span></span><br></pre></td></tr></table></figure><h3 id="11-2-5-字符串拼接结果"><a href="#11-2-5-字符串拼接结果" class="headerlink" title="11.2.5 字符串拼接结果"></a>11.2.5 字符串拼接结果</h3><p>原则：</p><p>（1）常量+常量：结果是常量池</p><p>（2）常量与变量 或 变量与变量：结果是堆</p><p>（3）拼接后调用intern方法：结果在常量池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line">String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">String s3 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">String s4 = (s1 + <span class="string">&quot;world&quot;</span>).intern();<span class="comment">//把拼接的结果放到常量池中</span></span><br><span class="line">String s5 = (s1 + s2).intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">final</span> String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">String s3 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">String s4 = s1 + <span class="string">&quot;world&quot;</span>;<span class="comment">//s4字符串内容也helloworld，s1是常量，&quot;world&quot;常量，常量+ 常量 结果在常量池中</span></span><br><span class="line">String s5 = s1 + s2;<span class="comment">//s5字符串内容也helloworld，s1和s2都是常量，常量+ 常量 结果在常量池中</span></span><br><span class="line">String s6 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;<span class="comment">//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">String s3 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">String s4 = s1 + <span class="string">&quot;world&quot;</span>;<span class="comment">//s4字符串内容也helloworld，s1是变量，&quot;world&quot;常量，变量 + 常量的结果在堆中</span></span><br><span class="line">String s5 = s1 + s2;<span class="comment">//s5字符串内容也helloworld，s1和s2都是变量，变量 + 变量的结果在堆中</span></span><br><span class="line">String s6 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;<span class="comment">//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-2-6-字符串的API"><a href="#11-2-6-字符串的API" class="headerlink" title="11.2.6 字符串的API"></a>11.2.6 字符串的API</h3><p>（1）boolean isEmpty()</p><p>（2）int length()</p><p>（3）String concat(xx)：拼接，等价于+</p><p>（4）boolean contanis(xx)</p><p>（5）int indexOf()：从前往后找，要是没有返回-1</p><p>（6）int lastIndexOf()：从后往前找，要是没有返回-1</p><p>（7）char charAt(index)</p><p>（8）new String(char[] ) 或new String(char[] ,int, int)</p><p>（9）char[] toCharArray()</p><p>（10）byte[] getBytes()：编码，把字符串变为字节数组，按照平台默认的字符编码进行编码</p><p>​    byte[] getBytes(字符编码方式)：按照指定的编码方式进行编码</p><p>（11）new String(byte[] ) 或 new String(byte[], int, int)：解码，按照平台默认的字符编码进行解码</p><p>​           new String(byte[]，字符编码方式 ) 或 new String(byte[], int, int，字符编码方式)：解码，按照指定的编码方式进行解码</p><p>（12）String subString(int begin)：从[begin]开始到最后</p><p>String subString(int begin,int end)：从[begin, end)</p><p>（13）boolean matchs(正则表达式)</p><p>（14）String replace(xx,xx)：不支持正则</p><p>String replaceFirst(正则，value)：替换第一个匹配部分</p><p>String repalceAll(正则， value)：替换所有匹配部分</p><p>（15）String[] split(正则)：按照某种规则进行拆分</p><p>（16）boolean startsWith(xx)：是否以xx开头</p><p>boolean endsWith(xx)：是否以xx结尾</p><p>（17）String trim()：去掉前后空白符，字符串中间的空白符不会去掉</p><p>（18）String toUpperCase()：转大写</p><p>（19）String  toLowerCase()：转小写</p><p>面试题：字符串的length和数组的length有什么不同？</p><p>字符串的length()，数组的length属性</p><h2 id="11-3-可变字符序列"><a href="#11-3-可变字符序列" class="headerlink" title="11.3 可变字符序列"></a>11.3 可变字符序列</h2><p>1、可变字符序列：StringBuilder和StringBuffer</p><p>StringBuffer：老的，线程安全的（因为它的方法有synchronized修饰）</p><p>StringBuilder：线程不安全的</p><p>2、面试题：String和StringBuilder、StringBuffer的区别？</p><p>String：不可变对象，不可变字符序列</p><p>StringBuilder、StringBuffer： 可变字符序列</p><p>3、常用的API，StringBuilder、StringBuffer的API是完全一致的</p><p>（1）append(xx)：拼接，追加</p><p>（2）insert(int index, xx)：插入</p><p>（3）delete(int start, int end)</p><p>deleteCharAt(int index)</p><p>（4）set(int index, xx)</p><p>（5）reverse()：反转</p><p>….  替换、截取、查找…</p><h2 id="11-4-和数学相关的"><a href="#11-4-和数学相关的" class="headerlink" title="11.4 和数学相关的"></a>11.4 和数学相关的</h2><p>1、java.lang.Math类</p><p>（1）sqrt()：求平方根</p><p>（2）pow(x,y)：求x的y次方</p><p>（3）random()：返回[0,1)范围的小数</p><p>（4）max(x,y)：找x,y最大值</p><p>​      min(x,y)：找最小值</p><p>（5）round(x)：四舍五入</p><p>​         ceil(x)：进一</p><p>​         floor(x)：退一</p><p>…..</p><p>2、java.math包</p><p>BigInteger：大整数</p><p>BigDecimal：大小数</p><p>运算通过方法完成：add(),subtract(),multiply(),divide()….</p><h2 id="11-5-日期时间API"><a href="#11-5-日期时间API" class="headerlink" title="11.5 日期时间API"></a>11.5 日期时间API</h2><h3 id="11-5-1-JDK1-8之前"><a href="#11-5-1-JDK1-8之前" class="headerlink" title="11.5.1 JDK1.8之前"></a>11.5.1 JDK1.8之前</h3><p>1、java.util.Date</p><p>new  Date()：当前系统时间</p><p>long  getTime()：返回该日期时间对象距离1970-1-1 0.0.0 0毫秒之间的毫秒值</p><p>new Date(long 毫秒)：把该毫秒值换算成日期时间对象</p><p>2、java.util.Calendar：</p><p>（1）getInstance()：得到Calendar的镀锡</p><p>（2）get(常量)</p><p>3、java.text.SimpleDateFormat：日期时间的格式化</p><p>y：表示年</p><p>M：月</p><p>d：天</p><p>H： 小时，24小时制</p><p>h：小时，12小时制</p><p>m：分</p><p>s：秒</p><p>S：毫秒</p><p>E：星期</p><p>D：年当中的天数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">String str = <span class="string">&quot;2019年06月06日 16时03分14秒 545毫秒  星期四 +0800&quot;</span>;</span><br><span class="line">SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒  E Z&quot;</span>);</span><br><span class="line">Date d = sf.parse(str);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒  E Z&quot;</span>);</span><br><span class="line"><span class="comment">//把Date日期转成字符串，按照指定的格式转</span></span><br><span class="line">String str = sf.format(d);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">String[] all = TimeZone.getAvailableIDs();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all.length; i++) &#123;</span><br><span class="line">System.out.println(all[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">TimeZone t = TimeZone.getTimeZone(<span class="string">&quot;America/Los_Angeles&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//getInstance(TimeZone zone)</span></span><br><span class="line">Calendar c = Calendar.getInstance(t);</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">System.out.println(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">System.out.println(year);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> month = c.get(Calendar.MONTH)+<span class="number">1</span>;</span><br><span class="line">System.out.println(month);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> time = Long.MAX_VALUE;</span><br><span class="line">Date d = <span class="keyword">new</span> Date(time);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> time = <span class="number">1559807047979L</span>;</span><br><span class="line">Date d = <span class="keyword">new</span> Date(time);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="keyword">long</span> time = d.getTime();</span><br><span class="line">System.out.println(time);<span class="comment">//1559807047979</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">System.out.println(time);<span class="comment">//1559806982971</span></span><br><span class="line"><span class="comment">//当前系统时间距离1970-1-1 0:0:0 0毫秒的时间差，毫秒为单位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-5-2-JDK1-8之后"><a href="#11-5-2-JDK1-8之后" class="headerlink" title="11.5.2 JDK1.8之后"></a>11.5.2 JDK1.8之后</h3><p>java.time及其子包中。</p><p>1、LocalDate、LocalTime、LocalDateTime</p><p>（1）now()：获取系统日期或时间</p><p>（2）of(xxx)：或者指定的日期或时间</p><p>（3）运算：运算后得到新对象，需要重新接受</p><p>plusXxx()：在当前日期或时间对象上加xx</p><p>minusXxx() ：在当前日期或时间对象上减xx</p><table><thead><tr><th>方法</th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>now() / now(ZoneId zone)</td><td>静态方法，根据当前时间创建对象/指定时区的对象</td></tr><tr><td>of()</td><td>静态方法，根据指定日期/时间创建对象</td></tr><tr><td>getDayOfMonth()/getDayOfYear()</td><td>获得月份天数(1-31) /获得年份天数(1-366)</td></tr><tr><td>getDayOfWeek()</td><td>获得星期几(返回一个 DayOfWeek 枚举值)</td></tr><tr><td>getMonth()</td><td>获得月份, 返回一个 Month 枚举值</td></tr><tr><td>getMonthValue() / getYear()</td><td>获得月份(1-12) /获得年份</td></tr><tr><td>getHours()/getMinute()/getSecond()</td><td>获得当前对象对应的小时、分钟、秒</td></tr><tr><td>withDayOfMonth()/withDayOfYear()/withMonth()/withYear()</td><td>将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</td></tr><tr><td>with(TemporalAdjuster  t)</td><td>将当前日期时间设置为校对器指定的日期时间</td></tr><tr><td>plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours()</td><td>向当前对象添加几天、几周、几个月、几年、几小时</td></tr><tr><td>minusMonths() / minusWeeks()/minusDays()/minusYears()/minusHours()</td><td>从当前对象减去几月、几周、几天、几年、几小时</td></tr><tr><td>plus(TemporalAmount t)/minus(TemporalAmount t)</td><td>添加或减少一个 Duration 或 Period</td></tr><tr><td>isBefore()/isAfter()</td><td>比较两个 LocalDate</td></tr><tr><td>isLeapYear()</td><td>判断是否是闰年（在LocalDate类中声明）</td></tr><tr><td>format(DateTimeFormatter  t)</td><td>格式化本地日期、时间，返回一个字符串</td></tr><tr><td>parse(Charsequence text)</td><td>将指定格式的字符串解析为日期、时间</td></tr></tbody></table><p>2、DateTimeFormatter：日期时间格式化</p><p>该类提供了三种格式化方法：</p><p>预定义的标准格式。如：ISO_DATE_TIME;ISO_DATE</p><p>本地化相关的格式。如：ofLocalizedDate(FormatStyle.MEDIUM)</p><p>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">//DateTimeFormatter df = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);//2019年6月6日 下午04时40分03秒</span></span><br><span class="line">DateTimeFormatter df = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);<span class="comment">//19-6-6 下午4:40</span></span><br><span class="line">String str = df.format(now);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">DateTimeFormatter df = DateTimeFormatter.ISO_DATE_TIME;<span class="comment">//2019-06-06T16:38:23.756</span></span><br><span class="line">String str = df.format(now);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">DateTimeFormatter df = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒  SSS毫秒  E 是这一年的D天&quot;</span>);</span><br><span class="line">String str = df.format(now);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">LocalDate before = now.minusDays(<span class="number">100</span>);</span><br><span class="line">System.out.println(before);<span class="comment">//2019-02-26</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDate lai = LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">13</span>);</span><br><span class="line">LocalDate go = lai.plusDays(<span class="number">160</span>);</span><br><span class="line">System.out.println(go);<span class="comment">//2019-10-20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDate lai = LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">13</span>);</span><br><span class="line">System.out.println(lai.getDayOfYear());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDate lai = LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">13</span>);</span><br><span class="line">System.out.println(lai);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line">System.out.println(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalTime now = LocalTime.now();</span><br><span class="line">System.out.println(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">System.out.println(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第十二章-集合"><a href="#第十二章-集合" class="headerlink" title="第十二章 集合"></a>第十二章 集合</h1><h2 id="12-1-概念"><a href="#12-1-概念" class="headerlink" title="12.1 概念"></a>12.1 概念</h2><p>数据结构：存储数据的某种结构</p><p>（1）底层的物理结构</p><p>①数组：开辟连续的存储空间，每一个元素使用[下标]进行区别</p><p>②链式：不需要开辟连续的存储空间，但是需要“结点”来包装要存储的数据，结点包含两部分内容：</p><p>​    A、数据</p><p>​    B、记录其他结点的地址，例如：next，pre，left，right，parent等</p><p>（2）表现出来的逻辑结构：动态数组、单向链表、双向链表、队列、栈、二叉树、哈希表、图等</p><h2 id="12-2-手动实现一些逻辑结构"><a href="#12-2-手动实现一些逻辑结构" class="headerlink" title="12.2 手动实现一些逻辑结构"></a>12.2 手动实现一些逻辑结构</h2><p>1、动态数组</p><p>包含：</p><p>（1）内部使用一个数组，用来存储数据</p><p>（2）内部使用一个total，记录实际存储的元素的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span> </span>&#123;</span><br><span class="line"><span class="comment">//为什么使用Object，因为只是说这个容器是用来装对象的，但是不知道用来装什么对象。</span></span><br><span class="line"><span class="keyword">private</span> Object[] data;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyArrayList</span><span class="params">()</span></span>&#123;</span><br><span class="line">data = <span class="keyword">new</span> Object[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="comment">//检查是否需要扩容</span></span><br><span class="line">checkCapacity();</span><br><span class="line">data[total++] = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果data满了，就扩容为原来的2倍</span></span><br><span class="line"><span class="keyword">if</span>(total &gt;= data.length)&#123;</span><br><span class="line">data = Arrays.copyOf(data, data.length*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回实际元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回数组的实际容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> data.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取[index]位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="comment">//校验index的合理性范围</span></span><br><span class="line">checkIndex(index);</span><br><span class="line"><span class="keyword">return</span> data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=total)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(index+<span class="string">&quot;对应位置的元素不存在&quot;</span>);</span><br><span class="line"><span class="comment">//throw new IndexOutOfBoundsException(index+&quot;越界&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换[index]位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object value)</span></span>&#123;</span><br><span class="line"><span class="comment">//校验index的合理性范围</span></span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line">data[index] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在[index]位置插入一个元素value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, Object value)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)考虑下标的合理性</span></span><br><span class="line"><span class="comment"> * (2)总长度是否够</span></span><br><span class="line"><span class="comment"> * (3)[index]以及后面的元素往后移动，把[index]位置腾出来</span></span><br><span class="line"><span class="comment"> * (4)data[index]=value  放入新元素</span></span><br><span class="line"><span class="comment"> * (5)total++  有效元素的个数增加</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)考虑下标的合理性：校验index的合理性范围</span></span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)总长度是否够：检查是否需要扩容</span></span><br><span class="line">checkCapacity();</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)[index]以及后面的元素往后移动，把[index]位置腾出来</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 假设total = 5, data.length= 10, index= 1</span></span><br><span class="line"><span class="comment"> * 有效元素的下标[0,4]</span></span><br><span class="line"><span class="comment"> * 移动：[1]-&gt;[2],[2]-&gt;[3],[3]-&gt;[4],[4]-&gt;[5]</span></span><br><span class="line"><span class="comment"> * 移动元素的个数：total-index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.arraycopy(data, index, data, index+<span class="number">1</span>, total-index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)data[index]=value  放入新元素</span></span><br><span class="line">data[index] = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(5)total++  有效元素的个数增加</span></span><br><span class="line">total++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回所有实际存储的元素</span></span><br><span class="line"><span class="keyword">public</span> Object[] getAll()&#123;</span><br><span class="line"><span class="comment">//返回total个</span></span><br><span class="line"><span class="keyword">return</span> Arrays.copyOf(data, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除[index]位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)校验index的合理性范围</span></span><br><span class="line"><span class="comment"> * (2)移动元素，把[index+1]以及后面的元素往前移动</span></span><br><span class="line"><span class="comment"> * (3)把data[total-1]=null  让垃圾回收器尽快回收</span></span><br><span class="line"><span class="comment"> * (4)总元素个数减少 total--</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)考虑下标的合理性：校验index的合理性范围</span></span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)移动元素，把[index+1]以及后面的元素往前移动</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 假设total=8, data.length=10, index = 3</span></span><br><span class="line"><span class="comment"> * 有效元素的范围[0,7]</span></span><br><span class="line"><span class="comment"> * 移动：[4]-&gt;[3],[5]-&gt;[4],[6]-&gt;[5],[7]-&gt;[6]</span></span><br><span class="line"><span class="comment"> * 移动了4个：total-index-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.arraycopy(data, index+<span class="number">1</span>, data, index, total-index-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)把data[total-1]=null  让垃圾回收器尽快回收</span></span><br><span class="line">data[total-<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)总元素个数减少 total--</span></span><br><span class="line">total--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询某个元素的下标</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(data[i] == <span class="keyword">null</span>)&#123;<span class="comment">//等价于 if(data[i] == obj)</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(obj.equals(data[i]))&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数组中的某个元素</span></span><br><span class="line"><span class="comment">//如果有重复的，只删除第一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)先查询obj的[index]</span></span><br><span class="line"><span class="comment"> * (2)如果存在，就调用remove(index)删除就可以</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)先查询obj的[index]</span></span><br><span class="line"><span class="keyword">int</span> index = indexOf(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">remove(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不存在，可以什么也不做</span></span><br><span class="line"><span class="comment">//不存在，也可以抛异常</span></span><br><span class="line"><span class="comment">//throw new RuntimeException(obj + &quot;不存在&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object old, Object value)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)查询old的[index]</span></span><br><span class="line"><span class="comment"> * (2)如果存在，就调用set(index, value)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)查询old的[index]</span></span><br><span class="line"><span class="keyword">int</span> index = indexOf(old);</span><br><span class="line"><span class="keyword">if</span>(index!=-<span class="number">1</span>)&#123;</span><br><span class="line">set(index, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不存在，可以什么也不做</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、单向链表</p><p>包含：</p><p>（1）包含一个Node类型的成员变量first：用来记录第一个结点的地址</p><p>如果这个链表是空的，还没有任何结点，那么first是null。</p><p>最后一个结点的特征：就是它的next是null</p><p>（2）内部使用一个total，记录实际存储的元素的个数</p><p>（3）使用了一个内部类Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里不需要数组，不需要其他的复杂的结构，我只要记录单向链表的“头”结点</span></span><br><span class="line"><span class="keyword">private</span> Node first;<span class="comment">//first中记录的是第一个结点的地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> total;<span class="comment">//这里我记录total是为了后面处理的方便，例如：当用户获取链表有效元素的个数时，不用现数，而是直接返回total等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 内部类，因为这种Node结点的类型，在别的地方没有用，只在单向链表中，用于存储和表示它的结点关系。</span></span><br><span class="line"><span class="comment"> * 因为我这里涉及为内部类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">Object data;<span class="comment">//因为数据可以是任意类型的对象，所以设计为Object</span></span><br><span class="line">Node next;<span class="comment">//因为next中记录的下一个结点的地址，因此类型是结点类型</span></span><br><span class="line"><span class="comment">//这里data,next没有私有化，是希望在外部类中可以不需要get/set，而是直接“结点对象.data&quot;,&quot;结点对象.next&quot;使用</span></span><br><span class="line">Node(Object data, Node next)&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)把obj的数据，包装成一个Node类型结点对象</span></span><br><span class="line"><span class="comment"> * (2)把新结点“链接”当前链表的最后</span></span><br><span class="line"><span class="comment"> * ①当前新结点是第一个结点</span></span><br><span class="line"><span class="comment"> * 如何判断是否是第一个   if(first==null)说明暂时还没有第一个</span></span><br><span class="line"><span class="comment"> * ②先找到目前的最后一个，把新结点链接到它的next中</span></span><br><span class="line"><span class="comment"> * 如何判断是否是最后一个   if(某个结点.next == null)说明这个结点是最后一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//(1)把obj的数据，包装成一个Node类型结点对象</span></span><br><span class="line"><span class="comment">//这里新结点的next赋值为null，表示新结点是最后一个结点</span></span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//①当前新结点是第一个结点</span></span><br><span class="line"><span class="keyword">if</span>(first == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//说明newNode是第一个</span></span><br><span class="line">first = newNode;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//②先找到目前的最后一个，把新结点链接到它的next中</span></span><br><span class="line">Node node = first;</span><br><span class="line"><span class="keyword">while</span>(node.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出循环时node指向最后一个结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把新结点链接到它的next中</span></span><br><span class="line">node.next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">total++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object[] getAll()&#123;</span><br><span class="line"><span class="comment">//(1)创建一个数组，长度为total</span></span><br><span class="line">Object[] all = <span class="keyword">new</span> Object[total];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)把单向链表的每一个结点中的data，拿过来放到all数组中</span></span><br><span class="line">Node node = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="comment">//all[i] = 结点.data;</span></span><br><span class="line">all[i] = node.data;</span><br><span class="line"><span class="comment">//然后node指向下一个</span></span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)返回数组</span></span><br><span class="line"><span class="keyword">return</span> all;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//(1)先考虑是否是第一个</span></span><br><span class="line"><span class="keyword">if</span>(first!=<span class="keyword">null</span>)&#123;<span class="comment">//链表非空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要删除的结点正好是第一个结点</span></span><br><span class="line"><span class="keyword">if</span>(first.data == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//让第一个结点指向它的下一个</span></span><br><span class="line">first = first.next;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要删除的不是第一个结点</span></span><br><span class="line">Node node = first.next;<span class="comment">//第二个结点</span></span><br><span class="line">Node last = first;</span><br><span class="line"><span class="keyword">while</span>(node.next!=<span class="keyword">null</span>)&#123;<span class="comment">//这里不包括最后一个，因为node.next==null，不进入循环，而node.next==null是最后一个</span></span><br><span class="line"><span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line">last.next = node.next;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">last = node;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独判断最后一个是否是要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//要删除的是最后一个结点</span></span><br><span class="line">last.next = <span class="keyword">null</span>;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//(1)先考虑是否是第一个</span></span><br><span class="line"><span class="keyword">if</span>(first!=<span class="keyword">null</span>)&#123;<span class="comment">//链表非空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要删除的结点正好是第一个结点</span></span><br><span class="line"><span class="keyword">if</span>(obj.equals(first.data))&#123;</span><br><span class="line"><span class="comment">//让第一个结点指向它的下一个</span></span><br><span class="line">first = first.next;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要删除的不是第一个结点</span></span><br><span class="line">Node node = first.next;<span class="comment">//第二个结点</span></span><br><span class="line">Node last = first;</span><br><span class="line"><span class="keyword">while</span>(node.next!=<span class="keyword">null</span>)&#123;<span class="comment">//这里不包括最后一个，因为node.next==null，不进入循环，而node.next==null是最后一个</span></span><br><span class="line"><span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line">last.next = node.next;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">last = node;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独判断最后一个是否是要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line"><span class="comment">//要删除的是最后一个结点</span></span><br><span class="line">last.next = <span class="keyword">null</span>;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">Node node = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Node node = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="12-3-Collection"><a href="#12-3-Collection" class="headerlink" title="12.3  Collection"></a>12.3  Collection</h2><p>因为集合的类型很多，那么我们把它们称为集合框架。</p><p>集合框架分为两个家族：Collection（一组对象）和Map（一组映射关系、一组键值对）</p><h3 id="12-3-1-Collection"><a href="#12-3-1-Collection" class="headerlink" title="12.3.1 Collection"></a>12.3.1 Collection</h3><p>Collection是代表一种对象的集合。它是Collection系列的根接口。</p><p>它们虽然：有些可能是有序的，有些可能是无序的，有些可能可以重复的，有些不能重复的，但是它们有共同的操作规范，因此这些操作的规范就抽象为了Collection接口。</p><p>常用方法：</p><p>（1）boolean add(Object obj)：添加一个</p><p>（2）boolean addAll（Collection c）：添加多个</p><p>（3）boolean remove(Object obj)：删除一个</p><p>（4）boolean removeAll(Collection c )： 删除多个</p><p>（5）boolean contains(Object c)：是否包含某个</p><p>（6）boolean containsAll(Collection c)： 是否包含所有</p><p>（7）boolean isEmpty()：是否为空</p><p>（8）int size()：获取元素个数</p><p>（9）void clear()：清空集合</p><p>（10）Object[] toArray()：获取所有元素</p><p>（11）Iterator iterator()： 获取遍历当前集合的迭代器对象</p><p>（12）retainAll(Collection c)：求当前集合与c集合的交集</p><h3 id="12-3-2-Collection系列的集合的遍历"><a href="#12-3-2-Collection系列的集合的遍历" class="headerlink" title="12.3.2  Collection系列的集合的遍历"></a>12.3.2  Collection系列的集合的遍历</h3><p>1、明确使用Iterator迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection c = ....;</span><br><span class="line"></span><br><span class="line">Iterator iter = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hashNext())&#123;</span><br><span class="line">    Object obj = iter.next();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator 接口的方法：</p><p>（1）boolean hasNext()</p><p>（2）Object next()</p><p>（3）void remove()</p><p>2、foreach</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection c &#x3D; ....;</span><br><span class="line"></span><br><span class="line">for(Object  obj :  c)&#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么样的集合（容器）能够使用foreach遍历？</p><p>（1）数组：</p><p>（2）实现了java.lang.Iterable接口</p><p>这个接口有一个抽象方法：Iterator iterator()</p><p>Iterator也是一个接口，它的实现类，通常在集合（容器）类中用内部类实现。并在iterator()的方法中创建它的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span> <span class="keyword">implements</span> <span class="title">Iterable</span></span>&#123;</span><br><span class="line"><span class="comment">//为什么使用Object，因为只是说这个容器是用来装对象的，但是不知道用来装什么对象。</span></span><br><span class="line"><span class="keyword">private</span> Object[] data;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他代码省略....</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyItr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyItr</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cursor;<span class="comment">//游标</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> cursor!=total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> data[cursor++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：如果遍历数组，什么情况下选用foreach，什么情况下选用for循环？</p><p>当如果你的操作中涉及到[下标]操作时，用for最好。</p><p>当你只是查看元素的内容，那么选foreach更简洁一些。</p><p>思考：如果遍历Collection系列集合，什么情况下选用foreach，是否能选用for循环？</p><p>首先考虑使用foreach，如果该集合也有索引信息的话，也可以通过for来操作，如果没有下标的信息，就不要用for。即，如果该集合的物理结构是数组的，那么可以用for，如果物理结构是链式，那么使用下标操作效率很低。</p><p>思考：如果遍历Collection系列集合，什么情况下选用foreach，什么情况下使用Iterator？</p><p>如果只是查看集合的元素，使用foreach，代码会更简洁。</p><p>但是如果要涉及到在遍历集合的同时根据某种条件要删除元素等操作，那么选用Iterator。</p><h2 id="12-4-List"><a href="#12-4-List" class="headerlink" title="12.4 List"></a>12.4 List</h2><h3 id="12-4-1-List概述"><a href="#12-4-1-List概述" class="headerlink" title="12.4.1 List概述"></a>12.4.1 List概述</h3><p>List：是Collection的子接口。</p><p>List系列的集合：有序的、可重复的</p><p>List系列的常用集合：ArrayList、Vector、LinkedList、Stack</p><h3 id="12-4-2-List的API"><a href="#12-4-2-List的API" class="headerlink" title="12.4.2 List的API"></a>12.4.2 List的API</h3><p>常用方法：</p><p>（1）boolean add(Object obj)：添加一个</p><p>（2）boolean addAll（Collection c）：添加多个</p><p>（3）void add(int index, Object obj)：添加一个，指定位置添加</p><p>（4）void addAll(int index, Collection c）：添加多个</p><p>（5）boolean remove(Object obj)：删除一个</p><p>（6）Object remove(int index)：删除指定位置的元素，并返回刚刚删除的元素</p><p>（7）boolean removeAll(Collection c )： 删除多个</p><p>（8）boolean contains(Object c)：是否包含某个</p><p>（9）boolean containsAll(Collection c)： 是否包含所有</p><p>（10）boolean isEmpty()：是否为空</p><p>（11）int size()：获取元素个数</p><p>（12）void clear()：清空集合</p><p>（13）Object[] toArray()：获取所有元素</p><p>（14）Iterator iterator()： 获取遍历当前集合的迭代器对象</p><p>（15）retainAll(Collection c)：求当前集合与c集合的交集</p><p>（16）ListIterator listIterator()：获取遍历当前集合的迭代器对象，这个迭代器可以往前、往后遍历</p><p>（17）ListIterator listIterator(int index)：从[index]位置开始，往前或往后遍历</p><p>（18）Object get(int index)：返回index位置的元素</p><p>（19）List  subList(int start, int end)：截取[start,end)部分的子列表</p><h3 id="12-4-3-ListIterator-接口"><a href="#12-4-3-ListIterator-接口" class="headerlink" title="12.4.3 ListIterator 接口"></a>12.4.3 ListIterator 接口</h3><p>Iterator 接口的方法：</p><p>（1）boolean hasNext()</p><p>（2）Object next()</p><p>（3）void remove()</p><p>ListIterator 是 Iterator子接口：增加了如下方法</p><p>（4）void add(Object obj)</p><p>（5）void set(Object obj)</p><p>（6）boolean hasPrevious()</p><p>（7）Object previous()</p><p>（8）int nextIndex()</p><p>（9）int previousIndex()</p><h3 id="12-4-4-List的实现类们的区别"><a href="#12-4-4-List的实现类们的区别" class="headerlink" title="12.4.4 List的实现类们的区别"></a>12.4.4 List的实现类们的区别</h3><p>ArrayList、Vector、LinkedList、Stack</p><p>（1）ArrayList、Vector：都是动态数组</p><p>Vector是最早版本的动态数组，线程安全的，默认扩容机制是2倍，支持旧版的迭代器Enumeration</p><p>ArrayList是后增的动态数组，线程不安全的，默认扩容机制是1.5倍</p><p>（2）动态数组与LinkedList的区别</p><p>动态数组：底层物理结构是数组</p><p>​    优点：根据[下标]访问的速度很快</p><p>​    缺点：需要开辟连续的存储空间，而且需要扩容，移动元素等操作</p><p>LinkedList：底层物理结构是双向链表</p><p>​    优点：在增加、删除元素时，不需要移动元素，只需要修改前后元素的引用关系</p><p>​    缺点：我们查找元素时，只能从first或last开始查找</p><p>（3）Stack：栈</p><p>是Vector的子类。比Vector多了几个方法，能够表现出“先进后出或后进先出”的特点。</p><p>①Object peek()：访问栈顶元素</p><p>②Object pop()：弹出栈顶元素</p><p>③push()：把元素压入栈顶</p><p>（4）LinkedList可以作为很多种数据结构使用</p><p>单链表：只关注next就可以</p><p>队列：先进先出，找对应的方法</p><p>双端队列(JDK1.6加入)：两头都可以进出，找对应的方法</p><p>栈：先进后出，找对应的方法</p><p>建议：虽然LinkedList是支持对索引进行操作，因为它实现List接口的所有方法，但是我们不太建议调用类似这样的方法，因为效率比较低。</p><h3 id="12-4-5-源码分析"><a href="#12-4-5-源码分析" class="headerlink" title="12.4.5 源码分析"></a>12.4.5 源码分析</h3><h4 id="（1）Vector"><a href="#（1）Vector" class="headerlink" title="（1）Vector"></a>（1）Vector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量initialCapacity为10</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);<span class="comment">//指定capacityIncrement增量为0</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement增量为<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>();</span><br><span class="line">       <span class="comment">//判断了形参初始容量initialCapacity的合法性</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="comment">//创建了一个Object[]类型的数组</span></span><br><span class="line">       <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];<span class="comment">//默认是10</span></span><br><span class="line">       <span class="comment">//增量，默认是0，如果是0，后面就按照2倍增加，如果不是0，后面就按照你指定的增量进行增量</span></span><br><span class="line">       <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//synchronized意味着线程安全的   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">    <span class="comment">//看是否需要扩容</span></span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//把新的元素存入[elementCount]，存入后，elementCount元素的个数增1</span></span><br><span class="line">        elementData[elementCount++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">//看是否超过了当前数组的容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);<span class="comment">//扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//获取目前数组的长度</span></span><br><span class="line">        <span class="comment">//如果capacityIncrement增量是0，新容量 = oldCapacity的2倍</span></span><br><span class="line">        <span class="comment">//如果capacityIncrement增量是不是0，新容量 = oldCapacity + capacityIncrement增量;</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                         capacityIncrement : oldCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果按照上面计算的新容量还不够，就按照你指定的需要的最小容量来扩容minCapacity</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果新容量超过了最大数组限制，那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把旧数组中的数据复制到新数组中，新数组的长度为newCapacity</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeElement(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//查找obj在当前Vector中的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexOf(obj);</span><br><span class="line">    <span class="comment">//如果i&gt;=0，说明存在，删除[i]位置的元素</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        removeElementAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;<span class="comment">//要查找的元素是null值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)<span class="comment">//如果是null值，用==null判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//要查找的元素是非null值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))<span class="comment">//如果是非null值，用equals判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//判断下标的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">&quot; &gt;= &quot;</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//j是要移动的元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果需要移动元素，就调用System.arraycopy进行移动</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//把index+1位置以及后面的元素往前移动</span></span><br><span class="line">        <span class="comment">//index+1的位置的元素移动到index位置，依次类推</span></span><br><span class="line">        <span class="comment">//一共移动j个</span></span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//元素的总个数减少</span></span><br><span class="line">    elementCount--;</span><br><span class="line">    <span class="comment">//将elementData[elementCount]这个位置置空，用来添加新元素，位置的元素等着被GC回收</span></span><br><span class="line">    elementData[elementCount] = <span class="keyword">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）ArrayList源码分析"><a href="#（2）ArrayList源码分析" class="headerlink" title="（2）ArrayList源码分析"></a>（2）ArrayList源码分析</h4><p>JDK1.6：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量为10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">      <span class="comment">//检查初始容量的合法性</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      <span class="comment">//数组初始化为长度为initialCapacity的数组</span></span><br><span class="line"><span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>JDK1.7</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//默认初始容量10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>();</span><br><span class="line">       <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//数组初始化为一个空数组</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;<span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">           <span class="comment">//minCapacity按照 默认初始容量和minCapacity中的的最大值处理</span></span><br><span class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//看是否需要扩容处理</span></span><br><span class="line">       ensureExplicitCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>JDK1.8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<span class="comment">//初始化为空数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存入新元素到[size]位置，然后size自增1</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">//那么minCapacity取DEFAULT_CAPACITY与minCapacity的最大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//查看是否需要扩容</span></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要的最小容量  比  当前数组的长度  大，即当前数组不够存，就扩容</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//当前数组容量</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//新数组容量是旧数组容量的1.5倍</span></span><br><span class="line">        <span class="comment">//看旧数组的1.5倍是否够</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//看旧数组的1.5倍是否超过最大数组限制</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//复制一个新数组</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先找到o在当前ArrayList的数组中的下标</span></span><br><span class="line">    <span class="comment">//分o是否为空两种情况讨论</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;<span class="comment">//null值用==比较</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;<span class="comment">//非null值用equals比较</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line">    <span class="comment">//需要移动的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">      modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被删除的元素，用于最后返回被删除的元素</span></span><br><span class="line">      E oldValue = elementData(index);</span><br><span class="line">      </span><br><span class="line"><span class="comment">//需要移动的元素个数</span></span><br><span class="line">      <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">          System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                           numMoved);</span><br><span class="line">      <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">      elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被替换的元素，用于最后返回被替换的元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">//用element替换[index]位置的元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);<span class="comment">//返回[index]位置的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从前往后找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从后往前找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（3）LinkedList源码分析"><a href="#（3）LinkedList源码分析" class="headerlink" title="（3）LinkedList源码分析"></a>（3）LinkedList源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">Node&lt;E&gt; first;<span class="comment">//记录第一个结点的位置</span></span><br><span class="line">Node&lt;E&gt; last;<span class="comment">//记录最后一个结点的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;<span class="comment">//元素数据</span></span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//下一个结点</span></span><br><span class="line">        Node&lt;E&gt; prev;<span class="comment">//前一个结点</span></span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);<span class="comment">//默认把新元素链接到链表尾部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;<span class="comment">//用l 记录原来的最后一个结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//现在的新结点是最后一个结点了</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果l==null，说明原来的链表是空的</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//那么新结点同时也是第一个结点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则把新结点链接到原来的最后一个结点的next中</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">//元素个数增加</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//分o是否为空两种情况</span></span><br><span class="line">      <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//找到o对应的结点x</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">              <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//找到o对应的结点x</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">              <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                  unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;<span class="comment">//x是要被删除的结点</span></span><br><span class="line">      <span class="comment">// assert x != null;</span></span><br><span class="line">      <span class="keyword">final</span> E element = x.item;<span class="comment">//被删除结点的数据</span></span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; next = x.next;<span class="comment">//被删除结点的下一个结点</span></span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="comment">//被删除结点的上一个结点</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果被删除结点的前面没有结点，说明被删除结点是第一个结点</span></span><br><span class="line">      <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//那么被删除结点的下一个结点变为第一个结点</span></span><br><span class="line">          first = next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是第一个结点</span></span><br><span class="line">          <span class="comment">//被删除结点的上一个结点的next指向被删除结点的下一个结点</span></span><br><span class="line">          prev.next = next;</span><br><span class="line">          <span class="comment">//断开被删除结点与上一个结点的链接</span></span><br><span class="line">          x.prev = <span class="keyword">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果被删除结点的后面没有结点，说明被删除结点是最后一个结点</span></span><br><span class="line">      <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//那么被删除结点的上一个结点变为最后一个结点</span></span><br><span class="line">          last = prev;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是最后一个结点</span></span><br><span class="line">          <span class="comment">//被删除结点的下一个结点的prev执行被删除结点的上一个结点</span></span><br><span class="line">          next.prev = prev;</span><br><span class="line">          <span class="comment">//断开被删除结点与下一个结点的连接</span></span><br><span class="line">          x.next = <span class="keyword">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//把被删除结点的数据也置空，使得GC回收</span></span><br><span class="line">      x.item = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//元素个数减少</span></span><br><span class="line">      size--;</span><br><span class="line">      <span class="comment">//修改次数增加</span></span><br><span class="line">      modCount++;</span><br><span class="line">      <span class="comment">//返回被删除结点的数据</span></span><br><span class="line">      <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="12-5-Set"><a href="#12-5-Set" class="headerlink" title="12.5 Set"></a>12.5 Set</h2><h3 id="12-5-1-Set概述"><a href="#12-5-1-Set概述" class="headerlink" title="12.5.1 Set概述"></a>12.5.1 Set概述</h3><p>Set系列的集合：不可重复的</p><p>Set系列的集合，有有序的也有无序的。HashSet无序的，TreeSet按照元素的大小顺序遍历，LinkedHashSet按照元素的添加顺序遍历。</p><h3 id="12-5-2-实现类的特点"><a href="#12-5-2-实现类的特点" class="headerlink" title="12.5.2 实现类的特点"></a>12.5.2 实现类的特点</h3><p>（1）HashSet：</p><p>​    底层是HashMap实现。添加到HashSet的元素是作为HashMap的key，value是一个Object类型的常量对象PRESENT。</p><p>​    依赖于元素的hashCode()和equals()保证元素的不可重复，存储位置和hashCode()值有关，根据hashCode()来算出它在底层table数组中的[index]</p><p>（2）TreeSet</p><p>​    底层是TreeMap实现。添加到TreeSet的元素是作为TreeMap的key，value是一个Object类型的常量对象PRESENT。</p><p>​    依赖于元素的大小，要么是java.lang.Comparable接口compareTo(Object obj)，要么是java.util.Comparator接口的compare(Object o1, Object o2)来比较元素的大小。认为大小相等的两个元素就是重复元素。</p><p>（3）LinkedHashSet</p><p>​    底层是LinkedHashMap。添加到LinkedHashSet的元素是作为LinkedHashMap的key，value是一个Object类型的常量对象PRESENT。</p><p>​    LinkedHashSet是HashSet的子类，比父类多维护了元素的添加顺序。</p><p>​    当且仅当，你既想要元素不可重复，又要保证元素的添加顺序时，再使用它。</p><p>​    </p><h2 id="12-6-Map"><a href="#12-6-Map" class="headerlink" title="12.6 Map"></a>12.6 Map</h2><h3 id="12-6-1-Map概述"><a href="#12-6-1-Map概述" class="headerlink" title="12.6.1 Map概述"></a>12.6.1 Map概述</h3><p>用来存储键值对，映射关系的集合。所有的Map的key都不能重复。</p><p>键值对、映射关系的类型：Entry类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entry接口是Map接口的内部接口。所有的Map的键值对的类型都实现了这个接口。</span><br><span class="line">HashMap中的映射关系，是有一个内部类来实现Entry的接口，JDK1.7是一个叫做Entry的内部类实现Entry接口。</span><br><span class="line">JDK1.8是一个叫做Node的内部类实现Entry接口。</span><br><span class="line">TreeMap中的映射关系，是有一个内部类Entry来实现Entry的接口</span><br></pre></td></tr></table></figure><h3 id="12-6-2-API"><a href="#12-6-2-API" class="headerlink" title="12.6.2 API"></a>12.6.2 API</h3><p>（1）put(Object key, Object value)：添加一对映射关系</p><p>（2）putAll(Map m)：添加多对映射关系</p><p>（3）clear()：清空map</p><p>（4）remove(Object key)：根据key删除一对</p><p>（5）int size()：获取有效元素的对数</p><p>（6）containsKey(Object key)：是否包含某个key</p><p>（7）containsValue(Object value)：是否包含某个value</p><p>（8）Object  get(Object key)：根据key获取value</p><p>（9）遍历相关的几个方法</p><p>Collection  values()：获取所有的value进行遍历</p><p>Set keySet()：获取所有key进行遍历</p><p>Set entrySet()：获取所有映射关系进行遍历</p><h3 id="12-6-3-Map的实现类们的区别"><a href="#12-6-3-Map的实现类们的区别" class="headerlink" title="12.6.3 Map的实现类们的区别"></a>12.6.3 Map的实现类们的区别</h3><p>（1）HashMap：</p><p>​    依据key的hashCode()和equals()来保证key是否重复。</p><p>​    key如果重复，新的value会替换旧的value。</p><p>​    hashCode()决定了映射关系在table数组中的存储的位置，index = hash(key.hashCode()) &amp; table.length-1 </p><p>​    HashMap的底层实现：JDK1.7是数组+链表；JDK1.8是数组+链表/红黑树</p><p>（2）TreeMap</p><p>​    依据key的大小来保证key是否重复。key如果重复，新的value会替换旧的value。</p><p>​    key的大小依赖于，java.lang.Comparable或java.util.Comparator。</p><p>（3）LinkedHashMap</p><p>​    依据key的hashCode()和equals()来保证key是否重复。key如果重复，新的value会替换旧的value。</p><p>​    LinkedHashMap是HashMap的子类，比HashMap多了添加顺序</p><h3 id="12-6-4-HashMap源码分析"><a href="#12-6-4-HashMap源码分析" class="headerlink" title="12.6.4 HashMap源码分析"></a>12.6.4 HashMap源码分析</h3><h4 id="JDK1-6源码："><a href="#JDK1-6源码：" class="headerlink" title="JDK1.6源码："></a>JDK1.6源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//this.loadFactor加载因子，影响扩容的频率</span></span><br><span class="line">    <span class="comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    <span class="comment">//threshold阈值 = 容量 * 加载因子</span></span><br><span class="line">    <span class="comment">//threshold阈值，当size达到threhold时，考虑扩容</span></span><br><span class="line">    <span class="comment">//扩容需要两个条件同时满足：（1）size &gt;= threhold （2）table[index]！=null，即新映射关系要存入的位置非空</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</span><br><span class="line">    <span class="comment">//table是数组，</span></span><br><span class="line">    <span class="comment">//DEFAULT_INITIAL_CAPACITY：默认是16</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JDK1-7源码："><a href="#JDK1-7源码：" class="headerlink" title="JDK1.7源码："></a>JDK1.7源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//DEFAULT_INITIAL_CAPACITY：默认初始容量16</span></span><br><span class="line">  <span class="comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span></span><br><span class="line">      <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//校验initialCapacity合法性</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">      <span class="comment">//校验initialCapacity合法性                                       initialCapacity);</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">          initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      <span class="comment">//校验loadFactor合法性</span></span><br><span class="line">      <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line"><span class="comment">//加载因子，初始化为0.75</span></span><br><span class="line">      <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">      <span class="comment">// threshold 初始为初始容量                                  </span></span><br><span class="line">      threshold = initialCapacity;</span><br><span class="line">      init();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果table数组是空的，那么先创建数组</span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            <span class="comment">//threshold一开始是初始容量的值</span></span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果key是null，单独处理</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对key的hashCode进行干扰，算出一个hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算新的映射关系应该存到table[i]位置，</span></span><br><span class="line">        <span class="comment">//i = hash &amp; table.length-1，可以保证i在[0,table.length-1]范围内</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//检查table[i]下面有没有key与我新的映射关系的key重复，如果重复替换value</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//添加新的映射关系</span></span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">        <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);<span class="comment">//容量是等于toSize值的最接近的2的n次方</span></span><br><span class="line"><span class="comment">//计算阈值 = 容量 * 加载因子</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//创建Entry[]数组，长度为capacity</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果key是null，直接存入[0]的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有重复的key，如果有重复的，就替换value</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//把新的映射关系存入[0]的位置，而且key的hash值用0表示</span></span><br><span class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否需要库容</span></span><br><span class="line">        <span class="comment">//扩容：（1）size达到阈值（2）table[i]正好非空</span></span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            <span class="comment">//table扩容为原来的2倍，并且扩容后，会重新调整所有映射关系的存储位置</span></span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">            <span class="comment">//新的映射关系的hash和index也会重新计算</span></span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//存入table中</span></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        <span class="comment">//原来table[i]下面的映射关系作为新的映射关系next</span></span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;<span class="comment">//个数增加</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1、put(key,value)</p><p>（1）当第一次添加映射关系时，数组初始化为一个长度为<strong>16</strong>的<strong>HashMap$Entry</strong>的数组，这个HashMap$Entry类型是实现了java.util.<strong>Map.Entry</strong>接口</p><p>（2）特殊考虑：如果key为null，index直接是[0]</p><p>（3）在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p><p>（4）计算index = table.length-1 &amp; hash;</p><p>（5）如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。</p><p>（6）如果没有相同的，会把新的映射关系添加到链表的头，原来table[index]下面的Entry对象连接到新的映射关系的next中。</p><p>（7）添加之前先判断if(size &gt;= threshold  &amp;&amp;  table[index]!=null)如果该条件为true，会扩容</p><p>​    if(size &gt;= threshold  &amp;&amp;  table[index]!=null){</p><p>​        ①会扩容</p><p>​        ②会重新计算key的hash</p><p>​        ③会重新计算index</p><p>​    }</p><p>2、get(key)</p><p>（1）计算key的hash值，用这个方法hash(key)</p><p>（2）找index = table.length-1 &amp; hash;</p><p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就返回它的value</p><p>3、remove(key)</p><p>（1）计算key的hash值，用这个方法hash(key)</p><p>（2）找index = table.length-1 &amp; hash;</p><p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</p><h4 id="JDK1-8源码"><a href="#JDK1-8源码" class="headerlink" title="JDK1.8源码"></a>JDK1.8源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">几个常量和变量：</span><br><span class="line">（<span class="number">1</span>）DEFAULT_INITIAL_CAPACITY：默认的初始容量 <span class="number">16</span></span><br><span class="line">（<span class="number">2</span>）MAXIMUM_CAPACITY：最大容量  <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br><span class="line">（<span class="number">3</span>）DEFAULT_LOAD_FACTOR：默认加载因子 <span class="number">0.75</span></span><br><span class="line">（<span class="number">4</span>）TREEIFY_THRESHOLD：默认树化阈值<span class="number">8</span>，当链表的长度达到这个值后，要考虑树化</span><br><span class="line">（<span class="number">5</span>）UNTREEIFY_THRESHOLD：默认反树化阈值<span class="number">6</span>，当树中的结点的个数达到这个阈值后，要考虑变为链表</span><br><span class="line">（<span class="number">6</span>）MIN_TREEIFY_CAPACITY：最小树化容量<span class="number">64</span></span><br><span class="line">当单个的链表的结点个数达到<span class="number">8</span>，并且table的长度达到<span class="number">64</span>，才会树化。</span><br><span class="line">当单个的链表的结点个数达到<span class="number">8</span>，但是table的长度未达到<span class="number">64</span>，会先扩容</span><br><span class="line">（<span class="number">7</span>）Node&lt;K,V&gt;[] table：数组</span><br><span class="line">（<span class="number">8</span>）size：记录有效映射关系的对数，也是Entry对象的个数</span><br><span class="line">（<span class="number">9</span>）<span class="keyword">int</span> threshold：阈值，当size达到阈值时，考虑扩容</span><br><span class="line">（<span class="number">10</span>）<span class="keyword">double</span> loadFactor：加载因子，影响扩容的频率</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">    <span class="comment">// all other fields defaulted，其他字段都是默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//目的：干扰hashCode值</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line"><span class="comment">//如果key是null，hash是0</span></span><br><span class="line"><span class="comment">//如果key非null，用key的hashCode值 与 key的hashCode值高16进行异或</span></span><br><span class="line"><span class="comment">//即就是用key的hashCode值高16位与低16位进行了异或的干扰运算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">index = hash &amp; table.length-1</span></span><br><span class="line"><span class="comment">如果用key的原始的hashCode值  与 table.length-1 进行按位与，那么基本上高16没机会用上。</span></span><br><span class="line"><span class="comment">这样就会增加冲突的概率，为了降低冲突的概率，把高16位加入到hash信息中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; <span class="comment">//数组</span></span><br><span class="line">Node&lt;K,V&gt; p; <span class="comment">//一个结点</span></span><br><span class="line"><span class="keyword">int</span> n, i;<span class="comment">//n是数组的长度   i是下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//tab和table等价</span></span><br><span class="line"><span class="comment">//如果table是空的</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)&#123;</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">tab = resize();</span></span><br><span class="line"><span class="comment">n = tab.length;*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果table是空的，resize()完成了①创建了一个长度为16的数组②threshold = 12</span></span><br><span class="line"><span class="comment">n = 16</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//i = (n - 1) &amp; hash ，下标 = 数组长度-1 &amp; hash</span></span><br><span class="line"><span class="comment">//p = tab[i] 第1个结点</span></span><br><span class="line"><span class="comment">//if(p==null) 条件满足的话说明 table[i]还没有元素</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//把新的映射关系直接放入table[i]</span></span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//newNode（）方法就创建了一个Node类型的新结点，新结点的next是null</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; </span><br><span class="line">K k;</span><br><span class="line"><span class="comment">//p是table[i]中第一个结点</span></span><br><span class="line"><span class="comment">//if(table[i]的第一个结点与新的映射关系的key重复)</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">               e = p;<span class="comment">//用e记录这个table[i]的第一个结点</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;<span class="comment">//如果table[i]第一个结点是一个树结点</span></span><br><span class="line">               <span class="comment">//单独处理树结点</span></span><br><span class="line">               <span class="comment">//如果树结点中，有key重复的，就返回那个重复的结点用e接收，即e!=null</span></span><br><span class="line">               <span class="comment">//如果树结点中，没有key重复的，就把新结点放到树中，并且返回null，即e=null</span></span><br><span class="line">e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//table[i]的第一个结点不是树结点，也与新的映射关系的key不重复</span></span><br><span class="line"><span class="comment">//binCount记录了table[i]下面的结点的个数</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="comment">//如果p的下一个结点是空的，说明当前的p是最后一个结点</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//把新的结点连接到table[i]的最后</span></span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果binCount&gt;=8-1，达到7个时</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)&#123; <span class="comment">// -1 for 1st</span></span><br><span class="line">                           <span class="comment">//要么扩容，要么树化</span></span><br><span class="line">treeifyBin(tab, hash);</span><br><span class="line">&#125;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"><span class="comment">//如果key重复了，就跳出for循环，此时e结点记录的就是那个key重复的结点</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">                   p = e;<span class="comment">//下一次循环，e=p.next，就类似于e=e.next，往链表下移动</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">//如果这个e不是null，说明有key重复，就考虑替换原来的value</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)&#123;</span><br><span class="line">                   e.value = value;</span><br><span class="line">&#125;</span><br><span class="line">               afterNodeAccess(e);<span class="comment">//什么也没干</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素个数增加</span></span><br><span class="line"><span class="comment">//size达到阈值</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)&#123;</span><br><span class="line">           resize();<span class="comment">//一旦扩容，重新调整所有映射关系的位置</span></span><br><span class="line">&#125;</span><br><span class="line">       afterNodeInsertion(evict);<span class="comment">//什么也没干</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//oldTab原来的table</span></span><br><span class="line"><span class="comment">//oldCap：原来数组的长度</span></span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">//oldThr：原来的阈值</span></span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;<span class="comment">//最开始threshold是0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//newCap，新容量</span></span><br><span class="line"><span class="comment">//newThr：新阈值</span></span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//说明原来不是空数组</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//是否达到数组最大限制</span></span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)&#123;</span><br><span class="line"><span class="comment">//newCap = 旧的容量*2 ，新容量&lt;最大数组容量限制</span></span><br><span class="line"><span class="comment">//新容量：32,64，...</span></span><br><span class="line"><span class="comment">//oldCap &gt;= 初始容量16</span></span><br><span class="line"><span class="comment">//新阈值重新算 = 24，48 ....</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">&#125;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)&#123; <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//新容量是默认初始化容量16</span></span><br><span class="line"><span class="comment">//新阈值= 默认的加载因子 * 默认的初始化容量 = 0.75*16 = 12</span></span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;<span class="comment">//阈值赋值为新阈值12，24.。。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建了一个新数组，长度为newCap，16，32,64.。。</span></span><br><span class="line">       <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;<span class="comment">//原来不是空数组</span></span><br><span class="line"><span class="comment">//把原来的table中映射关系，倒腾到新的table中</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;<span class="comment">//e是table下面的结点</span></span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;<span class="comment">//把旧的table[j]位置清空</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)<span class="comment">//如果是最后一个结点</span></span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;<span class="comment">//重新计算e的在新table中的存储位置，然后放入</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果e是树结点</span></span><br><span class="line"><span class="comment">//把原来的树拆解，放到新的table</span></span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">把原来table[i]下面的整个链表，重新挪到了新的table中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建一个新结点</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n, index; </span><br><span class="line">Node&lt;K,V&gt; e;</span><br><span class="line"><span class="comment">//MIN_TREEIFY_CAPACITY：最小树化容量64</span></span><br><span class="line"><span class="comment">//如果table是空的，或者  table的长度没有达到64</span></span><br><span class="line">       <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">           resize();<span class="comment">//先扩容</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//用e记录table[index]的结点的地址</span></span><br><span class="line">           TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">do...while，把table[index]链表的Node结点变为TreeNode类型的结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                   hd = p;<span class="comment">//hd记录根结点</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   p.prev = tl;</span><br><span class="line">                   tl.next = p;</span><br><span class="line">               &#125;</span><br><span class="line">               tl = p;</span><br><span class="line">           &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//如果table[index]下面不是空</span></span><br><span class="line">           <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">               hd.treeify(tab);<span class="comment">//将table[index]下面的链表进行树化</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>1、添加过程</p><p>（1）当第一次添加映射关系时，数组初始化为一个长度为<strong>16</strong>的<strong>HashMap$Node</strong>的数组，这个HashMap$Node类型是实现了java.util.<strong>Map.Entry</strong>接口</p><p>（2）在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p><blockquote><p>JDK1.8关于hash(key)方法的实现比JDK1.7要简洁。 key.hashCode() ^ key.Code()&gt;&gt;&gt;16;</p></blockquote><p>（3）计算index = table.length-1 &amp; hash;</p><p>（4）如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。</p><p>（5）如果没有相同的，</p><p>①table[index]链表的长度没有达到8个，会把新的映射关系添加到链表的尾</p><p>②table[index]链表的长度达到8个，但是table.length没有达到64，会先对table进行扩容，然后再添加</p><p>③table[index]链表的长度达到8个，并且table.length达到64，会先把该分支进行树化，结点的类型变为TreeNode，然后把链表转为一棵红黑树</p><p>④table[index]本来就已经是红黑树了，那么直接连接到树中，可能还会考虑考虑左旋右旋以保证树的平衡问题</p><p>（6）添加完成后判断if(size &gt; threshold ){</p><p>​        ①会扩容</p><p>​        ②会重新计算key的hash</p><p>​        ③会重新计算index</p><p>​    }</p><p>2、remove(key)</p><p>（1）计算key的hash值，用这个方法hash(key)</p><p>（2）找index = table.length-1 &amp; hash;</p><p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</p><p>（4）如果table[index]下面原来是红黑树，结点删除后，个数小于等于6，会把红黑树变为链表</p><h3 id="12-6-5-关于HashMap的面试问题"><a href="#12-6-5-关于HashMap的面试问题" class="headerlink" title="12.6.5 关于HashMap的面试问题"></a>12.6.5 关于HashMap的面试问题</h3><p>1、HashMap的底层实现</p><blockquote><p>答：JDK1.7是数组+链表，JDK1.8是数组+链表/红黑树</p></blockquote><p>2、HashMap的数组的元素类型</p><blockquote><p>答：java.util.Map$Entry接口类型。</p><p>JDK1.7的HashMap中有内部类Entry实现Entry接口</p><p>JDK1.8的HashMap中有内部类Node和TreeNode类型实现Entry接口</p></blockquote><p>3、为什么要使用数组？</p><blockquote><p> 答：因为数组的访问的效率高</p></blockquote><p>4、为什么数组还需要链表？或问如何解决hash或[index]冲突问题？</p><blockquote><p> 答：为了解决hash和[index]冲突问题</p><p> （1）两个不相同的key的hashCode值本身可能相同</p><p> （2）两个hashCode不相同的key，通过hash(key)以及 hash &amp; table.length-1运算得到的[index]可能相同</p><p> 那么意味着table[index]下可能需要存储多个Entry的映射关系对象，所以需要链表</p></blockquote><p>5、HashMap的数组的初始化长度</p><blockquote><p>答：默认的初始容量值是16</p></blockquote><p>6、HashMap的映射关系的存储索引index如何计算</p><blockquote><p>答：hash &amp; table.length-1</p></blockquote><p>7、为什么要使用hashCode()? 空间换时间</p><blockquote><p>答：因为hashCode()是一个整数值，可以用来直接计算index，效率比较高，用数组这种结构虽然会浪费一些空间，但是可以提高查询效率。</p></blockquote><p>8、hash()函数的作用是什么</p><blockquote><p> 答：在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p><p> JDK1.8关于hash(key)方法的实现比JDK1.7要简洁。 key.hashCode() ^ key.Code()&gt;&gt;&gt;16; 因为这样可以使得hashCode的高16位信息也能参与到运算中来</p></blockquote><p>9、HashMap的数组长度为什么一定要是2的幂次方</p><blockquote><p>答：因为2的n次方-1的二进制值是前面都0，后面几位都是1，这样的话，与hash进行&amp;运算的结果就能保证在[0,table.length-1]范围内，而且是均匀的。</p></blockquote><p>10、HashMap 为什么使用 &amp;按位与运算代替%模运算？</p><blockquote><p>答：因为&amp;效率高</p></blockquote><p>11、HashMap的数组什么时候扩容？</p><blockquote><p>答：JDK1.7版：当要添加新Entry对象时发现（1）size达到threshold（2）table[index]!=null时，两个条件同时满足会扩容</p><p>JDK1.8版：当要添加新Entry对象时发现（1）size达到threshold（2）当table[index]下的结点个数达到8个但是table.length又没有达到64。两种情况满足其一都会导致数组扩容</p><p>而且数组一旦扩容，不管哪个版本，都会导致所有映射关系重新调整存储位置。</p></blockquote><p>12、如何计算扩容阈值(临界值)？</p><blockquote><p>答：threshold = capacity * loadfactor</p></blockquote><p>13、loadFactor为什么是0.75，如果是1或者0.1呢有什么不同？</p><blockquote><p>答：1的话，会导致某个table[index]下面的结点个数可能很长</p><p>0.1的话，会导致数组扩容的频率太高</p></blockquote><p>14、JDK1.8的HashMap什么时候树化？</p><blockquote><p>答：当table[index]下的结点个数达到8个但是table.length已经达到64</p></blockquote><p>15、JDK1.8的HashMap什么时候反树化？</p><blockquote><p>答：当table[index]下的树结点个数少于6个</p></blockquote><p>16、JDK1.8的HashMap为什么要树化？</p><blockquote><p>答：因为当table[index]下的结点个数超过8个后，查询效率就低下了，修改为红黑树的话，可以提高查询效率</p></blockquote><p>17、JDK1.8的HashMap为什么要反树化？</p><blockquote><p>答：因为因为当table[index]下树的结点个数少于6个后，使用红黑树反而过于复杂了，此时使用链表既简洁又效率也不错</p></blockquote><p>18、作为HashMap的key类型重写equals和hashCode方法有什么要求</p><p>​    （1）equals与hashCode一起重写</p><p>​    （2）重写equals()方法，但是有一些注意事项；</p><ul><li>自反性：x.equals(x)必须返回true。<br>对称性：x.equals(y)与y.equals(x)的返回值必须相等。<br>传递性：x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。<br>一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)值始终不变。<br>非null：x不是null，y为null，则x.equals(y)必须为false。</li></ul><p>​    （3）重写hashCode（）的注意事项</p><ul><li>如果equals返回true的两个对象，那么hashCode值一定相同，并且只要参与equals判断属性没有修改，hashCode值也不能修改；<br>如果equals返回false的两个对象，那么hashCode值可以相同也可以不同；<br>如果hashCode值不同的，equals一定要返回false；<br>hashCode不宜过简单，太简单会导致冲突严重，hashCode也不宜过于复杂，会导致性能低下；</li></ul><p>19、为什么大部分 hashcode 方法使用 31？</p><blockquote><p> 答：因为31是一个不大不小的素数</p></blockquote><p>20、请问已经存储到HashMap中的key的对象属性是否可以修改？为什么？</p><blockquote><p>答：如果该属性参与hashCode的计算，那么不要修改。因为一旦修改hashCode()已经不是原来的值。<br>而存储到HashMap中时，key的hashCode()–&gt;hash()–&gt;hash已经确定了，不会重新计算。用新的hashCode值再查询get(key)/删除remove(key)时，算的hash值与原来不一样就不找不到原来的映射关系了。</p></blockquote><p>21、所以为什么，我们实际开发中，key的类型一般用String和Integer</p><blockquote><p>答：因为他们不可变。</p></blockquote><p>22、为什么HashMap中的Node或Entry类型的hash变量与key变量加final声明？</p><blockquote><p> 答：因为不希望你修改hash和key值</p></blockquote><p>23、为什么HashMap中的Node或Entry类型要单独存储hash？</p><blockquote><p> 答：为了在添加、删除、查找过程中，比较hash效率更高，不用每次重新计算key的hash值</p></blockquote><p>24、请问已经存储到HashMap中的value的对象属性是否可以修改？为什么？</p><blockquote><p>答：可以。因为我们存储、删除等都是根据key，和value无关。</p></blockquote><p>25、如果key是null是如何存储的？</p><blockquote><p>答：会存在table[0]中</p></blockquote><h2 id="12-7-集合框架图"><a href="#12-7-集合框架图" class="headerlink" title="12.7 集合框架图"></a>12.7 集合框架图</h2><p><img data-src="/upload_image/java2021_05_31/1560348912361.png" alt="1560348912361"></p><h1 id="第13章-泛型"><a href="#第13章-泛型" class="headerlink" title="第13章 泛型"></a>第13章 泛型</h1><h2 id="13-1-泛型的概述"><a href="#13-1-泛型的概述" class="headerlink" title="13.1 泛型的概述"></a>13.1 泛型的概述</h2><p>泛型：参数化类型</p><p>类型形参：<T>，<E>，<K>，<V>，<U>，<R>。。。。</p><p>类型实参：必须是引用数据类型，不能是基本数据类型</p><p>​    <String>，<Integer>，<Student>，&lt;ArrayList<String>&gt;。。。</p><h2 id="13-2-形式一：泛型类与泛型接口"><a href="#13-2-形式一：泛型类与泛型接口" class="headerlink" title="13.2 形式一：泛型类与泛型接口"></a>13.2 形式一：泛型类与泛型接口</h2><p>1、声明语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 class 类名&#x2F;接口&lt;类型形参列表&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 class 类名&#x2F;接口&lt;类型形参1 extends 父类上限&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">【修饰符】 class 类名&#x2F;接口&lt;类型形参1 extends 父类上限 &amp; 父接口上限&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在类名或接口名后面声明的泛型形参类型，可以在当前类或接口中使用，用作声明成员变量、方法的形参、方法的返回值。</p><p>但是不能用于<strong>静态成员</strong>上</p></blockquote><p>2、使用语法格式</p><p>在（1）创建泛型类、泛型接口的对象时，为泛型形参指定具体类型</p><p>​    （2）在继承泛型类或实现泛型接口时，为泛型形参指定具体类型</p><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//JDK1.7之后可以省略</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStringArrayList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee e)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Arrays.sort(数组,  <span class="keyword">new</span>  Comparator&lt;泛型实参&gt;()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(泛型实参类型  o1, 泛型实参类型  o2)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、泛型如果没有指定，会被擦除，按照最左边的上限处理，如果没有指定上限，按照Object处理</p><h2 id="13-3-形式二：泛型方法"><a href="#13-3-形式二：泛型方法" class="headerlink" title="13.3 形式二：泛型方法"></a>13.3 形式二：泛型方法</h2><p>1、声明的语法格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 &lt;泛型形参列表&gt;  返回值类型  方法名(【数据形参列表】)【throws 异常列表】&#123;&#125;</span><br><span class="line">【修饰符】 &lt;泛型形参 extends 父类上限 &amp; 父接口上限&gt;  返回值类型  方法名(【数据形参列表】)【throws 异常列表】&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>（1）在方法返回值类型前面声明的泛型形参类型，只能在当前方法中使用，用于表示形参的类型或返回值类型，或方法局部变量的类型，和别的方法无关。</p><p>（2）泛型方法可以是静态方法，也可以是非静态方法</p></blockquote><p>2、 使用</p><p>当调用方法，会根据具体的数据的实参的类型，来确定泛型实参的类型。</p><h2 id="13-4-通配符？"><a href="#13-4-通配符？" class="headerlink" title="13.4 通配符？"></a>13.4 通配符？</h2><p>（1）?：代表任意引用数据类型</p><p>（2）?  extends 上限：代表上限本身或它的子类</p><p>（3）? super 下限：代表下限本身或它的父类</p><p>例如：</p><p>ArrayList&lt;?&gt;：表示可以接受任意类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br></pre></td></tr></table></figure><p>ArrayList&lt;? extends 上限&gt;：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;? extends Person&gt; list &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line">ArrayList&lt;? extends Person&gt; list &#x3D; new ArrayList&lt;Animal&gt;();&#x2F;&#x2F;Animal不行，因为Animal是父类</span><br><span class="line">ArrayList&lt;? extends Person&gt; list &#x3D; new ArrayList&lt;Student&gt;();</span><br><span class="line">ArrayList&lt;? extends Person&gt; list &#x3D; new ArrayList&lt;Dog&gt;();&#x2F;&#x2F;Dog也不行</span><br></pre></td></tr></table></figure><p>ArrayList&lt;? super 下限&gt;：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;? <span class="keyword">super</span> Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">ArrayList&lt;? <span class="keyword">super</span> Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line">ArrayList&lt;? <span class="keyword">super</span> Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();<span class="comment">//Student，因为Student是子类</span></span><br><span class="line">ArrayList&lt;? <span class="keyword">super</span> Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();<span class="comment">//Dog也不行</span></span><br></pre></td></tr></table></figure><blockquote><p>ArrayList&lt;?&gt;：不能添加元素，除了null</p><p>ArrayList&lt;? extends 上限&gt;：不能添加元素，除了null</p><p>ArrayList&lt;? super 下限&gt;：可以添加下限或下限子类的对象</p></blockquote><h2 id="13-5-Collections工具类"><a href="#13-5-Collections工具类" class="headerlink" title="13.5 Collections工具类"></a>13.5 Collections工具类</h2><p>java.util.Collections：工具类，操作集合</p><p>（1）public static <T> boolean addAll(Collection&lt;? super T&gt; c, T… elements)</p><p>添加elements的几个对象到c集合中。T是elements对象的类型，要求Collection集合的元素类型必须是T或T的父类</p><p>（2）public static <T> int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list,T key)  </p><p>在list集合中用二分查找key的下标，如果存在返回的是合理的下标，如果不存在返回的是一个负数下标   </p><p>T是元素的类型，</p><? extends Comparable<? super T>>，要求集合的元素必须实现Comparable接口<? super T>，在实现Comparable接口，可以指定Comparable<类型实参>为T或T的父类。（3）public static boolean disjoint(Collection<?><p> c1, Collection&lt;?&gt; c2)</p><p>判断c1和c2没有交集就为true</p><p>（4）public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)</p><p>求coll集合中最大元素</p><p>&lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt;：要求T或T的父类实现Comparable接口</p><p>因为找最大值需要比较大小</p><p>（5）public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List<T> list) 给list集合排序   </p><p>&lt;T extends Comparable&lt;? super T&gt;&gt;：要求T或T的父类实现Comparable接口</p><p>（6）public static <T> Collection<T> synchronizedCollection(Collection<T> c)</p><p>以synchronizedXX开头的方法，表示把某种非线程安全集合转为一个线程安全的集合。</p><p>（7）public static <T> List<T> unmodifiableList(List&lt;? extends T&gt; list)</p><p>以unmodifiableXx开头的方法，表示返回一个“只读”的集合。</p><h1 id="第十八章-设计模式"><a href="#第十八章-设计模式" class="headerlink" title="第十八章 设计模式"></a>第十八章 设计模式</h1><h2 id="18-1-模板设计模式（了解）"><a href="#18-1-模板设计模式（了解）" class="headerlink" title="18.1 模板设计模式（了解）"></a>18.1 模板设计模式（了解）</h2><p>1、当解决某个问题，或者完成某个功能时，主体的算法结构（步骤）是确定的，只是其中的一个或者几个小的步骤不确定，要有使用者（子类）来确定时，就可以使用模板设计模式</p><p>2、示例代码：计算任意一段代码的运行时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CalTime</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、获取开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start =  System.currentTimeMills();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、运行xx代码：这个是不确定的</span></span><br><span class="line">        doWork();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、获取结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end =  System.currentTimeMills();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4、计算时间差</span></span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用模板类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCalTime</span> <span class="keyword">extends</span> <span class="title">CalTime</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....需要计算运行时间的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyCalTime my = <span class="keyword">new</span> MyCalTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行时间：&quot;</span> + my.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-2-单例设计模式"><a href="#18-2-单例设计模式" class="headerlink" title="18.2 单例设计模式"></a>18.2 单例设计模式</h2><p>单例：整个系统中，某个类型的对象只有一个。</p><p>1、饿汉式</p><p>（1）枚举式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）形式二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Single INSTANCE = <span class="keyword">new</span> Single();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）形式三</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Single INSTANCE = <span class="keyword">new</span> Single();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、懒汉式</p><p>（1）内部类形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Single INSTANCE = <span class="keyword">new</span> Single();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）形式二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Single.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Single();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Java </category>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机操作系统：（原书第四版-西安电子科技大学出版社）》全书知识梳理笔记</title>
      <link href="2021/04/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%EF%BC%88%E5%8E%9F%E4%B9%A6%E7%AC%AC%E5%9B%9B%E7%89%88-%E8%A5%BF%E5%AE%89%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%87%BA%E7%89%88%E7%A4%BE%EF%BC%89%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/04/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%EF%BC%88%E5%8E%9F%E4%B9%A6%E7%AC%AC%E5%9B%9B%E7%89%88-%E8%A5%BF%E5%AE%89%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E5%87%BA%E7%89%88%E7%A4%BE%EF%BC%89%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="《计算机操作系统：（原书第四版-西安电子科技大学出版社）》全书知识梳理笔记"><a href="#《计算机操作系统：（原书第四版-西安电子科技大学出版社）》全书知识梳理笔记" class="headerlink" title="《计算机操作系统：（原书第四版-西安电子科技大学出版社）》全书知识梳理笔记"></a>《计算机操作系统：（原书第四版-西安电子科技大学出版社）》全书知识梳理笔记</h1><p>本章笔记复习材料采用 《计算机操作系统：（原书第四版-西安电子科技大学出版社）》，目录结构采用顺序排列。</p><h1 id="本书目录"><a href="#本书目录" class="headerlink" title="本书目录"></a>本书目录</h1><h1 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h1><h2 id="1-1-操作系统的目标和作用"><a href="#1-1-操作系统的目标和作用" class="headerlink" title="1.1 操作系统的目标和作用"></a>1.1 操作系统的目标和作用</h2><h2 id="1-2-操作系统的发展过程"><a href="#1-2-操作系统的发展过程" class="headerlink" title="1.2 操作系统的发展过程"></a>1.2 操作系统的发展过程</h2><h2 id="1-3-操作系统的基本特性"><a href="#1-3-操作系统的基本特性" class="headerlink" title="1.3 操作系统的基本特性"></a>1.3 操作系统的基本特性</h2><h2 id="1-4-操作系统的主要功能"><a href="#1-4-操作系统的主要功能" class="headerlink" title="1.4 操作系统的主要功能"></a>1.4 操作系统的主要功能</h2><h2 id="1-5-OS结构设计"><a href="#1-5-OS结构设计" class="headerlink" title="1.5 OS结构设计"></a>1.5 OS结构设计</h2><h1 id="第二章-进程的描述与控制"><a href="#第二章-进程的描述与控制" class="headerlink" title="第二章 进程的描述与控制"></a>第二章 进程的描述与控制</h1><h2 id="2-1-前趋图和程序执行"><a href="#2-1-前趋图和程序执行" class="headerlink" title="2.1 前趋图和程序执行"></a>2.1 前趋图和程序执行</h2><h2 id="2-2-进程的描述"><a href="#2-2-进程的描述" class="headerlink" title="2.2 进程的描述"></a>2.2 进程的描述</h2><h2 id="2-3-进程控制"><a href="#2-3-进程控制" class="headerlink" title="2.3 进程控制"></a>2.3 进程控制</h2><h2 id="2-4-进程同步"><a href="#2-4-进程同步" class="headerlink" title="2.4 进程同步"></a>2.4 进程同步</h2><h2 id="2-5-经典进程的同步问题"><a href="#2-5-经典进程的同步问题" class="headerlink" title="2.5 经典进程的同步问题"></a>2.5 经典进程的同步问题</h2><h2 id="2-6-进程通信"><a href="#2-6-进程通信" class="headerlink" title="2.6 进程通信"></a>2.6 进程通信</h2><h2 id="2-7-线程（Threads）的基本概念"><a href="#2-7-线程（Threads）的基本概念" class="headerlink" title="2.7 线程（Threads）的基本概念"></a>2.7 线程（Threads）的基本概念</h2><h2 id="2-8-线程的实现"><a href="#2-8-线程的实现" class="headerlink" title="2.8 线程的实现"></a>2.8 线程的实现</h2><h1 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章 处理机调度与死锁"></a>第三章 处理机调度与死锁</h1><h2 id="3-1-处理机调度的层次和调度算法的目标"><a href="#3-1-处理机调度的层次和调度算法的目标" class="headerlink" title="3.1 处理机调度的层次和调度算法的目标"></a>3.1 处理机调度的层次和调度算法的目标</h2><h2 id="3-2-作业与作业调度"><a href="#3-2-作业与作业调度" class="headerlink" title="3.2 作业与作业调度"></a>3.2 作业与作业调度</h2><h2 id="3-3-进程调度"><a href="#3-3-进程调度" class="headerlink" title="3.3 进程调度"></a>3.3 进程调度</h2><h2 id="3-4-实时调度"><a href="#3-4-实时调度" class="headerlink" title="3.4 实时调度"></a>3.4 实时调度</h2><h2 id="3-5-死锁概述"><a href="#3-5-死锁概述" class="headerlink" title="3.5 死锁概述"></a>3.5 死锁概述</h2><h2 id="3-6-预防死锁"><a href="#3-6-预防死锁" class="headerlink" title="3.6 预防死锁"></a>3.6 预防死锁</h2><h2 id="3-7-避免死锁"><a href="#3-7-避免死锁" class="headerlink" title="3.7 避免死锁"></a>3.7 避免死锁</h2><h2 id="3-8-死锁的检测与解除"><a href="#3-8-死锁的检测与解除" class="headerlink" title="3.8 死锁的检测与解除"></a>3.8 死锁的检测与解除</h2><h1 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h1><h2 id="4-1-存储器的层次结构"><a href="#4-1-存储器的层次结构" class="headerlink" title="4.1 存储器的层次结构"></a>4.1 存储器的层次结构</h2><h2 id="4-2-程序的装入和链接"><a href="#4-2-程序的装入和链接" class="headerlink" title="4.2 程序的装入和链接"></a>4.2 程序的装入和链接</h2><h2 id="4-3-连续分配存储管理方式"><a href="#4-3-连续分配存储管理方式" class="headerlink" title="4.3 连续分配存储管理方式"></a>4.3 连续分配存储管理方式</h2><h2 id="4-4-对换（Swapping）"><a href="#4-4-对换（Swapping）" class="headerlink" title="4.4 对换（Swapping）"></a>4.4 对换（Swapping）</h2><h2 id="4-5-分页存储管理方式"><a href="#4-5-分页存储管理方式" class="headerlink" title="4.5 分页存储管理方式"></a>4.5 分页存储管理方式</h2><h2 id="4-6-分段存储管理方式"><a href="#4-6-分段存储管理方式" class="headerlink" title="4.6 分段存储管理方式"></a>4.6 分段存储管理方式</h2><h1 id="第五章-虚拟存储器"><a href="#第五章-虚拟存储器" class="headerlink" title="第五章 虚拟存储器"></a>第五章 虚拟存储器</h1><h2 id="5-1-虚拟存储器概述"><a href="#5-1-虚拟存储器概述" class="headerlink" title="5.1 虚拟存储器概述"></a>5.1 虚拟存储器概述</h2><h2 id="5-2-请求分页存储管理方式"><a href="#5-2-请求分页存储管理方式" class="headerlink" title="5.2 请求分页存储管理方式"></a>5.2 请求分页存储管理方式</h2><h2 id="5-3-页面置换算法"><a href="#5-3-页面置换算法" class="headerlink" title="5.3 页面置换算法"></a>5.3 页面置换算法</h2><h2 id="5-4-“抖动”与工作集"><a href="#5-4-“抖动”与工作集" class="headerlink" title="5.4 “抖动”与工作集"></a>5.4 “抖动”与工作集</h2><h2 id="5-5-请求分段存储管理方式"><a href="#5-5-请求分段存储管理方式" class="headerlink" title="5.5 请求分段存储管理方式"></a>5.5 请求分段存储管理方式</h2><h1 id="第六章-输入输出系统"><a href="#第六章-输入输出系统" class="headerlink" title="第六章 输入输出系统"></a>第六章 输入输出系统</h1><h2 id="6-1-I-O系统的功能、模型和接口"><a href="#6-1-I-O系统的功能、模型和接口" class="headerlink" title="6.1 I/O系统的功能、模型和接口"></a>6.1 I/O系统的功能、模型和接口</h2><h2 id="6-2-I-O设备和设备控制器"><a href="#6-2-I-O设备和设备控制器" class="headerlink" title="6.2 I/O设备和设备控制器"></a>6.2 I/O设备和设备控制器</h2><h2 id="6-3-中断机构和中断处理程序"><a href="#6-3-中断机构和中断处理程序" class="headerlink" title="6.3 中断机构和中断处理程序"></a>6.3 中断机构和中断处理程序</h2><h2 id="6-4-设备驱动程序"><a href="#6-4-设备驱动程序" class="headerlink" title="6.4 设备驱动程序"></a>6.4 设备驱动程序</h2><h2 id="6-5-与设备无关的I-O软件"><a href="#6-5-与设备无关的I-O软件" class="headerlink" title="6.5 与设备无关的I/O软件"></a>6.5 与设备无关的I/O软件</h2><h2 id="6-6-用户层的I-O软件"><a href="#6-6-用户层的I-O软件" class="headerlink" title="6.6 用户层的I/O软件"></a>6.6 用户层的I/O软件</h2><h2 id="6-7-缓冲区管理"><a href="#6-7-缓冲区管理" class="headerlink" title="6.7 缓冲区管理"></a>6.7 缓冲区管理</h2><h2 id="6-8-磁盘存储器的性能和调度"><a href="#6-8-磁盘存储器的性能和调度" class="headerlink" title="6.8 磁盘存储器的性能和调度"></a>6.8 磁盘存储器的性能和调度</h2><h1 id="第七章-文件管理"><a href="#第七章-文件管理" class="headerlink" title="第七章 文件管理"></a>第七章 文件管理</h1><h2 id="7-1-文件和文件系统"><a href="#7-1-文件和文件系统" class="headerlink" title="7.1 文件和文件系统"></a>7.1 文件和文件系统</h2><h2 id="7-2-文件的逻辑结构"><a href="#7-2-文件的逻辑结构" class="headerlink" title="7.2 文件的逻辑结构"></a>7.2 文件的逻辑结构</h2><h2 id="7-3-文件目录"><a href="#7-3-文件目录" class="headerlink" title="7.3 文件目录"></a>7.3 文件目录</h2><h2 id="7-4-文件共享"><a href="#7-4-文件共享" class="headerlink" title="7.4 文件共享"></a>7.4 文件共享</h2><h2 id="7-5-文件保护"><a href="#7-5-文件保护" class="headerlink" title="7.5 文件保护"></a>7.5 文件保护</h2><h1 id="第八章-磁盘存储器的管理"><a href="#第八章-磁盘存储器的管理" class="headerlink" title="第八章 磁盘存储器的管理"></a>第八章 磁盘存储器的管理</h1><h2 id="8-1-外存的组织方式"><a href="#8-1-外存的组织方式" class="headerlink" title="8.1 外存的组织方式"></a>8.1 外存的组织方式</h2><h2 id="8-2-文件存储空间的管理"><a href="#8-2-文件存储空间的管理" class="headerlink" title="8.2 文件存储空间的管理"></a>8.2 文件存储空间的管理</h2><h2 id="8-3-提高磁盘I-O速度的途径"><a href="#8-3-提高磁盘I-O速度的途径" class="headerlink" title="8.3 提高磁盘I/O速度的途径"></a>8.3 提高磁盘I/O速度的途径</h2><h2 id="8-4-提高磁盘可靠性的技术"><a href="#8-4-提高磁盘可靠性的技术" class="headerlink" title="8.4 提高磁盘可靠性的技术"></a>8.4 提高磁盘可靠性的技术</h2><h2 id="8-5-数据一致性控制"><a href="#8-5-数据一致性控制" class="headerlink" title="8.5 数据一致性控制"></a>8.5 数据一致性控制</h2><h1 id="第九章-操作系统接口"><a href="#第九章-操作系统接口" class="headerlink" title="第九章 操作系统接口"></a>第九章 操作系统接口</h1><h2 id="9-1-用户接口"><a href="#9-1-用户接口" class="headerlink" title="9.1 用户接口"></a>9.1 用户接口</h2><h2 id="9-2-Shell-命令语言"><a href="#9-2-Shell-命令语言" class="headerlink" title="9.2 Shell 命令语言"></a>9.2 Shell 命令语言</h2><h2 id="9-3-联机命令接口的实现"><a href="#9-3-联机命令接口的实现" class="headerlink" title="9.3 联机命令接口的实现"></a>9.3 联机命令接口的实现</h2><h2 id="9-4-系统调用的概念和类型"><a href="#9-4-系统调用的概念和类型" class="headerlink" title="9.4 系统调用的概念和类型"></a>9.4 系统调用的概念和类型</h2><h2 id="9-5-UNIX-系统实调用"><a href="#9-5-UNIX-系统实调用" class="headerlink" title="9.5 UNIX 系统实调用"></a>9.5 UNIX 系统实调用</h2><h2 id="9-6-系统调用的实现"><a href="#9-6-系统调用的实现" class="headerlink" title="9.6 系统调用的实现"></a>9.6 系统调用的实现</h2><h1 id="第十章-多处理机操作系统"><a href="#第十章-多处理机操作系统" class="headerlink" title="第十章 多处理机操作系统"></a>第十章 多处理机操作系统</h1><h2 id="10-1-多处理机系统的基本概念"><a href="#10-1-多处理机系统的基本概念" class="headerlink" title="10.1 多处理机系统的基本概念"></a>10.1 多处理机系统的基本概念</h2><h2 id="10-2-多处理机系统的结构"><a href="#10-2-多处理机系统的结构" class="headerlink" title="10.2 多处理机系统的结构"></a>10.2 多处理机系统的结构</h2><h2 id="10-3-多处理机操作系统的特征与分类"><a href="#10-3-多处理机操作系统的特征与分类" class="headerlink" title="10.3 多处理机操作系统的特征与分类"></a>10.3 多处理机操作系统的特征与分类</h2><h2 id="10-4-进程同步"><a href="#10-4-进程同步" class="headerlink" title="10.4 进程同步"></a>10.4 进程同步</h2><h2 id="10-5-多处理机系统的进程调度"><a href="#10-5-多处理机系统的进程调度" class="headerlink" title="10.5 多处理机系统的进程调度"></a>10.5 多处理机系统的进程调度</h2><h2 id="10-6-网络操作系统"><a href="#10-6-网络操作系统" class="headerlink" title="10.6 网络操作系统"></a>10.6 网络操作系统</h2><h2 id="10-7-分布式文件系统"><a href="#10-7-分布式文件系统" class="headerlink" title="10.7 分布式文件系统"></a>10.7 分布式文件系统</h2><h1 id="第十一章-多媒体操作系统"><a href="#第十一章-多媒体操作系统" class="headerlink" title="第十一章 多媒体操作系统"></a>第十一章 多媒体操作系统</h1><h2 id="11-1-多媒体系统简介"><a href="#11-1-多媒体系统简介" class="headerlink" title="11.1 多媒体系统简介"></a>11.1 多媒体系统简介</h2><h2 id="11-2-多媒体文件中的各种媒体"><a href="#11-2-多媒体文件中的各种媒体" class="headerlink" title="11.2 多媒体文件中的各种媒体"></a>11.2 多媒体文件中的各种媒体</h2><h2 id="11-3-多媒体进程管理中的问题和接纳控制"><a href="#11-3-多媒体进程管理中的问题和接纳控制" class="headerlink" title="11.3 多媒体进程管理中的问题和接纳控制"></a>11.3 多媒体进程管理中的问题和接纳控制</h2><h2 id="11-4-多媒体实时调度"><a href="#11-4-多媒体实时调度" class="headerlink" title="11.4 多媒体实时调度"></a>11.4 多媒体实时调度</h2><h2 id="11-5-媒体服务器的特征和接纳控制"><a href="#11-5-媒体服务器的特征和接纳控制" class="headerlink" title="11.5 媒体服务器的特征和接纳控制"></a>11.5 媒体服务器的特征和接纳控制</h2><h2 id="11-6-多媒体存储器的分配方法"><a href="#11-6-多媒体存储器的分配方法" class="headerlink" title="11.6 多媒体存储器的分配方法"></a>11.6 多媒体存储器的分配方法</h2><h2 id="11-7-高速缓存与磁盘调度"><a href="#11-7-高速缓存与磁盘调度" class="headerlink" title="11.7 高速缓存与磁盘调度"></a>11.7 高速缓存与磁盘调度</h2><h1 id="第十二章-保护与安全"><a href="#第十二章-保护与安全" class="headerlink" title="第十二章 保护与安全"></a>第十二章 保护与安全</h1><h2 id="12-1-安全环境"><a href="#12-1-安全环境" class="headerlink" title="12.1 安全环境"></a>12.1 安全环境</h2><h2 id="12-2-数据加密技术"><a href="#12-2-数据加密技术" class="headerlink" title="12.2 数据加密技术"></a>12.2 数据加密技术</h2><h2 id="12-3-用户验证"><a href="#12-3-用户验证" class="headerlink" title="12.3 用户验证"></a>12.3 用户验证</h2><h2 id="12-4-来自系统内部的攻击"><a href="#12-4-来自系统内部的攻击" class="headerlink" title="12.4 来自系统内部的攻击"></a>12.4 来自系统内部的攻击</h2><h2 id="12-5-来自系统外部的攻击"><a href="#12-5-来自系统外部的攻击" class="headerlink" title="12.5 来自系统外部的攻击"></a>12.5 来自系统外部的攻击</h2><h2 id="12-6-可信系统（Trusted-System）"><a href="#12-6-可信系统（Trusted-System）" class="headerlink" title="12.6 可信系统（Trusted System）"></a>12.6 可信系统（Trusted System）</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机类 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operation System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研408计算机思维导图知识整理</title>
      <link href="2020/12/23/%E8%80%83%E7%A0%94408%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>2020/12/23/%E8%80%83%E7%A0%94408%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="考研408计算机-思维导图-知识整理"><a href="#考研408计算机-思维导图-知识整理" class="headerlink" title="考研408计算机 思维导图 知识整理"></a>考研408计算机 思维导图 知识整理</h1><p>本章考研408计算机思维导图知识整理，408内容为计算机网络、计算机组成原理、操作系统、数据结构四类，下面是整理的学习笔记思维导图。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p><img data-src="/upload_image/20201223_comput_network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="计算机网络体系结构"></p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p><img data-src="/upload_image/20201223_comput_network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.%E7%89%A9%E7%90%86%E5%B1%82.png" alt="物理层"></p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p><img data-src="/upload_image/20201223_comput_network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.png" alt="数据链路层"></p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p><img data-src="/upload_image/20201223_comput_network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.%E7%BD%91%E7%BB%9C%E5%B1%82.png" alt="网络层"></p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p><img data-src="/upload_image/20201223_comput_network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.%E4%BC%A0%E8%BE%93%E5%B1%82.png" alt="传输层"></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><img data-src="/upload_image/20201223_comput_network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6.%E5%BA%94%E7%94%A8%E5%B1%82.png" alt="应用层"></p><h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><h3 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h3><p><img data-src="/upload_image/20201223_comput_network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.png" alt="计算机系统概述"></p><h3 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h3><p><img data-src="/upload_image/20201223_comput_network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97.png" alt="数据的表示和运算"></p><h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><p><img data-src="/upload_image/20201223_comput_network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.png" alt="存储系统"></p><h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><p><img data-src="/upload_image/20201223_comput_network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.png" alt="指令系统"></p><h3 id="中央处理器【CPU】"><a href="#中央处理器【CPU】" class="headerlink" title="中央处理器【CPU】"></a>中央处理器【CPU】</h3><p><img data-src="/upload_image/20201223_comput_network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8%E3%80%90CPU%E3%80%91.png" alt="中央处理器【CPU】"></p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p><img data-src="/upload_image/20201223_comput_network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.%E6%80%BB%E7%BA%BF.png" alt="总线"></p><h3 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h3><p><img data-src="/upload_image/20201223_comput_network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F.png" alt="输入输出系统"></p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="输入输出系统-1"><a href="#输入输出系统-1" class="headerlink" title="输入输出系统"></a>输入输出系统</h3><p><img data-src="/upload_image/20201223_comput_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA.png" alt="操作系统概论"></p><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p><img data-src="/upload_image/20201223_comput_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.png" alt="进程和线程"></p><h3 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h3><p><img data-src="/upload_image/20201223_comput_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6.png" alt="处理机调度"></p><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p><img data-src="/upload_image/20201223_comput_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4.%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5.png" alt="进程同步"></p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><img data-src="/upload_image/20201223_comput_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5.%E6%AD%BB%E9%94%81.png" alt="死锁"></p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p><img data-src="/upload_image/20201223_comput_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png" alt="内存管理"></p><h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><p><img data-src="/upload_image/20201223_comput_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png" alt="虚拟内存管理"></p><h3 id="文件管理1"><a href="#文件管理1" class="headerlink" title="文件管理1"></a>文件管理1</h3><p><img data-src="/upload_image/20201223_comput_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.png" alt="文件管理1"></p><h3 id="文件管理2"><a href="#文件管理2" class="headerlink" title="文件管理2"></a>文件管理2</h3><p><img data-src="/upload_image/20201223_comput_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.png" alt="文件管理2"></p><h3 id="文件管理3"><a href="#文件管理3" class="headerlink" title="文件管理3"></a>文件管理3</h3><p><img data-src="/upload_image/20201223_comput_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.png" alt="文件管理3"></p><h3 id="I-O管理"><a href="#I-O管理" class="headerlink" title="I/O管理"></a>I/O管理</h3><p><img data-src="/upload_image/20201223_comput_network/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.IO%E7%AE%A1%E7%90%86.png" alt="I/O管理"></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><img data-src="/upload_image/20201223_comput_network/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%9F%A5%E6%89%BE.png" alt="查找"></p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><img data-src="/upload_image/20201223_comput_network/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E6%8E%92%E5%BA%8F.png" alt="排序"></p><h3 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h3><p><img data-src="/upload_image/20201223_comput_network/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="树与二叉树"></p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p><img data-src="/upload_image/20201223_comput_network/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E5%9B%BE.png" alt="图"></p><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p><img data-src="/upload_image/20201223_comput_network/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E7%BA%BF%E6%80%A7%E8%A1%A8.png" alt="线性表"></p><h3 id="数据结构（总）"><a href="#数据结构（总）" class="headerlink" title="数据结构（总）"></a>数据结构（总）</h3><p><img data-src="/upload_image/20201223_comput_network/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%80%BB%EF%BC%89.png" alt="数据结构（总）"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机类 </category>
          
          <category> 思维导图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《TCP/IP详解（卷1：协议）》全书知识梳理</title>
      <link href="2020/12/06/TCP-IP%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE%EF%BC%89/"/>
      <url>2020/12/06/TCP-IP%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="《TCP-IP详解（卷1：协议）》全书知识梳理"><a href="#《TCP-IP详解（卷1：协议）》全书知识梳理" class="headerlink" title="《TCP/IP详解（卷1：协议）》全书知识梳理"></a>《TCP/IP详解（卷1：协议）》全书知识梳理</h1><p>本章笔记《TCP/IP详解（卷1：协议）》全书知识梳理为TCP/IP详解（卷1：协议）个人学习笔记，目录结构采用顺序排列。</p><h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h1><h2 id="1-1-体系结构原则"><a href="#1-1-体系结构原则" class="headerlink" title="1.1 体系结构原则"></a>1.1 体系结构原则</h2><h3 id="1-1-1-分组、连接和数据报"><a href="#1-1-1-分组、连接和数据报" class="headerlink" title="1.1.1 分组、连接和数据报"></a>1.1.1 分组、连接和数据报</h3><h3 id="1-1-2-端到端论点和命运分享"><a href="#1-1-2-端到端论点和命运分享" class="headerlink" title="1.1.2 端到端论点和命运分享"></a>1.1.2 端到端论点和命运分享</h3><h3 id="1-1-3-差错控制和流量控制"><a href="#1-1-3-差错控制和流量控制" class="headerlink" title="1.1.3 差错控制和流量控制"></a>1.1.3 差错控制和流量控制</h3><h2 id="1-2-设计和实现"><a href="#1-2-设计和实现" class="headerlink" title="1.2 设计和实现"></a>1.2 设计和实现</h2><h3 id="1-2-1-分层"><a href="#1-2-1-分层" class="headerlink" title="1.2.1 分层"></a>1.2.1 分层</h3><h3 id="1-2-2-分层实现中的复用、分解和封装"><a href="#1-2-2-分层实现中的复用、分解和封装" class="headerlink" title="1.2.2 分层实现中的复用、分解和封装"></a>1.2.2 分层实现中的复用、分解和封装</h3><h2 id="1-3-TCP-IP协议族结构和协议"><a href="#1-3-TCP-IP协议族结构和协议" class="headerlink" title="1.3 TCP/IP协议族结构和协议"></a>1.3 TCP/IP协议族结构和协议</h2><h3 id="1-3-1-ARPANET参考模型"><a href="#1-3-1-ARPANET参考模型" class="headerlink" title="1.3.1 ARPANET参考模型"></a>1.3.1 ARPANET参考模型</h3><h3 id="1-3-2-TCP-IP中的复用、分解和封装"><a href="#1-3-2-TCP-IP中的复用、分解和封装" class="headerlink" title="1.3.2 TCP/IP中的复用、分解和封装"></a>1.3.2 TCP/IP中的复用、分解和封装</h3><h3 id="1-3-3-端口号"><a href="#1-3-3-端口号" class="headerlink" title="1.3.3 端口号"></a>1.3.3 端口号</h3><h3 id="1-3-4-名称、地址和DNS"><a href="#1-3-4-名称、地址和DNS" class="headerlink" title="1.3.4 名称、地址和DNS"></a>1.3.4 名称、地址和DNS</h3><h2 id="1-4-Internet、内联网和外联网"><a href="#1-4-Internet、内联网和外联网" class="headerlink" title="1.4 Internet、内联网和外联网"></a>1.4 Internet、内联网和外联网</h2><h2 id="1-5-设计应用"><a href="#1-5-设计应用" class="headerlink" title="1.5 设计应用"></a>1.5 设计应用</h2><h3 id="1-5-1-客户机-服务器"><a href="#1-5-1-客户机-服务器" class="headerlink" title="1.5.1 客户机/服务器"></a>1.5.1 客户机/服务器</h3><h3 id="1-5-2-对等"><a href="#1-5-2-对等" class="headerlink" title="1.5.2 对等"></a>1.5.2 对等</h3><h3 id="1-5-3-应用程序编程接口"><a href="#1-5-3-应用程序编程接口" class="headerlink" title="1.5.3 应用程序编程接口"></a>1.5.3 应用程序编程接口</h3><h2 id="1-6-标准化进程"><a href="#1-6-标准化进程" class="headerlink" title="1.6 标准化进程"></a>1.6 标准化进程</h2><h3 id="1-6-1-RFC"><a href="#1-6-1-RFC" class="headerlink" title="1.6.1 RFC"></a>1.6.1 RFC</h3><h3 id="1-6-2-其他标准"><a href="#1-6-2-其他标准" class="headerlink" title="1.6.2 其他标准"></a>1.6.2 其他标准</h3><h2 id="1-7-实现和软件分发"><a href="#1-7-实现和软件分发" class="headerlink" title="1.7 实现和软件分发"></a>1.7 实现和软件分发</h2><h2 id="1-8-与Internet体系结构相关的攻击"><a href="#1-8-与Internet体系结构相关的攻击" class="headerlink" title="1.8 与Internet体系结构相关的攻击"></a>1.8 与Internet体系结构相关的攻击</h2><h2 id="1-9-总结"><a href="#1-9-总结" class="headerlink" title="1.9 总结"></a>1.9 总结</h2><h2 id="1-10-参考文献"><a href="#1-10-参考文献" class="headerlink" title="1.10 参考文献"></a>1.10 参考文献</h2><h1 id="第二章-Internet地址结构"><a href="#第二章-Internet地址结构" class="headerlink" title="第二章 Internet地址结构"></a>第二章 Internet地址结构</h1><h2 id="2-1-引言"><a href="#2-1-引言" class="headerlink" title="2.1 引言"></a>2.1 引言</h2><h2 id="2-2-表示IP地址"><a href="#2-2-表示IP地址" class="headerlink" title="2.2 表示IP地址"></a>2.2 表示IP地址</h2><h2 id="2-3-基本的IP地址结构"><a href="#2-3-基本的IP地址结构" class="headerlink" title="2.3 基本的IP地址结构"></a>2.3 基本的IP地址结构</h2><h3 id="2-3-1-分类寻址"><a href="#2-3-1-分类寻址" class="headerlink" title="2.3.1 分类寻址"></a>2.3.1 分类寻址</h3><h3 id="2-3-2-子网寻址"><a href="#2-3-2-子网寻址" class="headerlink" title="2.3.2 子网寻址"></a>2.3.2 子网寻址</h3><h3 id="2-3-3-子网掩码"><a href="#2-3-3-子网掩码" class="headerlink" title="2.3.3 子网掩码"></a>2.3.3 子网掩码</h3><h3 id="2-3-4-可变长度子网掩码"><a href="#2-3-4-可变长度子网掩码" class="headerlink" title="2.3.4 可变长度子网掩码"></a>2.3.4 可变长度子网掩码</h3><h3 id="2-3-5-广播地址"><a href="#2-3-5-广播地址" class="headerlink" title="2.3.5 广播地址"></a>2.3.5 广播地址</h3><h3 id="2-3-6-IPv6-地址的接口标识符"><a href="#2-3-6-IPv6-地址的接口标识符" class="headerlink" title="2.3.6 IPv6 地址的接口标识符"></a>2.3.6 IPv6 地址的接口标识符</h3><h2 id="2-4-CIDR和聚合"><a href="#2-4-CIDR和聚合" class="headerlink" title="2.4 CIDR和聚合"></a>2.4 CIDR和聚合</h2><h3 id="2-4-1-前缀"><a href="#2-4-1-前缀" class="headerlink" title="2.4.1 前缀"></a>2.4.1 前缀</h3><h3 id="2-4-2-聚合"><a href="#2-4-2-聚合" class="headerlink" title="2.4.2 聚合"></a>2.4.2 聚合</h3><h2 id="2-5-特殊用途地址"><a href="#2-5-特殊用途地址" class="headerlink" title="2.5 特殊用途地址"></a>2.5 特殊用途地址</h2><h3 id="2-5-1-IPv4-IPv6地址转换"><a href="#2-5-1-IPv4-IPv6地址转换" class="headerlink" title="2.5.1 IPv4/IPv6地址转换"></a>2.5.1 IPv4/IPv6地址转换</h3><h3 id="2-5-2-组播地址"><a href="#2-5-2-组播地址" class="headerlink" title="2.5.2 组播地址"></a>2.5.2 组播地址</h3><h3 id="2-5-3-IPv4组播地址"><a href="#2-5-3-IPv4组播地址" class="headerlink" title="2.5.3 IPv4组播地址"></a>2.5.3 IPv4组播地址</h3><h3 id="2-5-4-IPv6组播地址"><a href="#2-5-4-IPv6组播地址" class="headerlink" title="2.5.4 IPv6组播地址"></a>2.5.4 IPv6组播地址</h3><h3 id="2-5-5-任播地址"><a href="#2-5-5-任播地址" class="headerlink" title="2.5.5 任播地址"></a>2.5.5 任播地址</h3><h2 id="2-6-分配"><a href="#2-6-分配" class="headerlink" title="2.6 分配"></a>2.6 分配</h2><h3 id="2-6-1-单播"><a href="#2-6-1-单播" class="headerlink" title="2.6.1 单播"></a>2.6.1 单播</h3><h3 id="2-6-2-组播"><a href="#2-6-2-组播" class="headerlink" title="2.6.2 组播"></a>2.6.2 组播</h3><h2 id="2-7-单播地址分配"><a href="#2-7-单播地址分配" class="headerlink" title="2.7 单播地址分配"></a>2.7 单播地址分配</h2><h3 id="2-7-1-单个供应商-无网络-单个地址"><a href="#2-7-1-单个供应商-无网络-单个地址" class="headerlink" title="2.7.1 单个供应商/无网络/单个地址"></a>2.7.1 单个供应商/无网络/单个地址</h3><h3 id="2-7-2-单个供应商-单个网络-单个地址"><a href="#2-7-2-单个供应商-单个网络-单个地址" class="headerlink" title="2.7.2 单个供应商/单个网络/单个地址"></a>2.7.2 单个供应商/单个网络/单个地址</h3><h3 id="2-7-3-单个供应商-多个网络-多个地址"><a href="#2-7-3-单个供应商-多个网络-多个地址" class="headerlink" title="2.7.3 单个供应商/多个网络/多个地址"></a>2.7.3 单个供应商/多个网络/多个地址</h3><h3 id="2-7-4-多个供应商-多个网络-多个地址（多宿主）"><a href="#2-7-4-多个供应商-多个网络-多个地址（多宿主）" class="headerlink" title="2.7.4 多个供应商/多个网络/多个地址（多宿主）"></a>2.7.4 多个供应商/多个网络/多个地址（多宿主）</h3><h2 id="2-8-与IP地址相关的攻击"><a href="#2-8-与IP地址相关的攻击" class="headerlink" title="2.8 与IP地址相关的攻击"></a>2.8 与IP地址相关的攻击</h2><h2 id="2-9-总结"><a href="#2-9-总结" class="headerlink" title="2.9 总结"></a>2.9 总结</h2><h2 id="2-10-参考文献"><a href="#2-10-参考文献" class="headerlink" title="2.10 参考文献"></a>2.10 参考文献</h2><h1 id="第三章-链路层"><a href="#第三章-链路层" class="headerlink" title="第三章 链路层"></a>第三章 链路层</h1><h2 id="3-1-引言"><a href="#3-1-引言" class="headerlink" title="3.1 引言"></a>3.1 引言</h2><h2 id="3-2-以太网和IEEE-802局域网-城域网标准"><a href="#3-2-以太网和IEEE-802局域网-城域网标准" class="headerlink" title="3.2 以太网和IEEE 802局域网/城域网标准"></a>3.2 以太网和IEEE 802局域网/城域网标准</h2><h3 id="3-2-1-IEEE-802局域网-城域网标准"><a href="#3-2-1-IEEE-802局域网-城域网标准" class="headerlink" title="3.2.1 IEEE 802局域网/城域网标准"></a>3.2.1 IEEE 802局域网/城域网标准</h3><h3 id="3-2-2-以太网帧格式"><a href="#3-2-2-以太网帧格式" class="headerlink" title="3.2.2 以太网帧格式"></a>3.2.2 以太网帧格式</h3><h3 id="3-2-3-802-1p-q：虚拟局域网和QoS标签"><a href="#3-2-3-802-1p-q：虚拟局域网和QoS标签" class="headerlink" title="3.2.3 802.1p/q：虚拟局域网和QoS标签"></a>3.2.3 802.1p/q：虚拟局域网和QoS标签</h3><h3 id="3-2-4-802-1AX：链路聚合（以前的802-3ad）"><a href="#3-2-4-802-1AX：链路聚合（以前的802-3ad）" class="headerlink" title="3.2.4 802.1AX：链路聚合（以前的802.3ad）"></a>3.2.4 802.1AX：链路聚合（以前的802.3ad）</h3><h2 id="3-3-全双工、省电、自动协商和802-1X流量控制"><a href="#3-3-全双工、省电、自动协商和802-1X流量控制" class="headerlink" title="3.3 全双工、省电、自动协商和802.1X流量控制"></a>3.3 全双工、省电、自动协商和802.1X流量控制</h2><h3 id="3-3-1-双工不匹配"><a href="#3-3-1-双工不匹配" class="headerlink" title="3.3.1 双工不匹配"></a>3.3.1 双工不匹配</h3><h3 id="3-3-2-局域网唤醒（WoL）、省电和魔术分组"><a href="#3-3-2-局域网唤醒（WoL）、省电和魔术分组" class="headerlink" title="3.3.2 局域网唤醒（WoL）、省电和魔术分组"></a>3.3.2 局域网唤醒（WoL）、省电和魔术分组</h3><h3 id="3-3-3-链路层流量控制"><a href="#3-3-3-链路层流量控制" class="headerlink" title="3.3.3 链路层流量控制"></a>3.3.3 链路层流量控制</h3><h2 id="3-4-网桥和交换机"><a href="#3-4-网桥和交换机" class="headerlink" title="3.4 网桥和交换机"></a>3.4 网桥和交换机</h2><h3 id="3-4-1-生成树协议"><a href="#3-4-1-生成树协议" class="headerlink" title="3.4.1 生成树协议"></a>3.4.1 生成树协议</h3><h3 id="3-4-2-802-1ak：多注册协议"><a href="#3-4-2-802-1ak：多注册协议" class="headerlink" title="3.4.2 802.1ak：多注册协议"></a>3.4.2 802.1ak：多注册协议</h3><h2 id="3-5-无线局域网—IEEE-802-11（Wi-Fi）"><a href="#3-5-无线局域网—IEEE-802-11（Wi-Fi）" class="headerlink" title="3.5 无线局域网—IEEE 802.11（Wi-Fi）"></a>3.5 无线局域网—IEEE 802.11（Wi-Fi）</h2><h3 id="3-5-1-802-11帧"><a href="#3-5-1-802-11帧" class="headerlink" title="3.5.1 802.11帧"></a>3.5.1 802.11帧</h3><h3 id="3-5-2-省电模式和时间同步功能"><a href="#3-5-2-省电模式和时间同步功能" class="headerlink" title="3.5.2 省电模式和时间同步功能"></a>3.5.2 省电模式和时间同步功能</h3><h3 id="3-5-3-802-11-介质访问控制"><a href="#3-5-3-802-11-介质访问控制" class="headerlink" title="3.5.3 802.11 介质访问控制"></a>3.5.3 802.11 介质访问控制</h3><h3 id="3-5-4-物理层的细节：速率、信道和频率"><a href="#3-5-4-物理层的细节：速率、信道和频率" class="headerlink" title="3.5.4 物理层的细节：速率、信道和频率"></a>3.5.4 物理层的细节：速率、信道和频率</h3><h3 id="3-5-5-Wi-Fi安全"><a href="#3-5-5-Wi-Fi安全" class="headerlink" title="3.5.5 Wi-Fi安全"></a>3.5.5 Wi-Fi安全</h3><h3 id="3-5-6-Wi-Fi网状网（802-11s）"><a href="#3-5-6-Wi-Fi网状网（802-11s）" class="headerlink" title="3.5.6 Wi-Fi网状网（802.11s）"></a>3.5.6 Wi-Fi网状网（802.11s）</h3><h2 id="3-6-点到点协议"><a href="#3-6-点到点协议" class="headerlink" title="3.6 点到点协议"></a>3.6 点到点协议</h2><h3 id="3-6-1-链路控制协议"><a href="#3-6-1-链路控制协议" class="headerlink" title="3.6.1 链路控制协议"></a>3.6.1 链路控制协议</h3><h3 id="3-6-2-多链路PPP"><a href="#3-6-2-多链路PPP" class="headerlink" title="3.6.2 多链路PPP"></a>3.6.2 多链路PPP</h3><h3 id="3-6-3-压缩控制协议"><a href="#3-6-3-压缩控制协议" class="headerlink" title="3.6.3 压缩控制协议"></a>3.6.3 压缩控制协议</h3><h3 id="3-6-4-PPP认证"><a href="#3-6-4-PPP认证" class="headerlink" title="3.6.4 PPP认证"></a>3.6.4 PPP认证</h3><h3 id="3-6-5-网络控制协议"><a href="#3-6-5-网络控制协议" class="headerlink" title="3.6.5 网络控制协议"></a>3.6.5 网络控制协议</h3><h3 id="3-6-6-头部压缩"><a href="#3-6-6-头部压缩" class="headerlink" title="3.6.6 头部压缩"></a>3.6.6 头部压缩</h3><h3 id="3-6-7-例子"><a href="#3-6-7-例子" class="headerlink" title="3.6.7 例子"></a>3.6.7 例子</h3><h2 id="3-7-环回"><a href="#3-7-环回" class="headerlink" title="3.7 环回"></a>3.7 环回</h2><h2 id="3-8-MTU和路径MTU"><a href="#3-8-MTU和路径MTU" class="headerlink" title="3.8 MTU和路径MTU"></a>3.8 MTU和路径MTU</h2><h2 id="3-9-隧道基础"><a href="#3-9-隧道基础" class="headerlink" title="3.9 隧道基础"></a>3.9 隧道基础</h2><h3 id="3-9-1-单项链路"><a href="#3-9-1-单项链路" class="headerlink" title="3.9.1 单项链路"></a>3.9.1 单项链路</h3><h2 id="3-10-与链路层相关的攻击"><a href="#3-10-与链路层相关的攻击" class="headerlink" title="3.10 与链路层相关的攻击"></a>3.10 与链路层相关的攻击</h2><h2 id="3-11-总结"><a href="#3-11-总结" class="headerlink" title="3.11 总结"></a>3.11 总结</h2><h2 id="3-12-参考文献"><a href="#3-12-参考文献" class="headerlink" title="3.12 参考文献"></a>3.12 参考文献</h2><h1 id="第四章-地址解析协议"><a href="#第四章-地址解析协议" class="headerlink" title="第四章 地址解析协议"></a>第四章 地址解析协议</h1><h2 id="4-1-引言"><a href="#4-1-引言" class="headerlink" title="4.1 引言"></a>4.1 引言</h2><h2 id="4-2-一个例子"><a href="#4-2-一个例子" class="headerlink" title="4.2 一个例子"></a>4.2 一个例子</h2><h3 id="4-2-1-直接交付和ARP"><a href="#4-2-1-直接交付和ARP" class="headerlink" title="4.2.1 直接交付和ARP"></a>4.2.1 直接交付和ARP</h3><h2 id="4-3-ARP缓存"><a href="#4-3-ARP缓存" class="headerlink" title="4.3 ARP缓存"></a>4.3 ARP缓存</h2><h2 id="4-4-ARP帧格式"><a href="#4-4-ARP帧格式" class="headerlink" title="4.4 ARP帧格式"></a>4.4 ARP帧格式</h2><h2 id="4-5-ARP例子"><a href="#4-5-ARP例子" class="headerlink" title="4.5 ARP例子"></a>4.5 ARP例子</h2><h3 id="4-5-1-正常的例子"><a href="#4-5-1-正常的例子" class="headerlink" title="4.5.1 正常的例子"></a>4.5.1 正常的例子</h3><h3 id="4-5-2-对一个不存在主机的ARP请求"><a href="#4-5-2-对一个不存在主机的ARP请求" class="headerlink" title="4.5.2 对一个不存在主机的ARP请求"></a>4.5.2 对一个不存在主机的ARP请求</h3><h2 id="4-6-ARP缓存超时"><a href="#4-6-ARP缓存超时" class="headerlink" title="4.6 ARP缓存超时"></a>4.6 ARP缓存超时</h2><h2 id="4-7-代理ARP"><a href="#4-7-代理ARP" class="headerlink" title="4.7 代理ARP"></a>4.7 代理ARP</h2><h2 id="4-8-免费ARP和地址冲突检测"><a href="#4-8-免费ARP和地址冲突检测" class="headerlink" title="4.8 免费ARP和地址冲突检测"></a>4.8 免费ARP和地址冲突检测</h2><h2 id="4-9-arp命令"><a href="#4-9-arp命令" class="headerlink" title="4.9 arp命令"></a>4.9 arp命令</h2><h2 id="4-10-使用ARP设置一台嵌入式设备的IPv4地址"><a href="#4-10-使用ARP设置一台嵌入式设备的IPv4地址" class="headerlink" title="4.10 使用ARP设置一台嵌入式设备的IPv4地址"></a>4.10 使用ARP设置一台嵌入式设备的IPv4地址</h2><h2 id="4-11-与ARP相关的攻击"><a href="#4-11-与ARP相关的攻击" class="headerlink" title="4.11 与ARP相关的攻击"></a>4.11 与ARP相关的攻击</h2><h2 id="4-12-总结"><a href="#4-12-总结" class="headerlink" title="4.12 总结"></a>4.12 总结</h2><h2 id="4-13-参考文献"><a href="#4-13-参考文献" class="headerlink" title="4.13 参考文献"></a>4.13 参考文献</h2><h1 id="第五章-Internet协议"><a href="#第五章-Internet协议" class="headerlink" title="第五章 Internet协议"></a>第五章 Internet协议</h1><h2 id="5-1-引言"><a href="#5-1-引言" class="headerlink" title="5.1 引言"></a>5.1 引言</h2><h2 id="5-2-IPv4头部和IPv6头部"><a href="#5-2-IPv4头部和IPv6头部" class="headerlink" title="5.2 IPv4头部和IPv6头部"></a>5.2 IPv4头部和IPv6头部</h2><h3 id="5-2-1-IP头部字段"><a href="#5-2-1-IP头部字段" class="headerlink" title="5.2.1 IP头部字段"></a>5.2.1 IP头部字段</h3><h3 id="5-2-2-Internet校验和"><a href="#5-2-2-Internet校验和" class="headerlink" title="5.2.2 Internet校验和"></a>5.2.2 Internet校验和</h3><h3 id="5-2-3-DS字段和ECN（以前称为ToS字节或IPv6流量类别）"><a href="#5-2-3-DS字段和ECN（以前称为ToS字节或IPv6流量类别）" class="headerlink" title="5.2.3 DS字段和ECN（以前称为ToS字节或IPv6流量类别）"></a>5.2.3 DS字段和ECN（以前称为ToS字节或IPv6流量类别）</h3><h3 id="5-2-4-IP选项"><a href="#5-2-4-IP选项" class="headerlink" title="5.2.4 IP选项"></a>5.2.4 IP选项</h3><h2 id="5-3-IPv6扩展头部"><a href="#5-3-IPv6扩展头部" class="headerlink" title="5.3 IPv6扩展头部"></a>5.3 IPv6扩展头部</h2><h3 id="5-3-1-IPv6选项"><a href="#5-3-1-IPv6选项" class="headerlink" title="5.3.1 IPv6选项"></a>5.3.1 IPv6选项</h3><h3 id="5-3-2-路由头部"><a href="#5-3-2-路由头部" class="headerlink" title="5.3.2 路由头部"></a>5.3.2 路由头部</h3><h3 id="5-3-3-分片头部"><a href="#5-3-3-分片头部" class="headerlink" title="5.3.3 分片头部"></a>5.3.3 分片头部</h3><h2 id="5-4-IP转发"><a href="#5-4-IP转发" class="headerlink" title="5.4 IP转发"></a>5.4 IP转发</h2><h3 id="5-4-1-转发表"><a href="#5-4-1-转发表" class="headerlink" title="5.4.1 转发表"></a>5.4.1 转发表</h3><h3 id="5-4-2-IP转发行动"><a href="#5-4-2-IP转发行动" class="headerlink" title="5.4.2 IP转发行动"></a>5.4.2 IP转发行动</h3><h3 id="5-4-3-例子"><a href="#5-4-3-例子" class="headerlink" title="5.4.3 例子"></a>5.4.3 例子</h3><h3 id="5-4-4-讨论"><a href="#5-4-4-讨论" class="headerlink" title="5.4.4 讨论"></a>5.4.4 讨论</h3><h2 id="5-5-移动IP"><a href="#5-5-移动IP" class="headerlink" title="5.5 移动IP"></a>5.5 移动IP</h2><h3 id="5-5-1-基本模型：双向隧道"><a href="#5-5-1-基本模型：双向隧道" class="headerlink" title="5.5.1 基本模型：双向隧道"></a>5.5.1 基本模型：双向隧道</h3><h3 id="5-5-2-路由优化"><a href="#5-5-2-路由优化" class="headerlink" title="5.5.2 路由优化"></a>5.5.2 路由优化</h3><h3 id="5-5-3-讨论"><a href="#5-5-3-讨论" class="headerlink" title="5.5.3 讨论"></a>5.5.3 讨论</h3><h2 id="5-6-IP数据报的主机处理"><a href="#5-6-IP数据报的主机处理" class="headerlink" title="5.6 IP数据报的主机处理"></a>5.6 IP数据报的主机处理</h2><h3 id="5-6-1-主机模式"><a href="#5-6-1-主机模式" class="headerlink" title="5.6.1 主机模式"></a>5.6.1 主机模式</h3><h3 id="5-6-2-地址选择"><a href="#5-6-2-地址选择" class="headerlink" title="5.6.2 地址选择"></a>5.6.2 地址选择</h3><h2 id="5-7-与IP相关的攻击"><a href="#5-7-与IP相关的攻击" class="headerlink" title="5.7 与IP相关的攻击"></a>5.7 与IP相关的攻击</h2><h2 id="5-8-总结"><a href="#5-8-总结" class="headerlink" title="5.8 总结"></a>5.8 总结</h2><h2 id="5-9-参考文献"><a href="#5-9-参考文献" class="headerlink" title="5.9 参考文献"></a>5.9 参考文献</h2><h1 id="第六章-系统配置：DHCP和自动配置"><a href="#第六章-系统配置：DHCP和自动配置" class="headerlink" title="第六章 系统配置：DHCP和自动配置"></a>第六章 系统配置：DHCP和自动配置</h1><h2 id="6-1-引言"><a href="#6-1-引言" class="headerlink" title="6.1 引言"></a>6.1 引言</h2><h2 id="6-2-动态主机配置协议"><a href="#6-2-动态主机配置协议" class="headerlink" title="6.2 动态主机配置协议"></a>6.2 动态主机配置协议</h2><h3 id="6-2-1-地址池和租用"><a href="#6-2-1-地址池和租用" class="headerlink" title="6.2.1 地址池和租用"></a>6.2.1 地址池和租用</h3><h3 id="6-2-2-DHCP和BOOTP消息格式"><a href="#6-2-2-DHCP和BOOTP消息格式" class="headerlink" title="6.2.2 DHCP和BOOTP消息格式"></a>6.2.2 DHCP和BOOTP消息格式</h3><h3 id="6-2-3-DHCP和BOOTP选项"><a href="#6-2-3-DHCP和BOOTP选项" class="headerlink" title="6.2.3 DHCP和BOOTP选项"></a>6.2.3 DHCP和BOOTP选项</h3><h3 id="6-2-4-DHCP协议操作"><a href="#6-2-4-DHCP协议操作" class="headerlink" title="6.2.4 DHCP协议操作"></a>6.2.4 DHCP协议操作</h3><h3 id="6-2-5-DHCPv6"><a href="#6-2-5-DHCPv6" class="headerlink" title="6.2.5 DHCPv6"></a>6.2.5 DHCPv6</h3><h3 id="6-2-6-使用DHCP中继"><a href="#6-2-6-使用DHCP中继" class="headerlink" title="6.2.6 使用DHCP中继"></a>6.2.6 使用DHCP中继</h3><h3 id="6-2-7-DHCP认证"><a href="#6-2-7-DHCP认证" class="headerlink" title="6.2.7 DHCP认证"></a>6.2.7 DHCP认证</h3><h3 id="6-2-8-重新配置扩展"><a href="#6-2-8-重新配置扩展" class="headerlink" title="6.2.8 重新配置扩展"></a>6.2.8 重新配置扩展</h3><h3 id="6-2-9-快速确认"><a href="#6-2-9-快速确认" class="headerlink" title="6.2.9 快速确认"></a>6.2.9 快速确认</h3><h3 id="6-2-10-位置信息（LCI和LoST）"><a href="#6-2-10-位置信息（LCI和LoST）" class="headerlink" title="6.2.10 位置信息（LCI和LoST）"></a>6.2.10 位置信息（LCI和LoST）</h3><h3 id="6-2-11-移动和切换信息（MoS和ANDSF）"><a href="#6-2-11-移动和切换信息（MoS和ANDSF）" class="headerlink" title="6.2.11 移动和切换信息（MoS和ANDSF）"></a>6.2.11 移动和切换信息（MoS和ANDSF）</h3><h3 id="6-2-12-DHCP嗅探"><a href="#6-2-12-DHCP嗅探" class="headerlink" title="6.2.12 DHCP嗅探"></a>6.2.12 DHCP嗅探</h3><h2 id="6-3-无状态地址自动配置"><a href="#6-3-无状态地址自动配置" class="headerlink" title="6.3 无状态地址自动配置"></a>6.3 无状态地址自动配置</h2><h3 id="6-3-1-IPv4链路本地地址的动态配置"><a href="#6-3-1-IPv4链路本地地址的动态配置" class="headerlink" title="6.3.1 IPv4链路本地地址的动态配置"></a>6.3.1 IPv4链路本地地址的动态配置</h3><h3 id="6-3-2-链路本地地址的IPv6-SLAAC"><a href="#6-3-2-链路本地地址的IPv6-SLAAC" class="headerlink" title="6.3.2 链路本地地址的IPv6 SLAAC"></a>6.3.2 链路本地地址的IPv6 SLAAC</h3><h2 id="6-4-DHCP和DNS交互"><a href="#6-4-DHCP和DNS交互" class="headerlink" title="6.4 DHCP和DNS交互"></a>6.4 DHCP和DNS交互</h2><h2 id="6-5-以太网上的PPP"><a href="#6-5-以太网上的PPP" class="headerlink" title="6.5 以太网上的PPP"></a>6.5 以太网上的PPP</h2><h2 id="6-6-与系统配置相关的攻击"><a href="#6-6-与系统配置相关的攻击" class="headerlink" title="6.6 与系统配置相关的攻击"></a>6.6 与系统配置相关的攻击</h2><h2 id="6-7-总结"><a href="#6-7-总结" class="headerlink" title="6.7 总结"></a>6.7 总结</h2><h2 id="6-8-参考文献"><a href="#6-8-参考文献" class="headerlink" title="6.8 参考文献"></a>6.8 参考文献</h2><h1 id="第七章-防火墙和网络地址转换"><a href="#第七章-防火墙和网络地址转换" class="headerlink" title="第七章 防火墙和网络地址转换"></a>第七章 防火墙和网络地址转换</h1><h2 id="7-1-引言"><a href="#7-1-引言" class="headerlink" title="7.1 引言"></a>7.1 引言</h2><h2 id="7-2-防火墙"><a href="#7-2-防火墙" class="headerlink" title="7.2 防火墙"></a>7.2 防火墙</h2><h3 id="7-2-1-包过滤防火墙"><a href="#7-2-1-包过滤防火墙" class="headerlink" title="7.2.1 包过滤防火墙"></a>7.2.1 包过滤防火墙</h3><h3 id="7-2-2-代理防火墙"><a href="#7-2-2-代理防火墙" class="headerlink" title="7.2.2 代理防火墙"></a>7.2.2 代理防火墙</h3><h2 id="7-3-网络地址转换"><a href="#7-3-网络地址转换" class="headerlink" title="7.3 网络地址转换"></a>7.3 网络地址转换</h2><h3 id="7-3-1-传统的NAT：基本NAT和NAPT"><a href="#7-3-1-传统的NAT：基本NAT和NAPT" class="headerlink" title="7.3.1 传统的NAT：基本NAT和NAPT"></a>7.3.1 传统的NAT：基本NAT和NAPT</h3><h3 id="7-3-2-地址和端口转换行为"><a href="#7-3-2-地址和端口转换行为" class="headerlink" title="7.3.2 地址和端口转换行为"></a>7.3.2 地址和端口转换行为</h3><h3 id="7-3-3-过滤行为"><a href="#7-3-3-过滤行为" class="headerlink" title="7.3.3 过滤行为"></a>7.3.3 过滤行为</h3><h3 id="7-3-4-位于NAT之后的服务器"><a href="#7-3-4-位于NAT之后的服务器" class="headerlink" title="7.3.4 位于NAT之后的服务器"></a>7.3.4 位于NAT之后的服务器</h3><h3 id="7-3-5-发夹和NAT环回"><a href="#7-3-5-发夹和NAT环回" class="headerlink" title="7.3.5 发夹和NAT环回"></a>7.3.5 发夹和NAT环回</h3><h3 id="7-3-6-NAT编辑器"><a href="#7-3-6-NAT编辑器" class="headerlink" title="7.3.6 NAT编辑器"></a>7.3.6 NAT编辑器</h3><h3 id="7-3-7-服务提供者NAT和服务提供者IPv6转换"><a href="#7-3-7-服务提供者NAT和服务提供者IPv6转换" class="headerlink" title="7.3.7 服务提供者NAT和服务提供者IPv6转换"></a>7.3.7 服务提供者NAT和服务提供者IPv6转换</h3><h2 id="7-4-NAT穿越"><a href="#7-4-NAT穿越" class="headerlink" title="7.4 NAT穿越"></a>7.4 NAT穿越</h2><h3 id="7-4-1-针孔和打孔"><a href="#7-4-1-针孔和打孔" class="headerlink" title="7.4.1 针孔和打孔"></a>7.4.1 针孔和打孔</h3><h3 id="7-4-2-单边的自地址确定"><a href="#7-4-2-单边的自地址确定" class="headerlink" title="7.4.2 单边的自地址确定"></a>7.4.2 单边的自地址确定</h3><h3 id="7-4-3-NAT的对话穿越工具"><a href="#7-4-3-NAT的对话穿越工具" class="headerlink" title="7.4.3 NAT的对话穿越工具"></a>7.4.3 NAT的对话穿越工具</h3><h3 id="7-4-4-利用NAT中继的穿越"><a href="#7-4-4-利用NAT中继的穿越" class="headerlink" title="7.4.4 利用NAT中继的穿越"></a>7.4.4 利用NAT中继的穿越</h3><h3 id="7-4-5-交互连接建立"><a href="#7-4-5-交互连接建立" class="headerlink" title="7.4.5 交互连接建立"></a>7.4.5 交互连接建立</h3><h2 id="7-5-配置包过滤防火墙和NAT"><a href="#7-5-配置包过滤防火墙和NAT" class="headerlink" title="7.5 配置包过滤防火墙和NAT"></a>7.5 配置包过滤防火墙和NAT</h2><h3 id="7-5-1-防火墙规则"><a href="#7-5-1-防火墙规则" class="headerlink" title="7.5.1 防火墙规则"></a>7.5.1 防火墙规则</h3><h3 id="7-5-2-NAT规则"><a href="#7-5-2-NAT规则" class="headerlink" title="7.5.2 NAT规则"></a>7.5.2 NAT规则</h3><h3 id="7-5-3-与NAT和防火墙的直接交互：UPnP、NAT-PMP和PCP"><a href="#7-5-3-与NAT和防火墙的直接交互：UPnP、NAT-PMP和PCP" class="headerlink" title="7.5.3 与NAT和防火墙的直接交互：UPnP、NAT-PMP和PCP"></a>7.5.3 与NAT和防火墙的直接交互：UPnP、NAT-PMP和PCP</h3><h2 id="7-6-IPv4-IPv6共存和过渡中的NAT"><a href="#7-6-IPv4-IPv6共存和过渡中的NAT" class="headerlink" title="7.6 IPv4/IPv6共存和过渡中的NAT"></a>7.6 IPv4/IPv6共存和过渡中的NAT</h2><h3 id="7-6-1-双协议栈精简版"><a href="#7-6-1-双协议栈精简版" class="headerlink" title="7.6.1 双协议栈精简版"></a>7.6.1 双协议栈精简版</h3><h3 id="7-6-2-使用NAT和ALG的IPv4-IPv6转换"><a href="#7-6-2-使用NAT和ALG的IPv4-IPv6转换" class="headerlink" title="7.6.2 使用NAT和ALG的IPv4/IPv6转换"></a>7.6.2 使用NAT和ALG的IPv4/IPv6转换</h3><h2 id="7-7-与防火墙和NAT相关的攻击"><a href="#7-7-与防火墙和NAT相关的攻击" class="headerlink" title="7.7 与防火墙和NAT相关的攻击"></a>7.7 与防火墙和NAT相关的攻击</h2><h2 id="7-8-总结"><a href="#7-8-总结" class="headerlink" title="7.8 总结"></a>7.8 总结</h2><h2 id="7-9-参考文献"><a href="#7-9-参考文献" class="headerlink" title="7.9 参考文献"></a>7.9 参考文献</h2><h1 id="第八章-ICMPv4和ICMPv6：Internet控制报文协议"><a href="#第八章-ICMPv4和ICMPv6：Internet控制报文协议" class="headerlink" title="第八章 ICMPv4和ICMPv6：Internet控制报文协议"></a>第八章 ICMPv4和ICMPv6：Internet控制报文协议</h1><h2 id="8-1-引言"><a href="#8-1-引言" class="headerlink" title="8.1 引言"></a>8.1 引言</h2><h3 id="8-1-1-在IPv4和IPv6中的封装"><a href="#8-1-1-在IPv4和IPv6中的封装" class="headerlink" title="8.1.1 在IPv4和IPv6中的封装"></a>8.1.1 在IPv4和IPv6中的封装</h3><h2 id="8-2-ICMP报文"><a href="#8-2-ICMP报文" class="headerlink" title="8.2 ICMP报文"></a>8.2 ICMP报文</h2><h3 id="8-2-1-ICMPv4报文"><a href="#8-2-1-ICMPv4报文" class="headerlink" title="8.2.1 ICMPv4报文"></a>8.2.1 ICMPv4报文</h3><h3 id="8-2-2-ICMPv6报文"><a href="#8-2-2-ICMPv6报文" class="headerlink" title="8.2.2 ICMPv6报文"></a>8.2.2 ICMPv6报文</h3><h3 id="8-2-3-处理ICMP报文"><a href="#8-2-3-处理ICMP报文" class="headerlink" title="8.2.3 处理ICMP报文"></a>8.2.3 处理ICMP报文</h3><h2 id="8-3-ICMP差错报文"><a href="#8-3-ICMP差错报文" class="headerlink" title="8.3 ICMP差错报文"></a>8.3 ICMP差错报文</h2><h3 id="8-3-1-扩展的ICMP和多部报文"><a href="#8-3-1-扩展的ICMP和多部报文" class="headerlink" title="8.3.1 扩展的ICMP和多部报文"></a>8.3.1 扩展的ICMP和多部报文</h3><h3 id="8-3-2-目的不可达（ICMPv4类型3，ICMPv6类型1）和数据报太大（ICMPv6类型2）"><a href="#8-3-2-目的不可达（ICMPv4类型3，ICMPv6类型1）和数据报太大（ICMPv6类型2）" class="headerlink" title="8.3.2 目的不可达（ICMPv4类型3，ICMPv6类型1）和数据报太大（ICMPv6类型2）"></a>8.3.2 目的不可达（ICMPv4类型3，ICMPv6类型1）和数据报太大（ICMPv6类型2）</h3><h3 id="8-3-3-重定向（ICMPv4类型5，ICMPv6类型137）"><a href="#8-3-3-重定向（ICMPv4类型5，ICMPv6类型137）" class="headerlink" title="8.3.3 重定向（ICMPv4类型5，ICMPv6类型137）"></a>8.3.3 重定向（ICMPv4类型5，ICMPv6类型137）</h3><h3 id="8-3-4-ICMP超时（ICMPv4类型11，ICMPv6类型3）"><a href="#8-3-4-ICMP超时（ICMPv4类型11，ICMPv6类型3）" class="headerlink" title="8.3.4 ICMP超时（ICMPv4类型11，ICMPv6类型3）"></a>8.3.4 ICMP超时（ICMPv4类型11，ICMPv6类型3）</h3><h3 id="8-3-5-参数问题（ICMPv4类型12，ICMPv6类型4）"><a href="#8-3-5-参数问题（ICMPv4类型12，ICMPv6类型4）" class="headerlink" title="8.3.5 参数问题（ICMPv4类型12，ICMPv6类型4）"></a>8.3.5 参数问题（ICMPv4类型12，ICMPv6类型4）</h3><h2 id="8-4-ICMP查询-信息类报文"><a href="#8-4-ICMP查询-信息类报文" class="headerlink" title="8.4 ICMP查询/信息类报文"></a>8.4 ICMP查询/信息类报文</h2><h3 id="8-4-1-回显请求-应答（ping）（ICMPv4类型0-8，ICMPv6类型129-128）"><a href="#8-4-1-回显请求-应答（ping）（ICMPv4类型0-8，ICMPv6类型129-128）" class="headerlink" title="8.4.1 回显请求/应答（ping）（ICMPv4类型0/8，ICMPv6类型129/128）"></a>8.4.1 回显请求/应答（ping）（ICMPv4类型0/8，ICMPv6类型129/128）</h3><h3 id="8-4-2-路由器发现：路由器请求和通告（ICMPv4类型9，10）"><a href="#8-4-2-路由器发现：路由器请求和通告（ICMPv4类型9，10）" class="headerlink" title="8.4.2 路由器发现：路由器请求和通告（ICMPv4类型9，10）"></a>8.4.2 路由器发现：路由器请求和通告（ICMPv4类型9，10）</h3><h3 id="8-4-3-本地代理地址发现请求-应答（ICMPv6类型144-145）"><a href="#8-4-3-本地代理地址发现请求-应答（ICMPv6类型144-145）" class="headerlink" title="8.4.3 本地代理地址发现请求/应答（ICMPv6类型144/145）"></a>8.4.3 本地代理地址发现请求/应答（ICMPv6类型144/145）</h3><h3 id="8-4-4-移动前缀请求-通告（ICMPv6类型146-147）"><a href="#8-4-4-移动前缀请求-通告（ICMPv6类型146-147）" class="headerlink" title="8.4.4 移动前缀请求/通告（ICMPv6类型146/147）"></a>8.4.4 移动前缀请求/通告（ICMPv6类型146/147）</h3><h3 id="8-4-5-移动IPv6快速切换报文（ICMPv6类型154）"><a href="#8-4-5-移动IPv6快速切换报文（ICMPv6类型154）" class="headerlink" title="8.4.5 移动IPv6快速切换报文（ICMPv6类型154）"></a>8.4.5 移动IPv6快速切换报文（ICMPv6类型154）</h3><h3 id="8-4-6-组播侦听查询-报告-完成（ICMPv6类型130-131-132）"><a href="#8-4-6-组播侦听查询-报告-完成（ICMPv6类型130-131-132）" class="headerlink" title="8.4.6 组播侦听查询/报告/完成（ICMPv6类型130/131/132）"></a>8.4.6 组播侦听查询/报告/完成（ICMPv6类型130/131/132）</h3><h3 id="8-4-7-版本2组播侦听发现（ICMPv6类型143）"><a href="#8-4-7-版本2组播侦听发现（ICMPv6类型143）" class="headerlink" title="8.4.7 版本2组播侦听发现（ICMPv6类型143）"></a>8.4.7 版本2组播侦听发现（ICMPv6类型143）</h3><h3 id="8-4-8-组播路由器发现（IGMP类型48-49-50，ICMPv6类型151-152-153）"><a href="#8-4-8-组播路由器发现（IGMP类型48-49-50，ICMPv6类型151-152-153）" class="headerlink" title="8.4.8 组播路由器发现（IGMP类型48/49/50，ICMPv6类型151/152/153）"></a>8.4.8 组播路由器发现（IGMP类型48/49/50，ICMPv6类型151/152/153）</h3><h2 id="8-5-IPv6中的邻居发现"><a href="#8-5-IPv6中的邻居发现" class="headerlink" title="8.5 IPv6中的邻居发现"></a>8.5 IPv6中的邻居发现</h2><h3 id="8-5-1-ICMPv6路由器请求和通告（ICMPv6类型133，134）"><a href="#8-5-1-ICMPv6路由器请求和通告（ICMPv6类型133，134）" class="headerlink" title="8.5.1 ICMPv6路由器请求和通告（ICMPv6类型133，134）"></a>8.5.1 ICMPv6路由器请求和通告（ICMPv6类型133，134）</h3><h3 id="8-5-2-ICMPv6邻居请求和通告（ICMPv6类型135，136）"><a href="#8-5-2-ICMPv6邻居请求和通告（ICMPv6类型135，136）" class="headerlink" title="8.5.2 ICMPv6邻居请求和通告（ICMPv6类型135，136）"></a>8.5.2 ICMPv6邻居请求和通告（ICMPv6类型135，136）</h3><h3 id="8-5-3-ICMPv6反向邻居发现请求-通告（ICMPv6类型141-142）"><a href="#8-5-3-ICMPv6反向邻居发现请求-通告（ICMPv6类型141-142）" class="headerlink" title="8.5.3 ICMPv6反向邻居发现请求/通告（ICMPv6类型141/142）"></a>8.5.3 ICMPv6反向邻居发现请求/通告（ICMPv6类型141/142）</h3><h3 id="8-5-4-邻居不可达检测"><a href="#8-5-4-邻居不可达检测" class="headerlink" title="8.5.4 邻居不可达检测"></a>8.5.4 邻居不可达检测</h3><h3 id="8-5-5-安全邻居发现"><a href="#8-5-5-安全邻居发现" class="headerlink" title="8.5.5 安全邻居发现"></a>8.5.5 安全邻居发现</h3><h3 id="8-5-6-ICMPv6邻居发现选项"><a href="#8-5-6-ICMPv6邻居发现选项" class="headerlink" title="8.5.6 ICMPv6邻居发现选项"></a>8.5.6 ICMPv6邻居发现选项</h3><h2 id="8-6-ICMPv4和ICMPv6转换"><a href="#8-6-ICMPv4和ICMPv6转换" class="headerlink" title="8.6 ICMPv4和ICMPv6转换"></a>8.6 ICMPv4和ICMPv6转换</h2><h3 id="8-6-1-从ICMPv4转换到ICMPv6"><a href="#8-6-1-从ICMPv4转换到ICMPv6" class="headerlink" title="8.6.1 从ICMPv4转换到ICMPv6"></a>8.6.1 从ICMPv4转换到ICMPv6</h3><h3 id="8-6-2-从ICMPv6转换到ICMPv4"><a href="#8-6-2-从ICMPv6转换到ICMPv4" class="headerlink" title="8.6.2 从ICMPv6转换到ICMPv4"></a>8.6.2 从ICMPv6转换到ICMPv4</h3><h2 id="8-7-与ICMP相关的攻击"><a href="#8-7-与ICMP相关的攻击" class="headerlink" title="8.7 与ICMP相关的攻击"></a>8.7 与ICMP相关的攻击</h2><h2 id="8-8-总结"><a href="#8-8-总结" class="headerlink" title="8.8 总结"></a>8.8 总结</h2><h2 id="8-9-参考文献"><a href="#8-9-参考文献" class="headerlink" title="8.9 参考文献"></a>8.9 参考文献</h2><h1 id="第九章-广播和本地组播（IGMP和MLD）"><a href="#第九章-广播和本地组播（IGMP和MLD）" class="headerlink" title="第九章 广播和本地组播（IGMP和MLD）"></a>第九章 广播和本地组播（IGMP和MLD）</h1><h2 id="9-1-引言"><a href="#9-1-引言" class="headerlink" title="9.1 引言"></a>9.1 引言</h2><h2 id="9-2-广播"><a href="#9-2-广播" class="headerlink" title="9.2 广播"></a>9.2 广播</h2><h3 id="9-2-1-使用广播地址"><a href="#9-2-1-使用广播地址" class="headerlink" title="9.2.1 使用广播地址"></a>9.2.1 使用广播地址</h3><h3 id="9-2-2-发送广播数据报"><a href="#9-2-2-发送广播数据报" class="headerlink" title="9.2.2 发送广播数据报"></a>9.2.2 发送广播数据报</h3><h2 id="9-3-组播"><a href="#9-3-组播" class="headerlink" title="9.3 组播"></a>9.3 组播</h2><h3 id="9-3-1-将IP组播地址转换为802NAC-以太网地址"><a href="#9-3-1-将IP组播地址转换为802NAC-以太网地址" class="headerlink" title="9.3.1 将IP组播地址转换为802NAC/以太网地址"></a>9.3.1 将IP组播地址转换为802NAC/以太网地址</h3><h3 id="9-3-2-例子"><a href="#9-3-2-例子" class="headerlink" title="9.3.2 例子"></a>9.3.2 例子</h3><h3 id="9-3-3-发送组播数据报"><a href="#9-3-3-发送组播数据报" class="headerlink" title="9.3.3 发送组播数据报"></a>9.3.3 发送组播数据报</h3><h3 id="9-3-4-接收组播数据报"><a href="#9-3-4-接收组播数据报" class="headerlink" title="9.3.4 接收组播数据报"></a>9.3.4 接收组播数据报</h3><h3 id="9-3-5-主机地址过滤"><a href="#9-3-5-主机地址过滤" class="headerlink" title="9.3.5 主机地址过滤"></a>9.3.5 主机地址过滤</h3><h2 id="9-4-互联网组管理协议和组播侦听发现协议"><a href="#9-4-互联网组管理协议和组播侦听发现协议" class="headerlink" title="9.4 互联网组管理协议和组播侦听发现协议"></a>9.4 互联网组管理协议和组播侦听发现协议</h2><h3 id="9-4-1-组成员的IGMP和MLD处理（“组成员部分”）"><a href="#9-4-1-组成员的IGMP和MLD处理（“组成员部分”）" class="headerlink" title="9.4.1 组成员的IGMP和MLD处理（“组成员部分”）"></a>9.4.1 组成员的IGMP和MLD处理（“组成员部分”）</h3><h3 id="9-4-2-组播路由器的IGMP和MLD处理（“组播路由器部分”）"><a href="#9-4-2-组播路由器的IGMP和MLD处理（“组播路由器部分”）" class="headerlink" title="9.4.2 组播路由器的IGMP和MLD处理（“组播路由器部分”）"></a>9.4.2 组播路由器的IGMP和MLD处理（“组播路由器部分”）</h3><h3 id="9-4-3-例子"><a href="#9-4-3-例子" class="headerlink" title="9.4.3 例子"></a>9.4.3 例子</h3><h3 id="9-4-4-轻量级IGMPv3和MLDv2"><a href="#9-4-4-轻量级IGMPv3和MLDv2" class="headerlink" title="9.4.4 轻量级IGMPv3和MLDv2"></a>9.4.4 轻量级IGMPv3和MLDv2</h3><h3 id="9-4-5-IGMP和MLD健壮性"><a href="#9-4-5-IGMP和MLD健壮性" class="headerlink" title="9.4.5 IGMP和MLD健壮性"></a>9.4.5 IGMP和MLD健壮性</h3><h3 id="9-4-6-IGMP和MLD计数器和变量"><a href="#9-4-6-IGMP和MLD计数器和变量" class="headerlink" title="9.4.6 IGMP和MLD计数器和变量"></a>9.4.6 IGMP和MLD计数器和变量</h3><h3 id="9-4-7-IGMP和MLD探听"><a href="#9-4-7-IGMP和MLD探听" class="headerlink" title="9.4.7 IGMP和MLD探听"></a>9.4.7 IGMP和MLD探听</h3><h2 id="9-5-与IGMP和MLD相关的攻击"><a href="#9-5-与IGMP和MLD相关的攻击" class="headerlink" title="9.5 与IGMP和MLD相关的攻击"></a>9.5 与IGMP和MLD相关的攻击</h2><h2 id="9-6-总结"><a href="#9-6-总结" class="headerlink" title="9.6 总结"></a>9.6 总结</h2><h2 id="9-7-参考文献"><a href="#9-7-参考文献" class="headerlink" title="9.7 参考文献"></a>9.7 参考文献</h2><h1 id="第十章-用户数据报协议和IP分片"><a href="#第十章-用户数据报协议和IP分片" class="headerlink" title="第十章 用户数据报协议和IP分片"></a>第十章 用户数据报协议和IP分片</h1><h2 id="10-1-引言"><a href="#10-1-引言" class="headerlink" title="10.1 引言"></a>10.1 引言</h2><h2 id="10-2-UDP头部"><a href="#10-2-UDP头部" class="headerlink" title="10.2 UDP头部"></a>10.2 UDP头部</h2><h2 id="10-3-UDP检验和"><a href="#10-3-UDP检验和" class="headerlink" title="10.3 UDP检验和"></a>10.3 UDP检验和</h2><h2 id="10-4-例子"><a href="#10-4-例子" class="headerlink" title="10.4 例子"></a>10.4 例子</h2><h2 id="10-5-UDP和IPv6"><a href="#10-5-UDP和IPv6" class="headerlink" title="10.5 UDP和IPv6"></a>10.5 UDP和IPv6</h2><h3 id="10-5-1-Teredo：通过IPv4网络隧道传输IPv6"><a href="#10-5-1-Teredo：通过IPv4网络隧道传输IPv6" class="headerlink" title="10.5.1 Teredo：通过IPv4网络隧道传输IPv6"></a>10.5.1 Teredo：通过IPv4网络隧道传输IPv6</h3><h2 id="10-6-UDP-Lite"><a href="#10-6-UDP-Lite" class="headerlink" title="10.6 UDP-Lite"></a>10.6 UDP-Lite</h2><h2 id="10-7-IP分片"><a href="#10-7-IP分片" class="headerlink" title="10.7 IP分片"></a>10.7 IP分片</h2><h3 id="10-7-1-例子：UDP-IPv4分片"><a href="#10-7-1-例子：UDP-IPv4分片" class="headerlink" title="10.7.1 例子：UDP/IPv4分片"></a>10.7.1 例子：UDP/IPv4分片</h3><h3 id="10-7-2-重组超时"><a href="#10-7-2-重组超时" class="headerlink" title="10.7.2 重组超时"></a>10.7.2 重组超时</h3><h2 id="10-8-采用UDP的路径MTU发现"><a href="#10-8-采用UDP的路径MTU发现" class="headerlink" title="10.8 采用UDP的路径MTU发现"></a>10.8 采用UDP的路径MTU发现</h2><h3 id="10-8-1-例子"><a href="#10-8-1-例子" class="headerlink" title="10.8.1 例子"></a>10.8.1 例子</h3><h2 id="10-9-IP分片和ARP-ND之间的交互"><a href="#10-9-IP分片和ARP-ND之间的交互" class="headerlink" title="10.9 IP分片和ARP/ND之间的交互"></a>10.9 IP分片和ARP/ND之间的交互</h2><h2 id="10-10-最大UDP数据报长度"><a href="#10-10-最大UDP数据报长度" class="headerlink" title="10.10 最大UDP数据报长度"></a>10.10 最大UDP数据报长度</h2><h3 id="10-10-1-实现限制"><a href="#10-10-1-实现限制" class="headerlink" title="10.10.1 实现限制"></a>10.10.1 实现限制</h3><h3 id="10-10-2-数据报截断"><a href="#10-10-2-数据报截断" class="headerlink" title="10.10.2 数据报截断"></a>10.10.2 数据报截断</h3><h2 id="10-11-UDP服务器的设计"><a href="#10-11-UDP服务器的设计" class="headerlink" title="10.11 UDP服务器的设计"></a>10.11 UDP服务器的设计</h2><h3 id="10-11-1-IP地址和UDP端口号"><a href="#10-11-1-IP地址和UDP端口号" class="headerlink" title="10.11.1 IP地址和UDP端口号"></a>10.11.1 IP地址和UDP端口号</h3><h3 id="10-11-2-限制本地IP地址"><a href="#10-11-2-限制本地IP地址" class="headerlink" title="10.11.2 限制本地IP地址"></a>10.11.2 限制本地IP地址</h3><h3 id="10-11-3-使用多地址"><a href="#10-11-3-使用多地址" class="headerlink" title="10.11.3 使用多地址"></a>10.11.3 使用多地址</h3><h3 id="10-11-4-限制远端IP地址"><a href="#10-11-4-限制远端IP地址" class="headerlink" title="10.11.4 限制远端IP地址"></a>10.11.4 限制远端IP地址</h3><h3 id="10-11-5-每端口多服务器的使用"><a href="#10-11-5-每端口多服务器的使用" class="headerlink" title="10.11.5 每端口多服务器的使用"></a>10.11.5 每端口多服务器的使用</h3><h3 id="10-11-6-跨越地址族：IPv4和IPv6"><a href="#10-11-6-跨越地址族：IPv4和IPv6" class="headerlink" title="10.11.6 跨越地址族：IPv4和IPv6"></a>10.11.6 跨越地址族：IPv4和IPv6</h3><h3 id="10-11-7-流量和拥塞控制的缺失"><a href="#10-11-7-流量和拥塞控制的缺失" class="headerlink" title="10.11.7 流量和拥塞控制的缺失"></a>10.11.7 流量和拥塞控制的缺失</h3><h2 id="10-12-UDP-IPv4和UDP-IPv6数据报的转换"><a href="#10-12-UDP-IPv4和UDP-IPv6数据报的转换" class="headerlink" title="10.12 UDP/IPv4和UDP/IPv6数据报的转换"></a>10.12 UDP/IPv4和UDP/IPv6数据报的转换</h2><h2 id="10-13-互联网中的UDP"><a href="#10-13-互联网中的UDP" class="headerlink" title="10.13 互联网中的UDP"></a>10.13 互联网中的UDP</h2><h2 id="10-14-与UDP和IP分片相关的攻击"><a href="#10-14-与UDP和IP分片相关的攻击" class="headerlink" title="10.14 与UDP和IP分片相关的攻击"></a>10.14 与UDP和IP分片相关的攻击</h2><h2 id="10-15-总结"><a href="#10-15-总结" class="headerlink" title="10.15 总结"></a>10.15 总结</h2><h2 id="10-16-参考文献"><a href="#10-16-参考文献" class="headerlink" title="10.16 参考文献"></a>10.16 参考文献</h2><h1 id="第十一章-名称解析和域名系统"><a href="#第十一章-名称解析和域名系统" class="headerlink" title="第十一章 名称解析和域名系统"></a>第十一章 名称解析和域名系统</h1><h2 id="11-1-引言"><a href="#11-1-引言" class="headerlink" title="11.1 引言"></a>11.1 引言</h2><h2 id="11-2-DNS名称空间"><a href="#11-2-DNS名称空间" class="headerlink" title="11.2 DNS名称空间"></a>11.2 DNS名称空间</h2><h3 id="11-2-1-DNS命名语法"><a href="#11-2-1-DNS命名语法" class="headerlink" title="11.2.1 DNS命名语法"></a>11.2.1 DNS命名语法</h3><h2 id="11-3-名称服务器和区域"><a href="#11-3-名称服务器和区域" class="headerlink" title="11.3 名称服务器和区域"></a>11.3 名称服务器和区域</h2><h2 id="11-4-缓存"><a href="#11-4-缓存" class="headerlink" title="11.4 缓存"></a>11.4 缓存</h2><h2 id="11-5-DNS协议"><a href="#11-5-DNS协议" class="headerlink" title="11.5 DNS协议"></a>11.5 DNS协议</h2><h3 id="11-5-1-DNS消息格式"><a href="#11-5-1-DNS消息格式" class="headerlink" title="11.5.1 DNS消息格式"></a>11.5.1 DNS消息格式</h3><h3 id="11-5-2-DNS扩展格式（EDNS0）"><a href="#11-5-2-DNS扩展格式（EDNS0）" class="headerlink" title="11.5.2 DNS扩展格式（EDNS0）"></a>11.5.2 DNS扩展格式（EDNS0）</h3><h3 id="11-5-3-UDP或TCP"><a href="#11-5-3-UDP或TCP" class="headerlink" title="11.5.3 UDP或TCP"></a>11.5.3 UDP或TCP</h3><h3 id="11-5-4-问题（查询）和区域区段格式"><a href="#11-5-4-问题（查询）和区域区段格式" class="headerlink" title="11.5.4 问题（查询）和区域区段格式"></a>11.5.4 问题（查询）和区域区段格式</h3><h3 id="11-5-5-回答、授权和额外信息区段格式"><a href="#11-5-5-回答、授权和额外信息区段格式" class="headerlink" title="11.5.5 回答、授权和额外信息区段格式"></a>11.5.5 回答、授权和额外信息区段格式</h3><h3 id="11-5-6-资源记录类型"><a href="#11-5-6-资源记录类型" class="headerlink" title="11.5.6 资源记录类型"></a>11.5.6 资源记录类型</h3><h3 id="11-5-7-动态更新（DNS-UPDATE）"><a href="#11-5-7-动态更新（DNS-UPDATE）" class="headerlink" title="11.5.7 动态更新（DNS UPDATE）"></a>11.5.7 动态更新（DNS UPDATE）</h3><h3 id="11-5-8-区域传输和DNS通知"><a href="#11-5-8-区域传输和DNS通知" class="headerlink" title="11.5.8 区域传输和DNS通知"></a>11.5.8 区域传输和DNS通知</h3><h2 id="11-6-排序列表、循环和分离DNS"><a href="#11-6-排序列表、循环和分离DNS" class="headerlink" title="11.6 排序列表、循环和分离DNS"></a>11.6 排序列表、循环和分离DNS</h2><h2 id="11-7-开放DNS服务器和DynDNS"><a href="#11-7-开放DNS服务器和DynDNS" class="headerlink" title="11.7 开放DNS服务器和DynDNS"></a>11.7 开放DNS服务器和DynDNS</h2><h2 id="11-8-透明度和扩展性"><a href="#11-8-透明度和扩展性" class="headerlink" title="11.8 透明度和扩展性"></a>11.8 透明度和扩展性</h2><h2 id="11-9-从IPv4向IPv6转换DNS"><a href="#11-9-从IPv4向IPv6转换DNS" class="headerlink" title="11.9 从IPv4向IPv6转换DNS"></a>11.9 从IPv4向IPv6转换DNS</h2><h2 id="11-10-LLMNR和mDNS"><a href="#11-10-LLMNR和mDNS" class="headerlink" title="11.10 LLMNR和mDNS"></a>11.10 LLMNR和mDNS</h2><h2 id="11-11-LDAP"><a href="#11-11-LDAP" class="headerlink" title="11.11 LDAP"></a>11.11 LDAP</h2><h2 id="11-12-与DNS相关的攻击"><a href="#11-12-与DNS相关的攻击" class="headerlink" title="11.12 与DNS相关的攻击"></a>11.12 与DNS相关的攻击</h2><h2 id="11-13-总结"><a href="#11-13-总结" class="headerlink" title="11.13 总结"></a>11.13 总结</h2><h2 id="11-14-参考文献"><a href="#11-14-参考文献" class="headerlink" title="11.14 参考文献"></a>11.14 参考文献</h2><h1 id="第十二章-TCP：传输控制协议（初步）"><a href="#第十二章-TCP：传输控制协议（初步）" class="headerlink" title="第十二章 TCP：传输控制协议（初步）"></a>第十二章 TCP：传输控制协议（初步）</h1><h2 id="12-1-引言"><a href="#12-1-引言" class="headerlink" title="12.1 引言"></a>12.1 引言</h2><h3 id="12-1-1-ARQ和重传"><a href="#12-1-1-ARQ和重传" class="headerlink" title="12.1.1 ARQ和重传"></a>12.1.1 ARQ和重传</h3><h3 id="12-1-2-分组窗口和滑动窗口"><a href="#12-1-2-分组窗口和滑动窗口" class="headerlink" title="12.1.2 分组窗口和滑动窗口"></a>12.1.2 分组窗口和滑动窗口</h3><h3 id="12-1-3-变量窗口：流量控制和拥塞控制"><a href="#12-1-3-变量窗口：流量控制和拥塞控制" class="headerlink" title="12.1.3 变量窗口：流量控制和拥塞控制"></a>12.1.3 变量窗口：流量控制和拥塞控制</h3><h3 id="12-1-4-设置重传超时"><a href="#12-1-4-设置重传超时" class="headerlink" title="12.1.4 设置重传超时"></a>12.1.4 设置重传超时</h3><h2 id="12-2-TCP的引入"><a href="#12-2-TCP的引入" class="headerlink" title="12.2 TCP的引入"></a>12.2 TCP的引入</h2><h3 id="12-2-1-TCP服务模型"><a href="#12-2-1-TCP服务模型" class="headerlink" title="12.2.1 TCP服务模型"></a>12.2.1 TCP服务模型</h3><h3 id="12-2-2-TCP中的可靠性"><a href="#12-2-2-TCP中的可靠性" class="headerlink" title="12.2.2 TCP中的可靠性"></a>12.2.2 TCP中的可靠性</h3><h2 id="12-3-TCP头部和封装"><a href="#12-3-TCP头部和封装" class="headerlink" title="12.3 TCP头部和封装"></a>12.3 TCP头部和封装</h2><h2 id="12-4-总结"><a href="#12-4-总结" class="headerlink" title="12.4 总结"></a>12.4 总结</h2><h2 id="12-5-参考文献"><a href="#12-5-参考文献" class="headerlink" title="12.5 参考文献"></a>12.5 参考文献</h2><h1 id="第十三章-TCP连接管理"><a href="#第十三章-TCP连接管理" class="headerlink" title="第十三章 TCP连接管理"></a>第十三章 TCP连接管理</h1><h2 id="13-1-引言"><a href="#13-1-引言" class="headerlink" title="13.1 引言"></a>13.1 引言</h2><h2 id="13-2-TCP连接的建立与终止"><a href="#13-2-TCP连接的建立与终止" class="headerlink" title="13.2 TCP连接的建立与终止"></a>13.2 TCP连接的建立与终止</h2><h3 id="13-2-1-TCP半关闭"><a href="#13-2-1-TCP半关闭" class="headerlink" title="13.2.1 TCP半关闭"></a>13.2.1 TCP半关闭</h3><h3 id="13-2-2-同时打开与关闭"><a href="#13-2-2-同时打开与关闭" class="headerlink" title="13.2.2 同时打开与关闭"></a>13.2.2 同时打开与关闭</h3><h3 id="13-2-3-初始序列号"><a href="#13-2-3-初始序列号" class="headerlink" title="13.2.3 初始序列号"></a>13.2.3 初始序列号</h3><h3 id="13-2-4-例子"><a href="#13-2-4-例子" class="headerlink" title="13.2.4 例子"></a>13.2.4 例子</h3><h3 id="13-2-5-连接建立超时"><a href="#13-2-5-连接建立超时" class="headerlink" title="13.2.5 连接建立超时"></a>13.2.5 连接建立超时</h3><h3 id="13-2-6-连接与转换器"><a href="#13-2-6-连接与转换器" class="headerlink" title="13.2.6 连接与转换器"></a>13.2.6 连接与转换器</h3><h2 id="13-3-TCP选项"><a href="#13-3-TCP选项" class="headerlink" title="13.3 TCP选项"></a>13.3 TCP选项</h2><h3 id="13-3-1-最大段大小选项"><a href="#13-3-1-最大段大小选项" class="headerlink" title="13.3.1 最大段大小选项"></a>13.3.1 最大段大小选项</h3><h3 id="13-3-2-选择确认选项"><a href="#13-3-2-选择确认选项" class="headerlink" title="13.3.2 选择确认选项"></a>13.3.2 选择确认选项</h3><h3 id="13-3-3-窗口缩放选项"><a href="#13-3-3-窗口缩放选项" class="headerlink" title="13.3.3 窗口缩放选项"></a>13.3.3 窗口缩放选项</h3><h3 id="13-3-4-时间戳选项和防回绕序列号"><a href="#13-3-4-时间戳选项和防回绕序列号" class="headerlink" title="13.3.4 时间戳选项和防回绕序列号"></a>13.3.4 时间戳选项和防回绕序列号</h3><h3 id="13-3-5-用户超时选项"><a href="#13-3-5-用户超时选项" class="headerlink" title="13.3.5 用户超时选项"></a>13.3.5 用户超时选项</h3><h3 id="13-3-6-认证选项"><a href="#13-3-6-认证选项" class="headerlink" title="13.3.6 认证选项"></a>13.3.6 认证选项</h3><h2 id="13-4-TCP的路径最大传输单元发现"><a href="#13-4-TCP的路径最大传输单元发现" class="headerlink" title="13.4 TCP的路径最大传输单元发现"></a>13.4 TCP的路径最大传输单元发现</h2><h3 id="13-4-1-例子"><a href="#13-4-1-例子" class="headerlink" title="13.4.1 例子"></a>13.4.1 例子</h3><h2 id="13-5-TCP状态转换"><a href="#13-5-TCP状态转换" class="headerlink" title="13.5 TCP状态转换"></a>13.5 TCP状态转换</h2><h3 id="13-5-1-TCP状态转换图"><a href="#13-5-1-TCP状态转换图" class="headerlink" title="13.5.1 TCP状态转换图"></a>13.5.1 TCP状态转换图</h3><h3 id="13-5-2-TIME-WAIT状态"><a href="#13-5-2-TIME-WAIT状态" class="headerlink" title="13.5.2 TIME_WAIT状态"></a>13.5.2 TIME_WAIT状态</h3><h3 id="13-5-3-静默时间的概念"><a href="#13-5-3-静默时间的概念" class="headerlink" title="13.5.3 静默时间的概念"></a>13.5.3 静默时间的概念</h3><h3 id="13-5-4-FIN-WAIT-2状态"><a href="#13-5-4-FIN-WAIT-2状态" class="headerlink" title="13.5.4 FIN_WAIT_2状态"></a>13.5.4 FIN_WAIT_2状态</h3><h3 id="13-5-5-同时打开与关闭的转换"><a href="#13-5-5-同时打开与关闭的转换" class="headerlink" title="13.5.5 同时打开与关闭的转换"></a>13.5.5 同时打开与关闭的转换</h3><h2 id="13-6-重置报文段"><a href="#13-6-重置报文段" class="headerlink" title="13.6 重置报文段"></a>13.6 重置报文段</h2><h3 id="13-6-1-针对不存在端口的连接请求"><a href="#13-6-1-针对不存在端口的连接请求" class="headerlink" title="13.6.1 针对不存在端口的连接请求"></a>13.6.1 针对不存在端口的连接请求</h3><h3 id="13-6-2-终止一条连接"><a href="#13-6-2-终止一条连接" class="headerlink" title="13.6.2 终止一条连接"></a>13.6.2 终止一条连接</h3><h3 id="13-6-3-半开连接"><a href="#13-6-3-半开连接" class="headerlink" title="13.6.3 半开连接"></a>13.6.3 半开连接</h3><h3 id="13-6-4-时间等待错误"><a href="#13-6-4-时间等待错误" class="headerlink" title="13.6.4 时间等待错误"></a>13.6.4 时间等待错误</h3><h2 id="13-7-TCP服务器选项"><a href="#13-7-TCP服务器选项" class="headerlink" title="13.7 TCP服务器选项"></a>13.7 TCP服务器选项</h2><h3 id="13-7-1-TCP端口号"><a href="#13-7-1-TCP端口号" class="headerlink" title="13.7.1 TCP端口号"></a>13.7.1 TCP端口号</h3><h3 id="13-7-2-限制本地IP地址"><a href="#13-7-2-限制本地IP地址" class="headerlink" title="13.7.2 限制本地IP地址"></a>13.7.2 限制本地IP地址</h3><h3 id="13-7-3-限制外部节点"><a href="#13-7-3-限制外部节点" class="headerlink" title="13.7.3 限制外部节点"></a>13.7.3 限制外部节点</h3><h3 id="13-7-4-进入连接队列"><a href="#13-7-4-进入连接队列" class="headerlink" title="13.7.4 进入连接队列"></a>13.7.4 进入连接队列</h3><h2 id="13-8-与TCP连接管理相关的攻击"><a href="#13-8-与TCP连接管理相关的攻击" class="headerlink" title="13.8 与TCP连接管理相关的攻击"></a>13.8 与TCP连接管理相关的攻击</h2><h2 id="13-9-总结"><a href="#13-9-总结" class="headerlink" title="13.9 总结"></a>13.9 总结</h2><h2 id="13-10-参考文献"><a href="#13-10-参考文献" class="headerlink" title="13.10 参考文献"></a>13.10 参考文献</h2><h1 id="第十四章-TCP超时与重传"><a href="#第十四章-TCP超时与重传" class="headerlink" title="第十四章 TCP超时与重传"></a>第十四章 TCP超时与重传</h1><h2 id="14-1-引言"><a href="#14-1-引言" class="headerlink" title="14.1 引言"></a>14.1 引言</h2><h2 id="14-2-简单的超时与重传举例"><a href="#14-2-简单的超时与重传举例" class="headerlink" title="14.2 简单的超时与重传举例"></a>14.2 简单的超时与重传举例</h2><h2 id="14-3-设置重传超时"><a href="#14-3-设置重传超时" class="headerlink" title="14.3 设置重传超时"></a>14.3 设置重传超时</h2><h3 id="14-3-1-经典方法"><a href="#14-3-1-经典方法" class="headerlink" title="14.3.1 经典方法"></a>14.3.1 经典方法</h3><h3 id="14-3-2-标准方法"><a href="#14-3-2-标准方法" class="headerlink" title="14.3.2 标准方法"></a>14.3.2 标准方法</h3><h3 id="14-3-3-Linux采用的方法"><a href="#14-3-3-Linux采用的方法" class="headerlink" title="14.3.3 Linux采用的方法"></a>14.3.3 Linux采用的方法</h3><h3 id="14-3-4-RTT估计器行为"><a href="#14-3-4-RTT估计器行为" class="headerlink" title="14.3.4 RTT估计器行为"></a>14.3.4 RTT估计器行为</h3><h3 id="14-3-5RTTM对丢包和失序的鲁棒性"><a href="#14-3-5RTTM对丢包和失序的鲁棒性" class="headerlink" title="14.3.5RTTM对丢包和失序的鲁棒性"></a>14.3.5RTTM对丢包和失序的鲁棒性</h3><h2 id="14-4-基于计时器的重传"><a href="#14-4-基于计时器的重传" class="headerlink" title="14.4 基于计时器的重传"></a>14.4 基于计时器的重传</h2><h3 id="14-4-1-例子"><a href="#14-4-1-例子" class="headerlink" title="14.4.1 例子"></a>14.4.1 例子</h3><h2 id="14-5-快速重传"><a href="#14-5-快速重传" class="headerlink" title="14.5 快速重传"></a>14.5 快速重传</h2><h3 id="14-5-1-例子"><a href="#14-5-1-例子" class="headerlink" title="14.5.1 例子"></a>14.5.1 例子</h3><h2 id="14-6-带选择确认的重传"><a href="#14-6-带选择确认的重传" class="headerlink" title="14.6 带选择确认的重传"></a>14.6 带选择确认的重传</h2><h3 id="14-6-1-SACK接收端行为"><a href="#14-6-1-SACK接收端行为" class="headerlink" title="14.6.1 SACK接收端行为"></a>14.6.1 SACK接收端行为</h3><h3 id="14-6-2-SACK发送端行为"><a href="#14-6-2-SACK发送端行为" class="headerlink" title="14.6.2 SACK发送端行为"></a>14.6.2 SACK发送端行为</h3><h3 id="14-6-3-例子"><a href="#14-6-3-例子" class="headerlink" title="14.6.3 例子"></a>14.6.3 例子</h3><h2 id="14-7-伪超时与重传"><a href="#14-7-伪超时与重传" class="headerlink" title="14.7 伪超时与重传"></a>14.7 伪超时与重传</h2><h3 id="14-7-1-重复SACK（DSACK）扩展"><a href="#14-7-1-重复SACK（DSACK）扩展" class="headerlink" title="14.7.1 重复SACK（DSACK）扩展"></a>14.7.1 重复SACK（DSACK）扩展</h3><h3 id="14-7-2-Eifel检测算法"><a href="#14-7-2-Eifel检测算法" class="headerlink" title="14.7.2 Eifel检测算法"></a>14.7.2 Eifel检测算法</h3><h3 id="14-7-3-前移RTO恢复（F-RTO）"><a href="#14-7-3-前移RTO恢复（F-RTO）" class="headerlink" title="14.7.3 前移RTO恢复（F-RTO）"></a>14.7.3 前移RTO恢复（F-RTO）</h3><h3 id="14-7-4-Eifel响应算法"><a href="#14-7-4-Eifel响应算法" class="headerlink" title="14.7.4 Eifel响应算法"></a>14.7.4 Eifel响应算法</h3><h2 id="14-8-包失序与包重复"><a href="#14-8-包失序与包重复" class="headerlink" title="14.8 包失序与包重复"></a>14.8 包失序与包重复</h2><h3 id="14-8-1-失序"><a href="#14-8-1-失序" class="headerlink" title="14.8.1 失序"></a>14.8.1 失序</h3><h3 id="14-8-2-重复"><a href="#14-8-2-重复" class="headerlink" title="14.8.2 重复"></a>14.8.2 重复</h3><h2 id="14-9-目的度量"><a href="#14-9-目的度量" class="headerlink" title="14.9 目的度量"></a>14.9 目的度量</h2><h2 id="14-10-重新组包"><a href="#14-10-重新组包" class="headerlink" title="14.10 重新组包"></a>14.10 重新组包</h2><h2 id="14-11-与TCP重传相关的攻击"><a href="#14-11-与TCP重传相关的攻击" class="headerlink" title="14.11 与TCP重传相关的攻击"></a>14.11 与TCP重传相关的攻击</h2><h2 id="14-12-总结"><a href="#14-12-总结" class="headerlink" title="14.12 总结"></a>14.12 总结</h2><h2 id="14-13-参考文献"><a href="#14-13-参考文献" class="headerlink" title="14.13 参考文献"></a>14.13 参考文献</h2><h1 id="第十五章-TCP数据流与窗口管理"><a href="#第十五章-TCP数据流与窗口管理" class="headerlink" title="第十五章 TCP数据流与窗口管理"></a>第十五章 TCP数据流与窗口管理</h1><h2 id="15-1-引言"><a href="#15-1-引言" class="headerlink" title="15.1 引言"></a>15.1 引言</h2><h2 id="15-2-交互式通信"><a href="#15-2-交互式通信" class="headerlink" title="15.2 交互式通信"></a>15.2 交互式通信</h2><h2 id="15-3-延时确认"><a href="#15-3-延时确认" class="headerlink" title="15.3 延时确认"></a>15.3 延时确认</h2><h2 id="15-4-Nagle算法"><a href="#15-4-Nagle算法" class="headerlink" title="15.4 Nagle算法"></a>15.4 Nagle算法</h2><h3 id="15-4-1-延时ACK与Nagle算法结合"><a href="#15-4-1-延时ACK与Nagle算法结合" class="headerlink" title="15.4.1 延时ACK与Nagle算法结合"></a>15.4.1 延时ACK与Nagle算法结合</h3><h3 id="15-4-2-禁用Nagle算法"><a href="#15-4-2-禁用Nagle算法" class="headerlink" title="15.4.2 禁用Nagle算法"></a>15.4.2 禁用Nagle算法</h3><h2 id="15-5-流量控制与窗口管理"><a href="#15-5-流量控制与窗口管理" class="headerlink" title="15.5 流量控制与窗口管理"></a>15.5 流量控制与窗口管理</h2><h3 id="15-5-1-滑动窗口"><a href="#15-5-1-滑动窗口" class="headerlink" title="15.5.1 滑动窗口"></a>15.5.1 滑动窗口</h3><h3 id="15-5-2-零窗口与TCP持续计时器"><a href="#15-5-2-零窗口与TCP持续计时器" class="headerlink" title="15.5.2 零窗口与TCP持续计时器"></a>15.5.2 零窗口与TCP持续计时器</h3><h3 id="15-5-3-糊涂窗口综合征"><a href="#15-5-3-糊涂窗口综合征" class="headerlink" title="15.5.3 糊涂窗口综合征"></a>15.5.3 糊涂窗口综合征</h3><h3 id="15-5-4-大容量缓存与自动调优"><a href="#15-5-4-大容量缓存与自动调优" class="headerlink" title="15.5.4 大容量缓存与自动调优"></a>15.5.4 大容量缓存与自动调优</h3><h2 id="15-6-紧急机制"><a href="#15-6-紧急机制" class="headerlink" title="15.6 紧急机制"></a>15.6 紧急机制</h2><h3 id="15-6-1-例子"><a href="#15-6-1-例子" class="headerlink" title="15.6.1 例子"></a>15.6.1 例子</h3><h2 id="15-7-与窗口管理相关的攻击"><a href="#15-7-与窗口管理相关的攻击" class="headerlink" title="15.7 与窗口管理相关的攻击"></a>15.7 与窗口管理相关的攻击</h2><h2 id="15-8-总结"><a href="#15-8-总结" class="headerlink" title="15.8 总结"></a>15.8 总结</h2><h2 id="15-9-参考文献"><a href="#15-9-参考文献" class="headerlink" title="15.9 参考文献"></a>15.9 参考文献</h2><h1 id="第十六章-TCP拥塞控制"><a href="#第十六章-TCP拥塞控制" class="headerlink" title="第十六章 TCP拥塞控制"></a>第十六章 TCP拥塞控制</h1><h2 id="16-1-引言"><a href="#16-1-引言" class="headerlink" title="16.1 引言"></a>16.1 引言</h2><h3 id="16-1-1-TCP拥塞检测"><a href="#16-1-1-TCP拥塞检测" class="headerlink" title="16.1.1 TCP拥塞检测"></a>16.1.1 TCP拥塞检测</h3><h3 id="16-1-2-减缓TCP发送"><a href="#16-1-2-减缓TCP发送" class="headerlink" title="16.1.2 减缓TCP发送"></a>16.1.2 减缓TCP发送</h3><h2 id="16-2-一些经典算法"><a href="#16-2-一些经典算法" class="headerlink" title="16.2 一些经典算法"></a>16.2 一些经典算法</h2><h3 id="16-2-1-慢启动"><a href="#16-2-1-慢启动" class="headerlink" title="16.2.1 慢启动"></a>16.2.1 慢启动</h3><h3 id="16-2-2-拥塞避免"><a href="#16-2-2-拥塞避免" class="headerlink" title="16.2.2 拥塞避免"></a>16.2.2 拥塞避免</h3><h3 id="16-2-3-慢启动和拥塞避免的选择"><a href="#16-2-3-慢启动和拥塞避免的选择" class="headerlink" title="16.2.3 慢启动和拥塞避免的选择"></a>16.2.3 慢启动和拥塞避免的选择</h3><h3 id="16-2-4-Tahoe、Reno以及快速恢复算法"><a href="#16-2-4-Tahoe、Reno以及快速恢复算法" class="headerlink" title="16.2.4 Tahoe、Reno以及快速恢复算法"></a>16.2.4 Tahoe、Reno以及快速恢复算法</h3><h3 id="16-2-5-标准TCP"><a href="#16-2-5-标准TCP" class="headerlink" title="16.2.5 标准TCP"></a>16.2.5 标准TCP</h3><h2 id="16-3-对标准算法的改进"><a href="#16-3-对标准算法的改进" class="headerlink" title="16.3 对标准算法的改进"></a>16.3 对标准算法的改进</h2><h3 id="16-3-1-NewReno"><a href="#16-3-1-NewReno" class="headerlink" title="16.3.1 NewReno"></a>16.3.1 NewReno</h3><h3 id="16-3-2-采用选择确认机制的TCP拥塞控制"><a href="#16-3-2-采用选择确认机制的TCP拥塞控制" class="headerlink" title="16.3.2 采用选择确认机制的TCP拥塞控制"></a>16.3.2 采用选择确认机制的TCP拥塞控制</h3><h3 id="16-3-3-转发确认（FACK）和速率减半"><a href="#16-3-3-转发确认（FACK）和速率减半" class="headerlink" title="16.3.3 转发确认（FACK）和速率减半"></a>16.3.3 转发确认（FACK）和速率减半</h3><h3 id="16-3-4-限制传输"><a href="#16-3-4-限制传输" class="headerlink" title="16.3.4 限制传输"></a>16.3.4 限制传输</h3><h3 id="16-3-5-拥塞窗口校验"><a href="#16-3-5-拥塞窗口校验" class="headerlink" title="16.3.5 拥塞窗口校验"></a>16.3.5 拥塞窗口校验</h3><h2 id="16-4-伪RTO处理—Eifel响应算法"><a href="#16-4-伪RTO处理—Eifel响应算法" class="headerlink" title="16.4 伪RTO处理—Eifel响应算法"></a>16.4 伪RTO处理—Eifel响应算法</h2><h2 id="16-5-扩展举例"><a href="#16-5-扩展举例" class="headerlink" title="16.5 扩展举例"></a>16.5 扩展举例</h2><h3 id="16-5-1-慢启动行为"><a href="#16-5-1-慢启动行为" class="headerlink" title="16.5.1 慢启动行为"></a>16.5.1 慢启动行为</h3><h3 id="16-5-2-发送暂停和本地拥塞（事件1）"><a href="#16-5-2-发送暂停和本地拥塞（事件1）" class="headerlink" title="16.5.2 发送暂停和本地拥塞（事件1）"></a>16.5.2 发送暂停和本地拥塞（事件1）</h3><h3 id="16-5-3-延伸ACK和本地拥塞恢复"><a href="#16-5-3-延伸ACK和本地拥塞恢复" class="headerlink" title="16.5.3 延伸ACK和本地拥塞恢复"></a>16.5.3 延伸ACK和本地拥塞恢复</h3><h3 id="16-5-4-快速重传和SACK恢复（事件2）"><a href="#16-5-4-快速重传和SACK恢复（事件2）" class="headerlink" title="16.5.4 快速重传和SACK恢复（事件2）"></a>16.5.4 快速重传和SACK恢复（事件2）</h3><h3 id="16-5-5-其他本地拥塞和快速重传事件"><a href="#16-5-5-其他本地拥塞和快速重传事件" class="headerlink" title="16.5.5 其他本地拥塞和快速重传事件"></a>16.5.5 其他本地拥塞和快速重传事件</h3><h3 id="16-5-6-超时、重传和撤销cwnd修改"><a href="#16-5-6-超时、重传和撤销cwnd修改" class="headerlink" title="16.5.6 超时、重传和撤销cwnd修改"></a>16.5.6 超时、重传和撤销cwnd修改</h3><h3 id="16-5-7-连接结束"><a href="#16-5-7-连接结束" class="headerlink" title="16.5.7 连接结束"></a>16.5.7 连接结束</h3><h2 id="16-6-共享拥塞状态信息"><a href="#16-6-共享拥塞状态信息" class="headerlink" title="16.6 共享拥塞状态信息"></a>16.6 共享拥塞状态信息</h2><h2 id="16-7-TCP友好性"><a href="#16-7-TCP友好性" class="headerlink" title="16.7 TCP友好性"></a>16.7 TCP友好性</h2><h2 id="16-8-高速环境下的TCP"><a href="#16-8-高速环境下的TCP" class="headerlink" title="16.8 高速环境下的TCP"></a>16.8 高速环境下的TCP</h2><h3 id="16-8-1-高速TCP与受限的慢启动"><a href="#16-8-1-高速TCP与受限的慢启动" class="headerlink" title="16.8.1 高速TCP与受限的慢启动"></a>16.8.1 高速TCP与受限的慢启动</h3><h3 id="16-8-2-二进制增长拥塞控制（BIC和CUBIC）"><a href="#16-8-2-二进制增长拥塞控制（BIC和CUBIC）" class="headerlink" title="16.8.2 二进制增长拥塞控制（BIC和CUBIC）"></a>16.8.2 二进制增长拥塞控制（BIC和CUBIC）</h3><h2 id="16-9-基于延迟的拥塞控制算法"><a href="#16-9-基于延迟的拥塞控制算法" class="headerlink" title="16.9 基于延迟的拥塞控制算法"></a>16.9 基于延迟的拥塞控制算法</h2><h3 id="16-9-1-Vegas算法"><a href="#16-9-1-Vegas算法" class="headerlink" title="16.9.1 Vegas算法"></a>16.9.1 Vegas算法</h3><h3 id="16-9-2-FAST算法"><a href="#16-9-2-FAST算法" class="headerlink" title="16.9.2 FAST算法"></a>16.9.2 FAST算法</h3><h3 id="16-9-3-TCP-Westwood算法和Westwood-算法"><a href="#16-9-3-TCP-Westwood算法和Westwood-算法" class="headerlink" title="16.9.3 TCP Westwood算法和Westwood+ 算法"></a>16.9.3 TCP Westwood算法和Westwood+ 算法</h3><h3 id="16-9-4-复合TCP"><a href="#16-9-4-复合TCP" class="headerlink" title="16.9.4 复合TCP"></a>16.9.4 复合TCP</h3><h2 id="16-10-缓冲区膨胀"><a href="#16-10-缓冲区膨胀" class="headerlink" title="16.10 缓冲区膨胀"></a>16.10 缓冲区膨胀</h2><h2 id="16-11-积极列队管理和ECN"><a href="#16-11-积极列队管理和ECN" class="headerlink" title="16.11 积极列队管理和ECN"></a>16.11 积极列队管理和ECN</h2><h2 id="16-12-与TCP拥塞控制相关的攻击"><a href="#16-12-与TCP拥塞控制相关的攻击" class="headerlink" title="16.12 与TCP拥塞控制相关的攻击"></a>16.12 与TCP拥塞控制相关的攻击</h2><h2 id="16-13-总结"><a href="#16-13-总结" class="headerlink" title="16.13 总结"></a>16.13 总结</h2><h2 id="16-14-参考文献"><a href="#16-14-参考文献" class="headerlink" title="16.14 参考文献"></a>16.14 参考文献</h2><h1 id="第十七章-TCP保活机制"><a href="#第十七章-TCP保活机制" class="headerlink" title="第十七章 TCP保活机制"></a>第十七章 TCP保活机制</h1><h2 id="17-1-引言"><a href="#17-1-引言" class="headerlink" title="17.1 引言"></a>17.1 引言</h2><h2 id="17-2-描述"><a href="#17-2-描述" class="headerlink" title="17.2 描述"></a>17.2 描述</h2><h3 id="17-2-1-保活功能举例"><a href="#17-2-1-保活功能举例" class="headerlink" title="17.2.1 保活功能举例"></a>17.2.1 保活功能举例</h3><h2 id="17-3-与TCP保活机制相关的攻击"><a href="#17-3-与TCP保活机制相关的攻击" class="headerlink" title="17.3 与TCP保活机制相关的攻击"></a>17.3 与TCP保活机制相关的攻击</h2><h2 id="17-4-总结"><a href="#17-4-总结" class="headerlink" title="17.4 总结"></a>17.4 总结</h2><h2 id="17-5-参考文献"><a href="#17-5-参考文献" class="headerlink" title="17.5 参考文献"></a>17.5 参考文献</h2><h1 id="第十八章-安全：可扩展身份认证协议、IP安全协议、传输层安全、DNS安全、域名密钥识别邮箱"><a href="#第十八章-安全：可扩展身份认证协议、IP安全协议、传输层安全、DNS安全、域名密钥识别邮箱" class="headerlink" title="第十八章 安全：可扩展身份认证协议、IP安全协议、传输层安全、DNS安全、域名密钥识别邮箱"></a>第十八章 安全：可扩展身份认证协议、IP安全协议、传输层安全、DNS安全、域名密钥识别邮箱</h1><h2 id="18-1-引言"><a href="#18-1-引言" class="headerlink" title="18.1 引言"></a>18.1 引言</h2><h2 id="18-2-信息安全的基本原则"><a href="#18-2-信息安全的基本原则" class="headerlink" title="18.2 信息安全的基本原则"></a>18.2 信息安全的基本原则</h2><h2 id="18-3-网络通信的威胁"><a href="#18-3-网络通信的威胁" class="headerlink" title="18.3 网络通信的威胁"></a>18.3 网络通信的威胁</h2><h2 id="18-4-基础的加密与安全机制"><a href="#18-4-基础的加密与安全机制" class="headerlink" title="18.4 基础的加密与安全机制"></a>18.4 基础的加密与安全机制</h2><h3 id="18-4-1-密码系统"><a href="#18-4-1-密码系统" class="headerlink" title="18.4.1 密码系统"></a>18.4.1 密码系统</h3><h3 id="18-4-2-RSA公钥密码算法"><a href="#18-4-2-RSA公钥密码算法" class="headerlink" title="18.4.2 RSA公钥密码算法"></a>18.4.2 RSA公钥密码算法</h3><h3 id="18-4-3-Diffie-Hellman-Merkle密钥协商协议"><a href="#18-4-3-Diffie-Hellman-Merkle密钥协商协议" class="headerlink" title="18.4.3 Diffie-Hellman-Merkle密钥协商协议"></a>18.4.3 Diffie-Hellman-Merkle密钥协商协议</h3><h3 id="18-4-4-签密与椭圆曲线密码"><a href="#18-4-4-签密与椭圆曲线密码" class="headerlink" title="18.4.4 签密与椭圆曲线密码"></a>18.4.4 签密与椭圆曲线密码</h3><h3 id="18-4-5-密钥派生与完全正向保密"><a href="#18-4-5-密钥派生与完全正向保密" class="headerlink" title="18.4.5 密钥派生与完全正向保密"></a>18.4.5 密钥派生与完全正向保密</h3><h3 id="18-4-6-伪随机数、生成器与函数族"><a href="#18-4-6-伪随机数、生成器与函数族" class="headerlink" title="18.4.6 伪随机数、生成器与函数族"></a>18.4.6 伪随机数、生成器与函数族</h3><h3 id="18-4-7-随机数与混淆值"><a href="#18-4-7-随机数与混淆值" class="headerlink" title="18.4.7 随机数与混淆值"></a>18.4.7 随机数与混淆值</h3><h3 id="18-4-8-加密散列函数与消息摘要"><a href="#18-4-8-加密散列函数与消息摘要" class="headerlink" title="18.4.8 加密散列函数与消息摘要"></a>18.4.8 加密散列函数与消息摘要</h3><h3 id="18-4-9-消息认证码"><a href="#18-4-9-消息认证码" class="headerlink" title="18.4.9 消息认证码"></a>18.4.9 消息认证码</h3><h3 id="18-4-10-加密套件与密码套件"><a href="#18-4-10-加密套件与密码套件" class="headerlink" title="18.4.10 加密套件与密码套件"></a>18.4.10 加密套件与密码套件</h3><h2 id="18-5-证书、证书办法机构与公钥基础设施"><a href="#18-5-证书、证书办法机构与公钥基础设施" class="headerlink" title="18.5 证书、证书办法机构与公钥基础设施"></a>18.5 证书、证书办法机构与公钥基础设施</h2><h3 id="18-5-1-公钥证书、证书颁发机构与X-509标准"><a href="#18-5-1-公钥证书、证书颁发机构与X-509标准" class="headerlink" title="18.5.1 公钥证书、证书颁发机构与X.509标准"></a>18.5.1 公钥证书、证书颁发机构与X.509标准</h3><h3 id="18-5-2-验证与撤销证书"><a href="#18-5-2-验证与撤销证书" class="headerlink" title="18.5.2 验证与撤销证书"></a>18.5.2 验证与撤销证书</h3><h3 id="18-5-3-属性证书"><a href="#18-5-3-属性证书" class="headerlink" title="18.5.3 属性证书"></a>18.5.3 属性证书</h3><h2 id="18-6-TCP-IP安全协议与分层"><a href="#18-6-TCP-IP安全协议与分层" class="headerlink" title="18.6 TCP/IP安全协议与分层"></a>18.6 TCP/IP安全协议与分层</h2><h2 id="18-7-网络访问控制：802-1X，802-1AE，EAP-PANA"><a href="#18-7-网络访问控制：802-1X，802-1AE，EAP-PANA" class="headerlink" title="18.7 网络访问控制：802.1X，802.1AE，EAP,PANA"></a>18.7 网络访问控制：802.1X，802.1AE，EAP,PANA</h2><h3 id="18-7-1-EAP方法与密钥派生"><a href="#18-7-1-EAP方法与密钥派生" class="headerlink" title="18.7.1 EAP方法与密钥派生"></a>18.7.1 EAP方法与密钥派生</h3><h3 id="18-7-2-EAP重新认证协议"><a href="#18-7-2-EAP重新认证协议" class="headerlink" title="18.7.2 EAP重新认证协议"></a>18.7.2 EAP重新认证协议</h3><h3 id="18-7-3-网络接入认证信息承载协议"><a href="#18-7-3-网络接入认证信息承载协议" class="headerlink" title="18.7.3 网络接入认证信息承载协议"></a>18.7.3 网络接入认证信息承载协议</h3><h2 id="18-8-第3层IP安全（IPsec）"><a href="#18-8-第3层IP安全（IPsec）" class="headerlink" title="18.8 第3层IP安全（IPsec）"></a>18.8 第3层IP安全（IPsec）</h2><h3 id="18-8-1-Internet密钥交换协议（IKEv2）"><a href="#18-8-1-Internet密钥交换协议（IKEv2）" class="headerlink" title="18.8.1 Internet密钥交换协议（IKEv2）"></a>18.8.1 Internet密钥交换协议（IKEv2）</h3><h3 id="18-8-2-认证头部"><a href="#18-8-2-认证头部" class="headerlink" title="18.8.2 认证头部"></a>18.8.2 认证头部</h3><h3 id="18-8-3-封装安全负载"><a href="#18-8-3-封装安全负载" class="headerlink" title="18.8.3 封装安全负载"></a>18.8.3 封装安全负载</h3><h3 id="18-8-4-组播"><a href="#18-8-4-组播" class="headerlink" title="18.8.4 组播"></a>18.8.4 组播</h3><h3 id="18-8-5-L2TP-IPsec"><a href="#18-8-5-L2TP-IPsec" class="headerlink" title="18.8.5 L2TP/IPsec"></a>18.8.5 L2TP/IPsec</h3><h3 id="18-8-6-IPsec-NAT穿越"><a href="#18-8-6-IPsec-NAT穿越" class="headerlink" title="18.8.6 IPsec NAT穿越"></a>18.8.6 IPsec NAT穿越</h3><h3 id="18-8-7-例子"><a href="#18-8-7-例子" class="headerlink" title="18.8.7 例子"></a>18.8.7 例子</h3><h2 id="18-9-传输层安全（TLS和DTLS）"><a href="#18-9-传输层安全（TLS和DTLS）" class="headerlink" title="18.9 传输层安全（TLS和DTLS）"></a>18.9 传输层安全（TLS和DTLS）</h2><h3 id="18-9-1-TLS-1-2"><a href="#18-9-1-TLS-1-2" class="headerlink" title="18.9.1 TLS 1.2"></a>18.9.1 TLS 1.2</h3><h3 id="18-9-2-DTLS"><a href="#18-9-2-DTLS" class="headerlink" title="18.9.2 DTLS"></a>18.9.2 DTLS</h3><h2 id="18-10-DNS安全（DNSSEC）"><a href="#18-10-DNS安全（DNSSEC）" class="headerlink" title="18.10 DNS安全（DNSSEC）"></a>18.10 DNS安全（DNSSEC）</h2><h3 id="18-10-1-DNSSEC资源记录"><a href="#18-10-1-DNSSEC资源记录" class="headerlink" title="18.10.1 DNSSEC资源记录"></a>18.10.1 DNSSEC资源记录</h3><h3 id="18-10-2-DNSSEC运行"><a href="#18-10-2-DNSSEC运行" class="headerlink" title="18.10.2 DNSSEC运行"></a>18.10.2 DNSSEC运行</h3><h3 id="18-10-3-事物认证（TSIG-TKEY-SIC-0-）"><a href="#18-10-3-事物认证（TSIG-TKEY-SIC-0-）" class="headerlink" title="18.10.3 事物认证（TSIG,TKEY,SIC(0)）"></a>18.10.3 事物认证（TSIG,TKEY,SIC(0)）</h3><h3 id="18-10-4-带有DNS64的DNSSEC"><a href="#18-10-4-带有DNS64的DNSSEC" class="headerlink" title="18.10.4 带有DNS64的DNSSEC"></a>18.10.4 带有DNS64的DNSSEC</h3><h2 id="18-11-域名密钥识别邮件"><a href="#18-11-域名密钥识别邮件" class="headerlink" title="18.11 域名密钥识别邮件"></a>18.11 域名密钥识别邮件</h2><h3 id="18-11-1-DKIM签名"><a href="#18-11-1-DKIM签名" class="headerlink" title="18.11.1 DKIM签名"></a>18.11.1 DKIM签名</h3><h3 id="18-11-2-例子"><a href="#18-11-2-例子" class="headerlink" title="18.11.2 例子"></a>18.11.2 例子</h3><h2 id="18-12-与安全协议相关的攻击"><a href="#18-12-与安全协议相关的攻击" class="headerlink" title="18.12 与安全协议相关的攻击"></a>18.12 与安全协议相关的攻击</h2><h2 id="18-13-总结"><a href="#18-13-总结" class="headerlink" title="18.13 总结"></a>18.13 总结</h2><h2 id="18-14-参考文献"><a href="#18-14-参考文献" class="headerlink" title="18.14 参考文献"></a>18.14 参考文献</h2><h1 id="缩略语"><a href="#缩略语" class="headerlink" title="缩略语"></a>缩略语</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机类 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer-networks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_Demo_1.0</title>
      <link href="2020/11/02/Java%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B01-0/"/>
      <url>2020/11/02/Java%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B01-0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Ch4Demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.设计一个时间类Ch4Demo1,这个类包含： </span></span><br><span class="line"><span class="comment"> * （1）表示时间的数据域hour、minute和second;</span></span><br><span class="line"><span class="comment"> * （2）一个以当前时间创建Ch4Demo1对象的无参构造方法（数据域的值表示当前时间）；</span></span><br><span class="line"><span class="comment"> * （3）一个构造Ch4Demo1对象的构造方法，这个对象有一个特定的时间值，这个值是以毫秒表示的、从1970年1月1日午夜开始到现在流逝的时间段（数据域的值表示这个时间）；</span></span><br><span class="line"><span class="comment"> * （4）一个构造带特定的小时、分钟和秒的Ch4Demo1对象的构造方法； </span></span><br><span class="line"><span class="comment"> * （5）三个数据域hour、minute和second各自的get方法；</span></span><br><span class="line"><span class="comment"> * （6）一个名为setTime(long elapseTime)的方法使用流逝的时间给对象设置一个新时间。</span></span><br><span class="line"><span class="comment"> * 例如，如果流逝的时间为555550000毫秒，则转换为10小时、10分钟、10秒。 编写一个测试程序，创建两个Ch4Demo1对象（使用new</span></span><br><span class="line"><span class="comment"> * Ch4Demo1()和new Ch4Demo1(555550000)）,然后显示它们的小时、分钟和秒。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> AllenChen</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ch4Demo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（1）表示时间的数据域hour、minute和second;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> hour;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> minute;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> second;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）一个以当前时间创建Ch4Demo1对象的无参构造方法（数据域的值表示当前时间）；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Ch4Demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//System.currentTimeMillis()是GMT时间，GMT是中央时区,北京在东8区,相差8个小时。</span></span><br><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis() + <span class="number">8</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">second = (time / <span class="number">1000</span>) % <span class="number">60</span>;</span><br><span class="line">minute = (time / <span class="number">1000</span> / <span class="number">60</span>) % <span class="number">60</span>;</span><br><span class="line">hour = (time / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span>) % <span class="number">24</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）一个构造Ch4Demo1对象的构造方法，这个对象有一个特定的时间值，这个值是以毫秒表示的、从1970年1月1日午夜开始到现在流逝的时间段（数据域的值表示这个时间）；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Ch4Demo1</span><span class="params">(<span class="keyword">long</span> ElapseTime)</span> </span>&#123;</span><br><span class="line">second = (ElapseTime / <span class="number">1000</span>) % <span class="number">60</span>;</span><br><span class="line">minute = (ElapseTime / <span class="number">1000</span> / <span class="number">60</span>) % <span class="number">60</span>;</span><br><span class="line">hour = (ElapseTime / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span>) % <span class="number">24</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（4）一个构造带特定的小时、分钟和秒的Ch4Demo1对象的构造方法； </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Ch4Demo1</span><span class="params">(<span class="keyword">long</span> hour, <span class="keyword">long</span> minute, <span class="keyword">long</span> second)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.hour = hour;</span><br><span class="line"><span class="keyword">this</span>.minute = minute;</span><br><span class="line"><span class="keyword">this</span>.second = second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（5）三个数据域hour、minute和second各自的get方法；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getHour</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> hour;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMinute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> minute;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（6）一个名为setTime(long elapseTime)的方法使用流逝的时间给对象设置一个新时间。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">long</span> elapseTime)</span> </span>&#123;</span><br><span class="line">second = (elapseTime / <span class="number">1000</span>) % <span class="number">60</span>;</span><br><span class="line">minute = (elapseTime / <span class="number">1000</span> / <span class="number">60</span>) % <span class="number">60</span>;</span><br><span class="line">hour = (elapseTime / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span>) % <span class="number">24</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如，如果流逝的时间为555550000毫秒，则转换为10小时、10分钟、10秒。</span></span><br><span class="line"><span class="comment">//编写一个测试程序，创建两个Ch4Demo1对象（使用new Ch4Demo1()和new Ch4Demo1(555550000)）,</span></span><br><span class="line"><span class="comment">//然后显示它们的小时、分钟和秒。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Ch4Demo1 c = <span class="keyword">new</span> Ch4Demo1();</span><br><span class="line">Ch4Demo1 c1 = <span class="keyword">new</span> Ch4Demo1(<span class="number">555550000</span>);</span><br><span class="line">System.out.println(c.hour + <span class="string">&quot;:&quot;</span> + c.minute + <span class="string">&quot;:&quot;</span> + c.second);</span><br><span class="line">System.out.println(c1.hour + <span class="string">&quot;:&quot;</span> + c1.minute + <span class="string">&quot;:&quot;</span> + c1.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Java </category>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络名词英文缩写解释</title>
      <link href="2020/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%8D%E8%AF%8D%E8%8B%B1%E6%96%87%E7%BC%A9%E5%86%99%E8%A7%A3%E9%87%8A/"/>
      <url>2020/11/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%8D%E8%AF%8D%E8%8B%B1%E6%96%87%E7%BC%A9%E5%86%99%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="英文缩写"><a href="#英文缩写" class="headerlink" title="英文缩写"></a>英文缩写</h1><h1 id="按首字母排列"><a href="#按首字母排列" class="headerlink" title="按首字母排列"></a>按首字母排列</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><ol><li>ACK（ACKnowledgement）：确认</li><li>ADSL（Asymmetric Digital Subscriber Line）：非对称数字用户线</li><li>AES（Advanced Encryption Standard）：先进的加密标准</li><li>AF PHB（Assured Forwarding Per-Hop Behavior）：确保转发每跳行为（也可标记为AF）</li><li>AH（Authentication Header）：鉴别首部</li><li>AIMD（Additive Increase Multiplicative Decrease）：加法增大乘法减小</li><li>AN（Access Network）：接入网</li><li>ANSI（American National Standards Institute）：美国国家标准协会</li><li>AP（Access Point）：接入点</li><li>AP（Application）: 应用程序</li><li>API（Application Programming Interface）：应用编程接口</li><li>APNIC（Asia Pacific Network Informationg Center）：亚太网络信息中心</li><li>ARIN（American Registry for Internet Numbers）：美国互联网号码注册机构</li><li>ARP（Address Resolution Protocol）：地址解析协议</li><li>ARPA（Advanced Research Project Agency）：美国国防部远景研究规划局（高级研究计划署）</li><li>ARQ（Automatic Repeat reQuest）：自动重传请求</li><li>AS（Autonomous System）：自治系统</li><li>AS（Authentication Server）：鉴别服务器</li><li>ASCII（American Standard Code for Information Interchange）:美国信息交换标准码</li><li>ASN（Autonomous System Number）：自治系统号</li><li>ASN.1（Abstract Syntax Notation One）：抽象语法记法 1</li><li>ATM（Asynchronous Transfer Mode）：异步传递方式</li><li>ATU（Access Termination Unit）：接入端接单元</li><li>ATU-C（Access Termination Unit Central Office）：端局接入端接单元</li><li>ATU-R（Access Termination Unit Remote）：远端接入端接单元</li><li>AVT WG（Audio/Video Transport Working Group）：音频/视频运输工作组</li><li>AWT（Abstract Window Toolkit）：抽象窗口工具箱</li></ol><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><ol><li>Bcc（Blind carbon copy）：盲复写副本</li><li>BER（Bit Error Rate）：误码率</li><li>BER（Basic Encoding Rule）：基本编码规则</li><li>BGP（Border Gateway Protocol）：边界网关协议</li><li>BOOTP（BOOTstrap Protocol）：引导程序协议</li><li>BSA（Basic Service Area）：基本服务区</li><li>BSC（Base Station Controller）：基站控制器</li><li>BSS（Basic Service Set）：基本服务集</li><li>BSSID（Basic Service Set ID）：基本服务集标识符</li><li>BT（BitTorrent）：一种P2P应用程序</li></ol><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><ol><li>CA（Certificate Authority）：认证中心</li><li>CA（Collision Avoidance）：碰撞避免</li><li>CATV（Community Antenna Television(TV)，CAble TV）：有限电视</li><li>CBT（Core-based Tree）：基于核心的转发树</li><li>Cc（Carbon Copy）：复写副本</li><li>CCIR（Consultative Committee，International Radio）：国际无线电咨询委员会</li><li>CCITT（Consultative Committee，International Telephone and Telegraph）：国际电报电话咨询委员会</li><li>CDM（Code Division Multiplexing）：码分复用</li><li>CDMA（Code Division Multiple Access）：码分多址</li><li>CE（Consumer Electronics）：消费电子设备</li><li>CFI（Canonical Format Indicator）：规范格式指示符</li><li>CGI（Common Gateway Interface）：通用网关接口</li><li>CHAP（Challenge-Handshake Authentication Protocol）：口令握手鉴别协议</li><li>CIDR（Classless InterDomain Routing）：无分类域间路由选择</li><li>CNAME（Canonical NAME）：规范名</li><li>CNNIC（China Internet Network Information Center）：中国互联网络信息中心</li><li>CRC（Cyclic Redundancy Check）：循环冗余校验</li><li>CS-ACELP（(Conjugate-Structure Algebraic-Code-Excited Linear Predication）：共轭结构码激励线性预测（声码器）</li><li>CSMA/CD（Carrier Sense Multiple Access / Collision Detection）：载波侦听多点接入/冲突检测</li><li>CSMA/CA（Carrier Sense Multiple Access / Collision Avoid）：载波侦听多点接入/冲突避免</li><li>CSRC（Contributing SouRCe identifier）：参与源标识符</li><li>CSS（Cascading Style Sheets）：层叠样式表</li><li>CTS（Clear to Send）：允许发送</li></ol><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><ol><li>DACS（Digital Access and Cross-connect System）：数字交接系统</li><li>DARPA（Defense Advanced Research Projects Agency）：美国国防部远景规划局（高级研究署）</li><li>DCF（Distributed Coordination Function）：分布协调功能</li><li>DDoS（Distributed Denial of service）：分布式拒绝服务，分布式拒绝服务攻击</li><li>BES（Data Encryption Standard）：数据加密标准</li><li>DF（Don’t Fragment）：不能分片</li><li>DHCP（Dynamic Host Configuration Protocol）：动态主机配置协议</li><li>DiffServ（Differentiated Services）：区分服务</li><li>DIFS（Distributed Coordination Function Inter-Frame Space（IFS））：分布协调功能帧间间隔</li><li>DLCI（Data Link Connection Identifier）：数据链路连接标识符</li><li>DMT（Discrete Multi-Tone）：离散多音（调制）</li><li>DNS（Domain Name System）：域名系统</li><li>DOCSIS（Data Over Cable Service Interface Specifications）：电缆数据服务接口规约，有线电缆数据服务接口规范</li><li>DoS（Denial of Service）：拒绝服务，拒绝服务攻击</li><li>DS（Distribution System）：分配系统</li><li>DS（Differentiated Services）：区分服务（也写作DiffServ）</li><li>DSCP（Differentiated Services Code Point）：区分服务码点，差分服务代码点</li><li>DSL（Digital Subscriber Line）：数字用户线，数字用户线路</li><li>DSLAM（Digital Subscriber Line Access Multiplexer）：数字用户线路接入复用器</li><li>DSSS（Direct Sequence Spread Spectrum）：直接序列扩频</li><li>DVMRP（Distance Vector Multicast Routing Protocol）：距离向量多播路由选择协议，距离矢量组播路由选择协议</li><li>DWDM（Dense Wavelength Division Multiplexing（WDM））：密集波分复用，密集型光波复用</li></ol><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><ol><li>EBCDIC（Extended Binary Coded Decimal Interchange Code）：扩充的二 / 十进制交换码，广义二进制编码的十进制交换码</li><li>EDFA（Erbium Doped Fiber Amplifier）： 掺铒光纤放大器</li><li>EDGE（Enhanced Data Rate for GSM Evolution）：增强型数据速率GSM演进</li><li>EFM（Ethernet in the First Mile）：第一英里的以太网</li><li>EF PHB（Expedited Forwarding Per-Hop Behavior（PHB））：迅速转发每跳行为（也可记为EF）</li><li>EGP（External Gateway Protocol）：外部网关协议</li><li>EIA（Electronic Industries Association）：美国电子工业协会</li><li>EOT（End Of Transmission）：传输结束</li><li>EPON（Ethernet Passive Optical Network（PON））：以太网无源光网络</li><li>ESMTP（Extended Simple Mail Transfer Protocol（SMTP））：扩充的简单邮件传送协议</li><li>ESP（Encapsulating Security Payload）：封装安全有效载荷</li><li>ESS（Extended Service Set）：扩展的服务集</li><li>ETSI（European Telecommunications Standards Institute）：欧洲电信标准化协会</li><li>EUI（Extended Unique Identifier）：扩展的惟一标识符</li></ol><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><ol><li>FC（Fiber Channel）：光纤通道</li><li>FCS（Frame Check Sequence）：帧检验序列</li><li>FDDI（Fiber Distributed Data Interface）：光纤分布式数据接口</li><li>FDM（Frequency Division Multiplexing）：频分复用</li><li>FEC（Forwarding Equivalence Class）：转发等价类</li><li>FEC（Forward Error Correction）：前向纠错</li><li>FECN（Forward Explicit Congestion Notification）：前向显式拥塞通知</li><li>FFD（Full-Function Device）：全功能设备</li><li>FHSS（Frequency Hopping Spread Spectrum）：跳频扩频</li><li>FIFO（First In First Out）：先进先出</li><li>FOIRL（Fiber Optic Inter-Repeater Link）：转发器间的光纤链路</li><li>FQ（Fair Queuing）：公平排队</li><li>FR（Frame Relay）：帧中继</li><li>FSK（Frequency Shift Keying）：移频键控</li><li>FTP（File Transfer Protocol）：文件传送协议</li><li>FTTB（Fiber To The Building）：光纤到大楼</li><li>FTTC（Fiber To The Curb）：光纤到路边</li><li>FTTD（Fiber To The Door）：光纤到门户</li><li>FTTF（Fiber To The Floor）：光纤到楼层</li><li>FTTH（Fiber To The Home）：光纤到家</li><li>FTTH（Fiber To The Neighbor）：光纤到邻区</li><li>FTTO（Fiber To The Office）：光纤到办公室</li><li>FTTZ（Fiber To The Zone）：光纤到小区</li></ol><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><ol><li>GCRA（Generic Cell Rate Algorithm）：一般信元速率算法</li><li>GGSN（Gateway GPRS Support Node）：网关GPRS支持节点</li><li>GIF（Graphics Interchange Format）：图形交换格式</li><li>GII（Global Information Infrastructure）：全球信息基础结构，全球信息基础设施 </li><li>G/L（Global/Local）：全球/本地管理（位）</li><li>GFC（Generic Flow Control）：通用流量控制</li><li>GMSK（Gaussian Filtered Minimum Shift Keying）：高斯滤波最小频移键控</li><li>GPON（Gigabit PON）：吉比特无源光网络</li><li>GPRS（General Packet Radio Service）：通用分组无线服务</li><li>GSM（Global System for Mobile （Communications））：全球移动通信系统，GSM体制</li><li>GSM（Group Special Mobile）：群组专用移动通信体制</li></ol><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><ol><li>HDLC（High-level Data Link Control）：高级数据链路控制</li><li>HDSL（High speed DSL）：高速数字用户线</li><li>HEC（Header Error Control）：首部差错控制</li><li>HFC（Hybrid Fiber Coax）：光纤同轴混合（网）</li><li>HIPPI（HIgh-Performance Parallel Interface）：高性能并行接口</li><li>HLR（Home Location Register）：归属位置寄存器</li><li>HR-DSSS（High Rate DirectSequence Spread Spectrum）：高速直接序列扩频</li><li>HSSG（High Speed Study Group）：高速研究组</li><li>HTML（HyperText Markup Language）：超文本标记语言</li><li>HTTP（HyperText Transfer Protocol）：超文本传送协议</li></ol><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><ol><li>IAB（Internet Architecture Board）：互联网体系结构委员会，因特网体系结构委员会</li><li>IAC（Interpret As Command）：作为命令解释</li><li>IAHC（Internet International Ad Hoc Committee）：因特网国际特别委员会</li><li>IANA（Internet Assigned Numbers Authority）：互联网赋号管理局，因特网号码指派管理局</li><li>ICANN（Internet Corporation for Assigned Names and Numbers）：互联网名字和数字分配机构，因特网名字与号码指派公司</li><li>ICMP（Internet Control Message Protocol）：网际控制报文协议，因特网控制报文协议</li><li>IDEA（International Data Encryption Algorithm）：国际数据加密算法</li><li>IDS（Intrusion Detection System）：入侵检测系统</li><li>IEEE（Institute of Electrical and Electronics Engineers）：（美国）电气和电子工程师协会</li><li>IESG（Internet Engineering Steering Group）：互联网工程指导小组，因特网工程指导小组</li><li>IETF（Internet Engineering Task Force）：因特网工程部</li><li>IFS（(Inter Frame Space）：帧间间隔</li><li>I/G（Individual/Group）：单个站/组地址（位）</li><li>IGMP（Internet Group Management Protocol）：网际组管理协议，因特网组管理协议</li><li>IGP（Interior Gateway Protocol）：内部网关协议</li><li>IKE（Internet Key Exchange）：互联网密钥交换</li><li>IM（Instant Messaging）：即时传信</li><li>IMAP（Internet Message Access Protocol）：网际报文存取协议，因特网报文存取协议</li><li>IMP（Interface Message Processor）：接口报文处理机</li><li>IND（Inverse-Neighbor-Discovery）：反向邻站发现</li><li>IntServ（Integrated Services）：综合服务</li><li>IP（Internet Protocol）：网际协议</li><li>IPCP（IP Control Protocol）：IP控制协议</li><li>IPNG（IP Next Generation）：下一代的IP</li><li>IPOA（IP Over ATM）：IP在ATM上运行</li><li>IPRA（Internet Policy Registration Authority）：互联网政策登记管理机构，因特网政策登记机关</li><li>IPsec（IP security）：IP 安全协议 </li><li>IPX（Internet Packet Exchange）：Novell 公司的一种连网协议</li><li>IR（InfraRed）：红外技术</li><li>IRSG（Internet Research Steering Group）：互联网研究指导小组，因特网研究指导组</li><li>IRTF（Internet Research Task Force）：互联网研究部</li><li>ISAKMP（Internet Secure Association and Key Management Mechanism）：互联网安全相关和密钥管理协议</li><li>ISDN（Integrated Services Digital Network）：综合业务数字网</li><li>ISO（International Organization for Standardization）：国际标准化组织</li><li>ISOC（Internet Society）：因特网协会</li><li>ISM（Industrial，Scientific,and Medical）：工业、科学与医学（频段）</li><li>ISP（Internet Service Provider）：互联网服务提供者，因特网服务提供者</li><li>ITU（International Telecommunication Union）：国际电信联盟</li><li>ITU-T（ITU Telecommunication Standardization Sector）：国际电信联盟电信标准化部门</li></ol><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><ol><li>JPEG（Joint Photographic Expert Group）：联合图像专家组标准</li><li>JVM（Java Virtual Machine）：Java虚拟机</li></ol><h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><ol><li>KDC（Key Distribution Center）：密钥分配中心</li></ol><h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><ol><li>LACNIC（Latin American and Caribbean Network Internet Center）：拉美与加勒比海网络信息中心</li><li>LAN（Local Area Network）：局域网</li><li>LANE（LAN Emulation）：局域网仿真</li><li>LAPB（Link Access Procedure Balanced）： 链路接入规程（平衡型）</li><li>LCP（Link Control Protocol）：链路控制协议</li><li>LDP（Label Distribution Protocol）：标记分配协议</li><li>LED（Light Emitting Diode）：发光二极管</li><li>LMDS（Local Multipoint Distribution Services）：本地多点分配系统，区域多点传输服务</li><li>LLC（Logical Link Control）：逻辑链路控制</li><li>LoS（Line of Sight）：视距</li><li>LPC（Linear Predictive Coding）：线性预测编码</li><li>LSP（Label Switched Path）：标记交换路径</li><li>LSR（Label Switching Router）：标记交换路由器</li><li>LTE（Long-Term Evolution）：长期演进</li></ol><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><ol><li>MAC（Medium Access Control）：媒体接入控制，介质访问控制</li><li>MAC（Message Authentication Code）：报文鉴别码</li><li>MACA（Multiple Access with Collision Avoidance）：具有碰撞避免的多点接入</li><li>MAGIC（Mobile multimedia， Anytime/any-where, Global mobility support, Integrated wireless and Customized personal service）：移动多媒体、任何时间/地点、支持全球移动性、综合无线和制定的个人服务</li><li>MAN（Metropolitan Area Network）：城域网</li><li>MANET（Mobile Ad-hoc NETworks）：移动自组网络的工作组</li><li>MAU（Medium Access Unit）：媒体访问单元</li><li>MBONE（Multicast Backbone On the InterNEt）：多播主干网</li><li>MCU （Multipoint Control Unit）：多点控制单元</li><li>MD（Message Digest）：报文摘要</li><li>MF（More Fragment）：还有分片</li><li>MFTP（Multisource File Transfer Protocol）：多源文件传输协议</li><li>MIB（Management Information Base）：管理信息库</li><li>MIME（Multipurpose Internet Mail Extensions）：通用互联网邮件扩充</li><li>MIMO（Multiple Input Multiple Output）：多入多出</li><li>MIPS（Million Instructions Per Second）：百万指令每秒</li><li>MLD（Multicast Listener Delivery）：多播听众交付</li><li>MMUSIC（Multiparty MUltimedia SessIon Control）：多参与者多媒体会话控制</li><li>MOSPF（Multicast extensions to OSPF）：开放最短通路优先的多播扩展</li><li>MP3（MPEG Audio layer-3）：一种音频压缩标准</li><li>MPEG（Motion Picture Experts Group）：活动图像专家组</li><li>MPLS（MultiProtocol Label Switching：）多协议标记交换</li><li>MPPS（Million Packets Per Second）：百万分组每秒</li><li>MRU（Maximum Receive Unit）：最大接收单元</li><li>MSC（Mobile Switching Center）：移动交换中心</li><li>MSL（Maximum Segment Lifetime）：最长报文段寿命</li><li>MSRN（Mobile Station Roaming Number）：移动站漫游号码</li><li>MSS（Maximum Segment Size）：最长报文段</li><li>MTU（Maximum Transfer Unit）：最大传送单元</li></ol><h2 id="N"><a href="#N" class="headerlink" title="N"></a>N</h2><ol><li>NAP（Network Access Point）：网络接入点</li><li>NAT（Network Address Translation）：网络地址转换</li><li>NAV（Network Allocation Vector）：网络分配向量</li><li>NCP（Network Control Protocol）：网络控制协议</li><li>ND（Neighbor-Discovery）：邻站发现</li><li>NFS（Network File System）：网络文件系统</li><li>NGI（Next Generation Internet）：下一代互联网</li><li>NGN（Next Generation Network）：下一代电信网</li><li>NIC（Network Interface Card）：网络接口卡、网卡</li><li>NLA（Next-Level Aggregation）：下一级聚合</li><li>NLRI（Network Layer Reachability Information）：网络层可达性信息</li><li>NOC（Network Operations Center）：网络运行中心</li><li>NSAP（Network Service Access Point）：网络层服务访问点</li><li>NSF（National Science Foundation）：（美国）国家科学基金会</li><li>NVT（Network Virtual Terminal）：网络虚拟终端</li></ol><h2 id="O"><a href="#O" class="headerlink" title="O"></a>O</h2><ol><li>OC（Optical Carrier）：光载波</li><li>ODN（Optical Distribution Network）：光配线网</li><li>ODN（Optical Distribution Node）：光分配结点</li><li>OFDM（Orthogonal Frequency Division Multiplexing）：正交频分复用</li><li>OLT（Optical Line Terminal）：光线路终端</li><li>ONU（Optical Network Unit）：光网络单元</li><li>OSI/RM（Open Systems Interconnection Reference Model）：开放系统互连基本参考模型</li><li>OSPF（Open Shortest Path First）：开放最短通路优先</li><li>OUI（Organizationally Unique Identifier）：机构唯一标识符</li></ol><h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><ol><li>P2P（Peer-to-Peer）：对等方式</li><li>PAN（Personal Area Network）：个人区域网</li><li>PAP（Password Authentication Protocol）：口令鉴别协议</li><li>PARC（Polo Alto Research Center）：（美国施乐公司（XEROX）的）PARC研究中心</li><li>PAWS（Protect Against Wrapped Sequence numbers）：防止序号绕回</li><li>PCA（Policy Certification Authority）：政策认证中心</li><li>PCF（Point Coordination Function）：点协调功能</li><li>PCM（Pulse Code Modulation）：脉码调制</li><li>PCMCIA（Personal Computer Memory Card Interface Adapter）：个人计算机存储器卡接口适配器</li><li>PDA（Personal Digital Assistant）：个人数字助理</li><li>PDF（Portable Document Forment）：轻便文档格式</li><li>PDU（Protocol Data Unit）：协议数据单元</li><li>PEM（Privacy Enhanced Mail）：互联网的正式邮件加密标准</li><li>PGP（Pretty Good Privacy）：一种电子邮件加密技术</li><li>PHB（Per-Hop Behavior）：每跳行为</li><li>PIFS（Point Coordination Function IFS）：点协调功能帧间间隔</li><li>PIM-DM（Protocol Independent Multicast-Dense Mode）：协议无关多播-密集方式</li><li>PIM-SM（Protocol Independent Multicast-Sparse Mode）：协议无关多播-稀疏方式</li><li>PING（Packet InterNet Groper）：分组网间探测，乒程序，ICMP的一种应用</li><li>PK（public key）：公钥，公开密钥</li><li>PKI（Public Key Infrastructure）：公钥基础结构</li><li>PLMN（Public Land Mobile Network）：公共陆地移动网络</li><li>PON（Passive Optical Network）：无源光网络</li><li>PoP（Point of Presence）：汇接点</li><li>POP（Post Office Protocol）：邮局协议</li><li>POTS（Plain Old Telephone Service）：传统电话</li><li>PPP（Point-to-Point Protocol）：点对点协议</li><li>PPPoE（Point-to-Point Protocol over Ethernet）：以太网上的点对点协议</li><li>PS（POTS Splitter）：电话分离器</li><li>PTE（Path Terminating Element）：路径端接设备</li></ol><h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><ol><li>QAM（Quadrature Amplitude Modulation）：正交幅度调制</li><li>QoS（Quality of Service）：服务质量</li><li>QPSK（Quarternary Phase Shift Keying或Quadrature Phase Shift Keying）：正交相移键控</li></ol><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><ol><li>RA（Registration Authority）：注册管理机构</li><li>RARP（Reverse Address Resolution Protocol）：逆地址解析协议</li><li>RAS（Registration/Admission/Status）：登记/接纳/状态</li><li>RED（Random Early Detection）：随机早期检测</li><li>RED（Random Early Discard，Random Early Drop）：随机早期丢弃</li><li>RESV（RESerVation）：预留</li><li>RFC（Request For Comments）：请求评论</li><li>RFD（Reduced-Function Device）：精简功能设备</li><li>RG（Research Group）：研究组</li><li>RIP（Routing Information Protocol）：路由信息协议</li><li>RIPE（法文表示的European IP Network）：欧洲的IP网络</li><li>RPB（Reverse Path Broadcasting）：反向路径广播</li><li>RR（Receiver Report）：接收端报告（分组）</li><li>RSA（Rivest，Shamir and Adleman）：用三个人名表示的一种公开密钥算法的名称，</li><li>RSVP（Resource reSerVation Protocol）：资源预留协议</li><li>RTCP（Real-time Transfer Control Protocol）：实时传送控制协议</li><li>RTO（Retransmission Time-Out）：超时重传时间</li><li>RTP（Real-time Transport Protocol）：实时运输协议</li><li>RTS（Request To Send）：请求发送</li><li>RTSP（Real-Time Streaming Protocol）：实时流式协议</li><li>RTT （Round-Trip Time）：往返时间</li></ol><h2 id="S"><a href="#S" class="headerlink" title="S"></a>S</h2><ol><li>SA（Security Association）：安全关联</li><li>SACK（Selective ACK）：选择确认</li><li>SAD（Security Association Database）：安全关联数据库</li><li>SAP（Service Access Point）：服务访问点</li><li>SCTP（Stream Control Transmission Protocol）：流控制传输协议</li><li>SDH（Synchronous Digital Hierarchy）：同步数字系列</li><li>SDP（Session Description Protocol）：会话描述协议</li><li>SDSL（Single-line DSL）：1对线的数字用户线</li><li>SDU（Service Data Unit）：服务数据单元</li><li>SET（Secure Electronic Transaction）：安全电子交易</li><li>SGSN（Serving GPRS Support Node）：GPRS服务支持结点</li><li>SHA（Secure Hash Algorithm）：安全散列算法</li><li>SIFS（Short IFS）：短帧间间隔</li><li>SIM（Subscriber Identity Module）：用户身份识别卡</li><li>SIP（Session Initiation Protocol）：会话发起协议</li><li>SK（Secret Key）：秘钥</li><li>SKEME（Secure Key Exchange Mechanism）：安全密钥交换机制</li><li>SLA（Service Level Agreement）：服务等级协定</li><li>SMI（Structure of Management Information）：管理信息结构</li><li>SMTP（Simple Mail Transfer Protocol）：简单邮件传送协议</li><li>SNA（System Network Architecture）：系统网络体系结构</li><li>SNMP（Simple Network Management Protocol）：简单网络管理协议</li><li>SOH（Start Of Header）：首部开始</li><li>SONET（Synchronous Optical Network）：同步光纤网</li><li>SPD（Security Policy Database）：安全策略数据库</li><li>SPI（Security Parameter Index）：安全参数索引</li><li>SR（Sender Reporting）：发送端报告（分组）</li><li>SRA（Seamless Rate Adaptation）：无缝速率自适应技术</li><li>SSID（Service Set IDentifier）：服务集标识符</li><li>SSL（Secure Socket Layer）：安全插口层，或安全套接层（协议）</li><li>SSRC（Synchronous SouRCe identifier）：同步源标识符</li><li>STDM（Statistic TDM）：统计时分复用</li><li>STM（Synchronous Transfer Module）：同步传递模块</li><li>STP（Shielded Twisted Pair）：屏蔽双绞线</li><li>STS（Synchronous Transport Signal）：同步传送信号</li></ol><h2 id="T"><a href="#T" class="headerlink" title="T"></a>T</h2><ol><li>TAG（TAG Switching）：标记交换</li><li>TCB（Transmission Control Block）：传输控制程序块</li><li>TCP（Transmission Control Protocol）：传输控制协议</li><li>TDM（Time Division Multiplexing）：时分复用</li><li>TD-SCDMA（Time Division-Synchronous CDMA）：时分同步的码分多址</li><li>TELNET（TELetype NETwork）：电传机网络，一种互联网的应用程序</li><li>TFTP（Trivial File Transfer Protocol）：简单文件传送协议</li><li>TGS（Ticket-Granting Server）：票据授予服务器</li><li>TIA（Telecommunications Industries Association）：电信行业协会</li><li>TLA（Top-Level Aggregation）：顶级聚合</li><li>TLD（Top Level Domain）：顶级域名</li><li>TLI（Transport Layer Interface）：运输层接口</li><li>TLS（Transport Layer Security）：运输层安全协议</li><li>TLV（Type-Length-Value）：类型-长度-值</li><li>TPDU（Transport Protocol Data Unit）：运输协议数据单元</li><li>TSS（Telecommunication Standardization Sector）：电信标准化部门</li><li>TTL（Time To Live）：生存时间，或寿命</li></ol><h2 id="U"><a href="#U" class="headerlink" title="U"></a>U</h2><ol><li>UA（User Agent）：用户代理</li><li>UAC（User Agent Client）：用户代理客户</li><li>UAS（User Agent Server）：用户代理服务器</li><li>UDP（User Datagram Protocol）：用户数据报协议</li><li>UIB（User Interface Box）：用户接口盒</li><li>URL（Uniform Resource Locator）：统一资源定位符</li><li>USIM（Universal Subscriber Identity Module）：通用用户身份识别卡</li><li>UTP（Unshielded Twisted Pair）：无屏蔽双绞线</li><li>UWB（Ultra-Wide Band）：超宽带</li></ol><h2 id="V"><a href="#V" class="headerlink" title="V"></a>V</h2><ol><li>VC（Virtual Circuit）：虚电路</li><li>VCI（Virtual Channel Identifier）：虚通路标识符</li><li>VDSL（Very high speed DSL）：甚高速数字用户线</li><li>VID（VLAN ID）：VLAN标识符</li><li>VLAN（Virtual LAN）：虚拟局域网</li><li>VLR（Visitor Location Register）：来访用户位置寄存器</li><li>VLSM（Variable Length Subnet Mask）：变长子网掩码</li><li>VoIP（Voice over IP）：在IP上的话音</li><li>VON（Voice On the Net）：在互联网上的话音</li><li>VPI（Virtual Path Identifier）：虚通道标识符</li><li>VPN（Virtual Private Network）：虚拟专用网</li><li>VRML（Virtual Reality Modeling Language）：虚拟现实建模语言</li><li>VSAT（Very Small Aperture Terminal）：甚小孔径地球站</li></ol><h2 id="W"><a href="#W" class="headerlink" title="W"></a>W</h2><ol><li>WAN（Wide Area Network）：广域网</li><li>WCDMA（Wideband CDMA）：宽带码分多址</li><li>WDM（Wavelength Division Multiplexing）：波分复用</li><li>WEP（Wired Equivalent Privacy）：有线等效保密</li><li>WFQ（Weighted Fair Queuing）：加权公平排队</li><li>WG（Working Group）：工作组</li><li>WGIG（Working Group on Internet Governance）：互联网治理工作组</li><li>Wi-Fi（Wireless-Fidelity）：无线保真度（无线局域网的同义词）</li><li>WiMAX（Worldwide interoperability for Microwave Access）：全球微波接入的互操作性，即WMAN。</li><li>WISP（Wireless Internet Service Provider）：无线互联网服务提供者</li><li>WLAN（Wireless Local Area Network）：无线局域网</li><li>WMAN（Wireless Metropolitan Area Network）：无线城域网</li><li>WPA（Wi-Fi Protected Access）：无线局域网受保护的接入</li><li>WPAN（Wireless Personal Area Network）：无线个人区域网</li><li>WSN（Wireless Sensor Network）：无线传感器网络</li><li>WWW（World Wide Web）：万维网</li><li>W3C（World Wide Web Consortium）：万维网联盟</li></ol><h2 id="X"><a href="#X" class="headerlink" title="X"></a>X</h2><ol><li>XHTML（Extensible HTML）：可扩展超文本标记语言</li><li>XML（Extensible Markup Language）：可扩展标记语言</li></ol><h2 id="Y"><a href="#Y" class="headerlink" title="Y"></a>Y</h2><ol><li><h2 id=""><a href="#" class="headerlink" title=""></a></h2></li></ol><h2 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h2><ol><li><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2></li></ol>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer-networks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重庆邮电大学2021年硕士研究生入学考试大纲解析笔记知识整理</title>
      <link href="2020/11/01/%E9%87%8D%E5%BA%86%E9%82%AE%E7%94%B5%E5%A4%A7%E5%AD%A62021%E5%B9%B4%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2%E8%A7%A3%E6%9E%90/"/>
      <url>2020/11/01/%E9%87%8D%E5%BA%86%E9%82%AE%E7%94%B5%E5%A4%A7%E5%AD%A62021%E5%B9%B4%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>重庆邮电大学2021年硕士研究生入学考试大纲（计算机类）<br>《计算机网络（803）》<br>参考书目：《计算机网络（第六版）谢希仁》。</p><p>《程序设计（F01）》<br>参考书目：《C语言程序设计（第三版）谭浩强，清华大学出版社》、《C++程序设计教程（第二版）钱能，清华大学出版社》。</p><p>《软件工程（J10）》<br>参考书目：《软件工程导论（第五版）张海藩，清华大学出版社》。</p><p>《数据库原理（J15）》<br>参考书目：《数据库系统概论（第四版）王珊、萨师煊，高等教育出版社》。</p><h1 id="《计算机网络（803）》考试大纲解析"><a href="#《计算机网络（803）》考试大纲解析" class="headerlink" title="《计算机网络（803）》考试大纲解析"></a>《计算机网络（803）》考试大纲解析</h1><h2 id="（一）概述"><a href="#（一）概述" class="headerlink" title="（一）概述"></a>（一）概述</h2><h3 id="1-计算机网络的定义"><a href="#1-计算机网络的定义" class="headerlink" title="1. 计算机网络的定义"></a>1. 计算机网络的定义</h3><p>   计算机网络是将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信设备与线路连接起来，由功能完善的软件（网络操作系统，网络管理软件及网络通信协议）的管理和协调下，实现资源共享和信息传递的计算机系统。</p><h3 id="2-计算机网络的功能"><a href="#2-计算机网络的功能" class="headerlink" title="2. 计算机网络的功能"></a>2. 计算机网络的功能</h3><ol><li>数据通信——是计算机网络的最基本的功能，可实现不同地理位置的计算机与终端、计算机与计算机之间的数据传输。</li><li>资源共享——计算机网络的主要目的，包括网络中软件、硬件和数据资源的共享，这是计算机网络最主要和最有吸引力功能。</li><li>分布式处理</li><li>可靠性高</li><li>负载均衡</li></ol><h3 id="3-计算机网络的拓扑结构的类型"><a href="#3-计算机网络的拓扑结构的类型" class="headerlink" title="3. 计算机网络的拓扑结构的类型"></a>3. 计算机网络的拓扑结构的类型</h3><h3 id="4-OSI-RM及其了解各层的功能"><a href="#4-OSI-RM及其了解各层的功能" class="headerlink" title="4. OSI/RM及其了解各层的功能"></a>4. OSI/RM及其了解各层的功能</h3><h3 id="5-TCP-IP参考类型"><a href="#5-TCP-IP参考类型" class="headerlink" title="5. TCP/IP参考类型"></a>5. TCP/IP参考类型</h3><h3 id="6-计算机网络协议、接口和服务的概念"><a href="#6-计算机网络协议、接口和服务的概念" class="headerlink" title="6. 计算机网络协议、接口和服务的概念"></a>6. 计算机网络协议、接口和服务的概念</h3><h3 id="7-计算机网络的主要性能指标：1）带宽-2）时延-3）时延带宽积-4）往返时延"><a href="#7-计算机网络的主要性能指标：1）带宽-2）时延-3）时延带宽积-4）往返时延" class="headerlink" title="7. 计算机网络的主要性能指标：1）带宽 2）时延 3）时延带宽积 4）往返时延"></a>7. 计算机网络的主要性能指标：1）带宽 2）时延 3）时延带宽积 4）往返时延</h3><h2 id="（二）物理层"><a href="#（二）物理层" class="headerlink" title="（二）物理层"></a>（二）物理层</h2><h3 id="1-物理层特性"><a href="#1-物理层特性" class="headerlink" title="1. 物理层特性"></a>1. 物理层特性</h3><h3 id="2-奈奎斯特定理和香农定理"><a href="#2-奈奎斯特定理和香农定理" class="headerlink" title="2. 奈奎斯特定理和香农定理"></a>2. 奈奎斯特定理和香农定理</h3><h3 id="3-光纤的优点及其两种模式"><a href="#3-光纤的优点及其两种模式" class="headerlink" title="3. 光纤的优点及其两种模式"></a>3. 光纤的优点及其两种模式</h3><h3 id="4-三种基本的调制方法"><a href="#4-三种基本的调制方法" class="headerlink" title="4. 三种基本的调制方法"></a>4. 三种基本的调制方法</h3><h3 id="5-曼彻斯特编码和差分曼彻斯特编码"><a href="#5-曼彻斯特编码和差分曼彻斯特编码" class="headerlink" title="5. 曼彻斯特编码和差分曼彻斯特编码"></a>5. 曼彻斯特编码和差分曼彻斯特编码</h3><h3 id="6-两种数字传输系统（T1-E1）"><a href="#6-两种数字传输系统（T1-E1）" class="headerlink" title="6. 两种数字传输系统（T1,E1）"></a>6. 两种数字传输系统（T1,E1）</h3><h3 id="7-PCM的缺点"><a href="#7-PCM的缺点" class="headerlink" title="7. PCM的缺点"></a>7. PCM的缺点</h3><h2 id="（三）数据链路层"><a href="#（三）数据链路层" class="headerlink" title="（三）数据链路层"></a>（三）数据链路层</h2><h3 id="1-数据链路层的功能"><a href="#1-数据链路层的功能" class="headerlink" title="1. 数据链路层的功能"></a>1. 数据链路层的功能</h3><h3 id="2-常见的组帧的方法"><a href="#2-常见的组帧的方法" class="headerlink" title="2. 常见的组帧的方法"></a>2. 常见的组帧的方法</h3><h3 id="3-循环冗余校验码的原理"><a href="#3-循环冗余校验码的原理" class="headerlink" title="3. 循环冗余校验码的原理"></a>3. 循环冗余校验码的原理</h3><h3 id="4-多帧滑动窗口与后退N帧协议"><a href="#4-多帧滑动窗口与后退N帧协议" class="headerlink" title="4. 多帧滑动窗口与后退N帧协议"></a>4. 多帧滑动窗口与后退N帧协议</h3><h3 id="5-多路复用技术的一般形式"><a href="#5-多路复用技术的一般形式" class="headerlink" title="5. 多路复用技术的一般形式"></a>5. 多路复用技术的一般形式</h3><h3 id="6-CSMA-CD-协议"><a href="#6-CSMA-CD-协议" class="headerlink" title="6. CSMA/CD 协议"></a>6. CSMA/CD 协议</h3><h3 id="7-局域网的主要特征"><a href="#7-局域网的主要特征" class="headerlink" title="7. 局域网的主要特征"></a>7. 局域网的主要特征</h3><h3 id="8-以太网物理层和MAC-子层的功能"><a href="#8-以太网物理层和MAC-子层的功能" class="headerlink" title="8. 以太网物理层和MAC 子层的功能"></a>8. 以太网物理层和MAC 子层的功能</h3><h3 id="9-以太网的帧格式"><a href="#9-以太网的帧格式" class="headerlink" title="9. 以太网的帧格式"></a>9. 以太网的帧格式</h3><h3 id="10-广域网的主要特征"><a href="#10-广域网的主要特征" class="headerlink" title="10. 广域网的主要特征"></a>10. 广域网的主要特征</h3><h3 id="11-数据报服务的特点"><a href="#11-数据报服务的特点" class="headerlink" title="11. 数据报服务的特点"></a>11. 数据报服务的特点</h3><h3 id="12-虚电路服务与数据报服务的主要区别"><a href="#12-虚电路服务与数据报服务的主要区别" class="headerlink" title="12. 虚电路服务与数据报服务的主要区别"></a>12. 虚电路服务与数据报服务的主要区别</h3><h3 id="13-PPP组成"><a href="#13-PPP组成" class="headerlink" title="13. PPP组成"></a>13. PPP组成</h3><h3 id="14-HDLC的帧结构"><a href="#14-HDLC的帧结构" class="headerlink" title="14. HDLC的帧结构"></a>14. HDLC的帧结构</h3><h3 id="15-网桥的概念以及类型"><a href="#15-网桥的概念以及类型" class="headerlink" title="15. 网桥的概念以及类型"></a>15. 网桥的概念以及类型</h3><h3 id="16-以太网的工作原理和信道的利用率"><a href="#16-以太网的工作原理和信道的利用率" class="headerlink" title="16. 以太网的工作原理和信道的利用率"></a>16. 以太网的工作原理和信道的利用率</h3><h3 id="17-纯ALOHA-和时隙ALOHA-的结论"><a href="#17-纯ALOHA-和时隙ALOHA-的结论" class="headerlink" title="17. 纯ALOHA 和时隙ALOHA 的结论"></a>17. 纯ALOHA 和时隙ALOHA 的结论</h3><h3 id="18-CSMA-CD的原理和吞吐量的计算"><a href="#18-CSMA-CD的原理和吞吐量的计算" class="headerlink" title="18. CSMA/CD的原理和吞吐量的计算"></a>18. CSMA/CD的原理和吞吐量的计算</h3><h3 id="19-VLAN的概念"><a href="#19-VLAN的概念" class="headerlink" title="19. VLAN的概念"></a>19. VLAN的概念</h3><h3 id="20-划分VLAN的方法"><a href="#20-划分VLAN的方法" class="headerlink" title="20. 划分VLAN的方法"></a>20. 划分VLAN的方法</h3><h2 id="（四）网络层"><a href="#（四）网络层" class="headerlink" title="（四）网络层"></a>（四）网络层</h2><h3 id="1-网络的异构型表现在哪些方面"><a href="#1-网络的异构型表现在哪些方面" class="headerlink" title="1. 网络的异构型表现在哪些方面"></a>1. 网络的异构型表现在哪些方面</h3><h3 id="2-中继系统的种类"><a href="#2-中继系统的种类" class="headerlink" title="2. 中继系统的种类"></a>2. 中继系统的种类</h3><h3 id="3-拥塞控制算法"><a href="#3-拥塞控制算法" class="headerlink" title="3. 拥塞控制算法"></a>3. 拥塞控制算法</h3><h3 id="4-距离向量路由算法"><a href="#4-距离向量路由算法" class="headerlink" title="4. 距离向量路由算法"></a>4. 距离向量路由算法</h3><h3 id="5-链路状态路由算法"><a href="#5-链路状态路由算法" class="headerlink" title="5. 链路状态路由算法"></a>5. 链路状态路由算法</h3><h3 id="6-IP地址的分类及其表示"><a href="#6-IP地址的分类及其表示" class="headerlink" title="6. IP地址的分类及其表示"></a>6. IP地址的分类及其表示</h3><h3 id="7-IP数据报的结构及其每个域的意义"><a href="#7-IP数据报的结构及其每个域的意义" class="headerlink" title="7. IP数据报的结构及其每个域的意义"></a>7. IP数据报的结构及其每个域的意义</h3><h3 id="8-子网及其掩码"><a href="#8-子网及其掩码" class="headerlink" title="8. 子网及其掩码"></a>8. 子网及其掩码</h3><h3 id="9-CIDR"><a href="#9-CIDR" class="headerlink" title="9. CIDR"></a>9. CIDR</h3><h3 id="10-ICMP差错报告报文的种类"><a href="#10-ICMP差错报告报文的种类" class="headerlink" title="10. ICMP差错报告报文的种类"></a>10. ICMP差错报告报文的种类</h3><h3 id="11-OSPF"><a href="#11-OSPF" class="headerlink" title="11. OSPF"></a>11. OSPF</h3><h3 id="12-IP多播的概念和多播地址"><a href="#12-IP多播的概念和多播地址" class="headerlink" title="12. IP多播的概念和多播地址"></a>12. IP多播的概念和多播地址</h3><h3 id="13-转交地址的分类"><a href="#13-转交地址的分类" class="headerlink" title="13. 转交地址的分类"></a>13. 转交地址的分类</h3><h3 id="14-路由器的优缺点"><a href="#14-路由器的优缺点" class="headerlink" title="14. 路由器的优缺点"></a>14. 路由器的优缺点</h3><h2 id="（五）传输层"><a href="#（五）传输层" class="headerlink" title="（五）传输层"></a>（五）传输层</h2><h3 id="1-传输层寻址与端口"><a href="#1-传输层寻址与端口" class="headerlink" title="1. 传输层寻址与端口"></a>1. 传输层寻址与端口</h3><h3 id="2-无连接服务与面向连接服务"><a href="#2-无连接服务与面向连接服务" class="headerlink" title="2. 无连接服务与面向连接服务"></a>2. 无连接服务与面向连接服务</h3><h3 id="3-传输连接的建立与释放"><a href="#3-传输连接的建立与释放" class="headerlink" title="3. 传输连接的建立与释放"></a>3. 传输连接的建立与释放</h3><h3 id="4-UDP的优点"><a href="#4-UDP的优点" class="headerlink" title="4. UDP的优点"></a>4. UDP的优点</h3><h3 id="5-UDP和TCP报文段报头格式"><a href="#5-UDP和TCP报文段报头格式" class="headerlink" title="5. UDP和TCP报文段报头格式"></a>5. UDP和TCP报文段报头格式</h3><h3 id="6-TCP的流量控制"><a href="#6-TCP的流量控制" class="headerlink" title="6. TCP的流量控制"></a>6. TCP的流量控制</h3><h3 id="7-TCP的拥塞控制"><a href="#7-TCP的拥塞控制" class="headerlink" title="7. TCP的拥塞控制"></a>7. TCP的拥塞控制</h3><h3 id="8-TCP传送连接的管理"><a href="#8-TCP传送连接的管理" class="headerlink" title="8. TCP传送连接的管理"></a>8. TCP传送连接的管理</h3><h2 id="（六）应用层"><a href="#（六）应用层" class="headerlink" title="（六）应用层"></a>（六）应用层</h2><h3 id="1-C-S-结构的优点"><a href="#1-C-S-结构的优点" class="headerlink" title="1. C/S 结构的优点"></a>1. C/S 结构的优点</h3><h3 id="2-DNS的层次结构"><a href="#2-DNS的层次结构" class="headerlink" title="2. DNS的层次结构"></a>2. DNS的层次结构</h3><h3 id="3-域名服务器的类型"><a href="#3-域名服务器的类型" class="headerlink" title="3. 域名服务器的类型"></a>3. 域名服务器的类型</h3><h3 id="4-Internet的应用协议：FTP-MIME-HTTP"><a href="#4-Internet的应用协议：FTP-MIME-HTTP" class="headerlink" title="4. Internet的应用协议：FTP,MIME,HTTP"></a>4. Internet的应用协议：FTP,MIME,HTTP</h3><h3 id="5-Web页面文档的分类"><a href="#5-Web页面文档的分类" class="headerlink" title="5. Web页面文档的分类"></a>5. Web页面文档的分类</h3><h3 id="6-生成动态文档的方法"><a href="#6-生成动态文档的方法" class="headerlink" title="6. 生成动态文档的方法"></a>6. 生成动态文档的方法</h3><h3 id="7-生成活动文档的方法"><a href="#7-生成活动文档的方法" class="headerlink" title="7. 生成活动文档的方法"></a>7. 生成活动文档的方法</h3><h3 id="8-URL的格式"><a href="#8-URL的格式" class="headerlink" title="8. URL的格式"></a>8. URL的格式</h3><h3 id="9-网络管理系统逻辑模型"><a href="#9-网络管理系统逻辑模型" class="headerlink" title="9. 网络管理系统逻辑模型"></a>9. 网络管理系统逻辑模型</h3><h3 id="10-网络管理的主要功能"><a href="#10-网络管理的主要功能" class="headerlink" title="10. 网络管理的主要功能"></a>10. 网络管理的主要功能</h3><h3 id="11-被管对象的特性"><a href="#11-被管对象的特性" class="headerlink" title="11. 被管对象的特性"></a>11. 被管对象的特性</h3><h3 id="12-SNMP的基本元素"><a href="#12-SNMP的基本元素" class="headerlink" title="12. SNMP的基本元素"></a>12. SNMP的基本元素</h3><h3 id="13-SNMPv3的安全模式"><a href="#13-SNMPv3的安全模式" class="headerlink" title="13. SNMPv3的安全模式"></a>13. SNMPv3的安全模式</h3><h2 id="（七）网络安全"><a href="#（七）网络安全" class="headerlink" title="（七）网络安全"></a>（七）网络安全</h2><h3 id="1-网络面临的4种威胁：截获、中断、篡改、伪造"><a href="#1-网络面临的4种威胁：截获、中断、篡改、伪造" class="headerlink" title="1. 网络面临的4种威胁：截获、中断、篡改、伪造"></a>1. 网络面临的4种威胁：截获、中断、篡改、伪造</h3><h3 id="2-替代加密和置换加密"><a href="#2-替代加密和置换加密" class="headerlink" title="2. 替代加密和置换加密"></a>2. 替代加密和置换加密</h3><h3 id="3-秘密密钥加密算法：DES（明文位数，密钥位数，分组密码）"><a href="#3-秘密密钥加密算法：DES（明文位数，密钥位数，分组密码）" class="headerlink" title="3. 秘密密钥加密算法：DES（明文位数，密钥位数，分组密码）"></a>3. 秘密密钥加密算法：DES（明文位数，密钥位数，分组密码）</h3><h3 id="4-公开密钥算法的特点"><a href="#4-公开密钥算法的特点" class="headerlink" title="4. 公开密钥算法的特点"></a>4. 公开密钥算法的特点</h3><h3 id="5-公开密钥加密算法：RSA"><a href="#5-公开密钥加密算法：RSA" class="headerlink" title="5. 公开密钥加密算法：RSA"></a>5. 公开密钥加密算法：RSA</h3><h3 id="6-数字签名"><a href="#6-数字签名" class="headerlink" title="6. 数字签名"></a>6. 数字签名</h3><h2 id="（八）视频、音频与无线网络"><a href="#（八）视频、音频与无线网络" class="headerlink" title="（八）视频、音频与无线网络"></a>（八）视频、音频与无线网络</h2><h3 id="1-RTP、RTCP、Qos等的概念"><a href="#1-RTP、RTCP、Qos等的概念" class="headerlink" title="1. RTP、RTCP、Qos等的概念"></a>1. RTP、RTCP、Qos等的概念</h3><h3 id="2-时延、时延抖动等的处理"><a href="#2-时延、时延抖动等的处理" class="headerlink" title="2. 时延、时延抖动等的处理"></a>2. 时延、时延抖动等的处理</h3><h3 id="3-WLan、WPan、WMan、WLL的概念"><a href="#3-WLan、WPan、WMan、WLL的概念" class="headerlink" title="3. WLan、WPan、WMan、WLL的概念"></a>3. WLan、WPan、WMan、WLL的概念</h3><h3 id="4-无线局域网的DCF和PCF"><a href="#4-无线局域网的DCF和PCF" class="headerlink" title="4. 无线局域网的DCF和PCF"></a>4. 无线局域网的DCF和PCF</h3><h3 id="5-CSMA-CA协议的原理"><a href="#5-CSMA-CA协议的原理" class="headerlink" title="5. CSMA/CA协议的原理"></a>5. CSMA/CA协议的原理</h3><h2 id="（九）下一代因特网"><a href="#（九）下一代因特网" class="headerlink" title="（九）下一代因特网"></a>（九）下一代因特网</h2><h3 id="1-IPv6的特点"><a href="#1-IPv6的特点" class="headerlink" title="1. IPv6的特点"></a>1. IPv6的特点</h3><h3 id="2-P2P技术的特点"><a href="#2-P2P技术的特点" class="headerlink" title="2. P2P技术的特点"></a>2. P2P技术的特点</h3><h3 id="3-标记交换原理"><a href="#3-标记交换原理" class="headerlink" title="3. 标记交换原理"></a>3. 标记交换原理</h3><h3 id="4-MPLS的封装"><a href="#4-MPLS的封装" class="headerlink" title="4. MPLS的封装"></a>4. MPLS的封装</h3><h3 id="5-标记分配的方式"><a href="#5-标记分配的方式" class="headerlink" title="5. 标记分配的方式"></a>5. 标记分配的方式</h3><h3 id="6-与以路由器作为核心网络平台的技术相比，MPLS的主要优点"><a href="#6-与以路由器作为核心网络平台的技术相比，MPLS的主要优点" class="headerlink" title="6. 与以路由器作为核心网络平台的技术相比，MPLS的主要优点"></a>6. 与以路由器作为核心网络平台的技术相比，MPLS的主要优点</h3><h3 id="7-IntServd的局限性"><a href="#7-IntServd的局限性" class="headerlink" title="7. IntServd的局限性"></a>7. IntServd的局限性</h3><h3 id="8-DiffServ的体系结构"><a href="#8-DiffServ的体系结构" class="headerlink" title="8. DiffServ的体系结构"></a>8. DiffServ的体系结构</h3><h3 id="9-DiffServ的技术特点"><a href="#9-DiffServ的技术特点" class="headerlink" title="9. DiffServ的技术特点"></a>9. DiffServ的技术特点</h3><p>参考书目：《计算机网络》（第六版），谢希仁，电子工业出版社，2013年。</p><h1 id="《程序设计（F01）》考试大纲解析"><a href="#《程序设计（F01）》考试大纲解析" class="headerlink" title="《程序设计（F01）》考试大纲解析"></a>《程序设计（F01）》考试大纲解析</h1><h2 id="考试内容"><a href="#考试内容" class="headerlink" title="考试内容"></a>考试内容</h2><h3 id="1-数据类型及其操作：基本数据类型、数组、指针、结构体、链表等的定义、初始化、引用和操作"><a href="#1-数据类型及其操作：基本数据类型、数组、指针、结构体、链表等的定义、初始化、引用和操作" class="headerlink" title="1. 数据类型及其操作：基本数据类型、数组、指针、结构体、链表等的定义、初始化、引用和操作"></a>1. 数据类型及其操作：基本数据类型、数组、指针、结构体、链表等的定义、初始化、引用和操作</h3><h3 id="2-程序语言的三种控制结构：顺序、选择、循环"><a href="#2-程序语言的三种控制结构：顺序、选择、循环" class="headerlink" title="2. 程序语言的三种控制结构：顺序、选择、循环"></a>2. 程序语言的三种控制结构：顺序、选择、循环</h3><h3 id="3-程序输入输出实现：程序中赋值、键盘输入和输出、通过文件进行数据存取"><a href="#3-程序输入输出实现：程序中赋值、键盘输入和输出、通过文件进行数据存取" class="headerlink" title="3. 程序输入输出实现：程序中赋值、键盘输入和输出、通过文件进行数据存取"></a>3. 程序输入输出实现：程序中赋值、键盘输入和输出、通过文件进行数据存取</h3><h3 id="4-函数：函数定义、函数调用、参数传递、函数返回"><a href="#4-函数：函数定义、函数调用、参数传递、函数返回" class="headerlink" title="4. 函数：函数定义、函数调用、参数传递、函数返回"></a>4. 函数：函数定义、函数调用、参数传递、函数返回</h3><h3 id="5-算法描述方法：程序流程图、N-S盒图、伪代码等"><a href="#5-算法描述方法：程序流程图、N-S盒图、伪代码等" class="headerlink" title="5. 算法描述方法：程序流程图、N-S盒图、伪代码等"></a>5. 算法描述方法：程序流程图、N-S盒图、伪代码等</h3><h3 id="6-常用算法实例："><a href="#6-常用算法实例：" class="headerlink" title="6. 常用算法实例："></a>6. 常用算法实例：</h3><h4 id="1-加法器与累乘器"><a href="#1-加法器与累乘器" class="headerlink" title="1. 加法器与累乘器"></a>1. 加法器与累乘器</h4><h4 id="2-求最大数与最小数"><a href="#2-求最大数与最小数" class="headerlink" title="2. 求最大数与最小数"></a>2. 求最大数与最小数</h4><h4 id="3-排序（冒泡排序、选择排序等）"><a href="#3-排序（冒泡排序、选择排序等）" class="headerlink" title="3. 排序（冒泡排序、选择排序等）"></a>3. 排序（冒泡排序、选择排序等）</h4><h4 id="4-大小写字母转换"><a href="#4-大小写字母转换" class="headerlink" title="4. 大小写字母转换"></a>4. 大小写字母转换</h4><h4 id="5-判别键盘输入字符的类别"><a href="#5-判别键盘输入字符的类别" class="headerlink" title="5. 判别键盘输入字符的类别"></a>5. 判别键盘输入字符的类别</h4><h4 id="6-判别闰年"><a href="#6-判别闰年" class="headerlink" title="6. 判别闰年"></a>6. 判别闰年</h4><h4 id="7-百分制成绩与等级制成绩互相转换"><a href="#7-百分制成绩与等级制成绩互相转换" class="headerlink" title="7. 百分制成绩与等级制成绩互相转换"></a>7. 百分制成绩与等级制成绩互相转换</h4><h4 id="8-求两个数的最大公因数和最小公倍数"><a href="#8-求两个数的最大公因数和最小公倍数" class="headerlink" title="8. 求两个数的最大公因数和最小公倍数"></a>8. 求两个数的最大公因数和最小公倍数</h4><h4 id="9-求菲比拉契数列有限项"><a href="#9-求菲比拉契数列有限项" class="headerlink" title="9. 求菲比拉契数列有限项"></a>9. 求菲比拉契数列有限项</h4><h4 id="10-统计学生成绩，包括总成绩、平均成绩、各分数段人数等"><a href="#10-统计学生成绩，包括总成绩、平均成绩、各分数段人数等" class="headerlink" title="10. 统计学生成绩，包括总成绩、平均成绩、各分数段人数等"></a>10. 统计学生成绩，包括总成绩、平均成绩、各分数段人数等</h4><h4 id="11-验证哥德巴赫猜想"><a href="#11-验证哥德巴赫猜想" class="headerlink" title="11. 验证哥德巴赫猜想"></a>11. 验证哥德巴赫猜想</h4><h4 id="12-用穷举法求某数段的素数、水仙花数、完全平方数等"><a href="#12-用穷举法求某数段的素数、水仙花数、完全平方数等" class="headerlink" title="12. 用穷举法求某数段的素数、水仙花数、完全平方数等"></a>12. 用穷举法求某数段的素数、水仙花数、完全平方数等</h4><h4 id="13-求近似数（如定积分、用牛顿迭代法或二分法或弦截法求多元方程的根）"><a href="#13-求近似数（如定积分、用牛顿迭代法或二分法或弦截法求多元方程的根）" class="headerlink" title="13. 求近似数（如定积分、用牛顿迭代法或二分法或弦截法求多元方程的根）"></a>13. 求近似数（如定积分、用牛顿迭代法或二分法或弦截法求多元方程的根）</h4><h4 id="14-求两个矩阵之和、之积"><a href="#14-求两个矩阵之和、之积" class="headerlink" title="14. 求两个矩阵之和、之积"></a>14. 求两个矩阵之和、之积</h4><h4 id="15-统计输入字符中的单词个数"><a href="#15-统计输入字符中的单词个数" class="headerlink" title="15. 统计输入字符中的单词个数"></a>15. 统计输入字符中的单词个数</h4><p>参考书目：《C语言程序设计（第三版）》，谭浩强，清华大学出版社。《C++程序设计教程（第二版）》，钱能，清华大学出版社。</p><h1 id="《软件工程（J10）》考试大纲解析"><a href="#《软件工程（J10）》考试大纲解析" class="headerlink" title="《软件工程（J10）》考试大纲解析"></a>《软件工程（J10）》考试大纲解析</h1><p>参考书目：《软件工程导论（第五版）》，张海藩，清华大学出版社。</p><h1 id="《数据库原理（J15）》考试大纲解析"><a href="#《数据库原理（J15）》考试大纲解析" class="headerlink" title="《数据库原理（J15）》考试大纲解析"></a>《数据库原理（J15）》考试大纲解析</h1><p>参考书目：《数据库系统概论（第四版）》，王珊、萨师煊，高等教育出版社。</p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer-networks </tag>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机网络（谢希仁 第七版）学习笔记》全书知识梳理复习笔记</title>
      <link href="2020/10/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%EF%BC%88%E8%B0%A2%E5%B8%8C%E4%BB%81-%E7%AC%AC%E4%B8%83%E7%89%88%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B/"/>
      <url>2020/10/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%EF%BC%88%E8%B0%A2%E5%B8%8C%E4%BB%81-%E7%AC%AC%E4%B8%83%E7%89%88%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="《计算机网络（谢希仁-第七版）》全书知识梳理复习笔记"><a href="#《计算机网络（谢希仁-第七版）》全书知识梳理复习笔记" class="headerlink" title="《计算机网络（谢希仁 第七版）》全书知识梳理复习笔记"></a>《计算机网络（谢希仁 第七版）》全书知识梳理复习笔记</h1><p>本章笔记复习材料采用《计算机网络（谢希仁 第七版）》，目录结构采用顺序排列。</p><blockquote><p>日常牢记<a href="/2020/10/07/Markdown%E8%AF%AD%E6%B3%95/">Markdown语法</a></p></blockquote><h1 id="本书目录"><a href="#本书目录" class="headerlink" title="本书目录"></a>本书目录</h1><h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h1><h2 id="1-1-计算机网络在信息时代中的作用"><a href="#1-1-计算机网络在信息时代中的作用" class="headerlink" title="1.1 计算机网络在信息时代中的作用"></a>1.1 计算机网络在信息时代中的作用</h2><p>21世纪的重要特征：数字化、网络化和信息化，以网络为核心的信息时代。</p><ol><li>常用的网络：<ol><li>电信网络：向用户提供电话、电报及传真等服务。</li><li>有线电视网络：向用户传送各种电视节目。</li><li>计算机网络：使用户能够在计算机之间传送数据文件。</li></ol></li><li>Internet两种译名：<ol><li>internet（互连网）:是一个通用名词，泛指由多个计算机网络互联而成的计算机网络。</li><li>Internet（互联网）：是一个专用名词，指当前全球最大的、开放的、由众多网络相互连接而成的特定互联网，采用TCP/IP协议族作为通信规则。</li></ol></li></ol><p>扩展： intranet（内联网）：又称企业内联网，是用因特网技术建立的可支持企事业内部业务处理和信息交流的综合网络信息系统，通常采用一定的安全措施与企事业外部的因特网用户相隔离，对内部用户在信息使用的权限上也有严格的规定。</p><ol start="3"><li>互联网具有两个重要的基本特征：<strong>连通性（指相隔多远都可交换各种信息）</strong> 和 <strong>共享性（指：资源共享）</strong>。</li></ol><h2 id="1-2-互联网概述"><a href="#1-2-互联网概述" class="headerlink" title="1.2 互联网概述"></a>1.2 互联网概述</h2><h3 id="1-2-1-网络中的网络"><a href="#1-2-1-网络中的网络" class="headerlink" title="1.2.1 网络中的网络"></a>1.2.1 网络中的网络</h3><p>计算机网络（简称为网络）：由若干结点（node）和连接这些结点的链路（link）组成。网络中的结点包括：计算机、集线器、交换机、路由器等。</p><h3 id="1-2-2-互联网基础结构发展的三个阶段"><a href="#1-2-2-互联网基础结构发展的三个阶段" class="headerlink" title="1.2.2 互联网基础结构发展的三个阶段"></a>1.2.2 互联网基础结构发展的三个阶段</h3><h3 id="1-2-3-互联网的标准化工作"><a href="#1-2-3-互联网的标准化工作" class="headerlink" title="1.2.3 互联网的标准化工作"></a>1.2.3 互联网的标准化工作</h3><h2 id="1-3-互联网的组成"><a href="#1-3-互联网的组成" class="headerlink" title="1.3 互联网的组成"></a>1.3 互联网的组成</h2><h3 id="1-3-1-互联网的边缘部分"><a href="#1-3-1-互联网的边缘部分" class="headerlink" title="1.3.1 互联网的边缘部分"></a>1.3.1 互联网的边缘部分</h3><h3 id="1-3-2-互联网的核心部分"><a href="#1-3-2-互联网的核心部分" class="headerlink" title="1.3.2 互联网的核心部分"></a>1.3.2 互联网的核心部分</h3><h2 id="1-4-计算机网络在我国的发展"><a href="#1-4-计算机网络在我国的发展" class="headerlink" title="1.4 计算机网络在我国的发展"></a>1.4 计算机网络在我国的发展</h2><h2 id="1-5-计算机网络的类别"><a href="#1-5-计算机网络的类别" class="headerlink" title="1.5 计算机网络的类别"></a>1.5 计算机网络的类别</h2><h3 id="1-5-1-计算机网络的定义"><a href="#1-5-1-计算机网络的定义" class="headerlink" title="1.5.1 计算机网络的定义"></a>1.5.1 计算机网络的定义</h3><h3 id="1-5-2-几种不同类别的计算机网络"><a href="#1-5-2-几种不同类别的计算机网络" class="headerlink" title="1.5.2 几种不同类别的计算机网络"></a>1.5.2 几种不同类别的计算机网络</h3><h2 id="1-6-计算机网络的性能"><a href="#1-6-计算机网络的性能" class="headerlink" title="1.6 计算机网络的性能"></a>1.6 计算机网络的性能</h2><h3 id="1-6-1-计算机网络的性能指标"><a href="#1-6-1-计算机网络的性能指标" class="headerlink" title="1.6.1 计算机网络的性能指标"></a>1.6.1 计算机网络的性能指标</h3><h3 id="1-6-2-计算机网络的非性能指标"><a href="#1-6-2-计算机网络的非性能指标" class="headerlink" title="1.6.2 计算机网络的非性能指标"></a>1.6.2 计算机网络的非性能指标</h3><h2 id="1-7-计算机网络体系结构"><a href="#1-7-计算机网络体系结构" class="headerlink" title="1.7 计算机网络体系结构"></a>1.7 计算机网络体系结构</h2><h3 id="1-7-1-计算机网络体系结构的形成"><a href="#1-7-1-计算机网络体系结构的形成" class="headerlink" title="1.7.1 计算机网络体系结构的形成"></a>1.7.1 计算机网络体系结构的形成</h3><h3 id="1-7-2-协议与划分层次"><a href="#1-7-2-协议与划分层次" class="headerlink" title="1.7.2 协议与划分层次"></a>1.7.2 协议与划分层次</h3><h3 id="1-7-3-具有五层协议的体系结构"><a href="#1-7-3-具有五层协议的体系结构" class="headerlink" title="1.7.3 具有五层协议的体系结构"></a>1.7.3 具有五层协议的体系结构</h3><h3 id="1-7-4-实体、协议、服务和服务访问点"><a href="#1-7-4-实体、协议、服务和服务访问点" class="headerlink" title="1.7.4 实体、协议、服务和服务访问点"></a>1.7.4 实体、协议、服务和服务访问点</h3><h3 id="1-7-5-TCP-IP的体系结构"><a href="#1-7-5-TCP-IP的体系结构" class="headerlink" title="1.7.5 TCP/IP的体系结构"></a>1.7.5 TCP/IP的体系结构</h3><h1 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h1><h2 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h2><h2 id="2-2-数据通信的基础知识"><a href="#2-2-数据通信的基础知识" class="headerlink" title="2.2 数据通信的基础知识"></a>2.2 数据通信的基础知识</h2><h3 id="2-2-1-数据通信系统的模型"><a href="#2-2-1-数据通信系统的模型" class="headerlink" title="2.2.1 数据通信系统的模型"></a>2.2.1 数据通信系统的模型</h3><h3 id="2-2-2-有关信道的几个基本概念"><a href="#2-2-2-有关信道的几个基本概念" class="headerlink" title="2.2.2 有关信道的几个基本概念"></a>2.2.2 有关信道的几个基本概念</h3><h3 id="2-2-3-信道的极限容量"><a href="#2-2-3-信道的极限容量" class="headerlink" title="2.2.3 信道的极限容量"></a>2.2.3 信道的极限容量</h3><h2 id="2-3-物理层下面的传输媒体"><a href="#2-3-物理层下面的传输媒体" class="headerlink" title="2.3 物理层下面的传输媒体"></a>2.3 物理层下面的传输媒体</h2><h3 id="2-3-1-导引型传输媒体"><a href="#2-3-1-导引型传输媒体" class="headerlink" title="2.3.1 导引型传输媒体"></a>2.3.1 导引型传输媒体</h3><h3 id="2-3-2-非导引型传输媒体"><a href="#2-3-2-非导引型传输媒体" class="headerlink" title="2.3.2 非导引型传输媒体"></a>2.3.2 非导引型传输媒体</h3><h2 id="2-4-信道复用技术"><a href="#2-4-信道复用技术" class="headerlink" title="2.4 信道复用技术"></a>2.4 信道复用技术</h2><h3 id="2-4-1-频分复用、时分复用和统计时分复用"><a href="#2-4-1-频分复用、时分复用和统计时分复用" class="headerlink" title="2.4.1 频分复用、时分复用和统计时分复用"></a>2.4.1 频分复用、时分复用和统计时分复用</h3><h3 id="2-4-2-波分复用"><a href="#2-4-2-波分复用" class="headerlink" title="2.4.2 波分复用"></a>2.4.2 波分复用</h3><h3 id="2-4-3-码分复用"><a href="#2-4-3-码分复用" class="headerlink" title="2.4.3 码分复用"></a>2.4.3 码分复用</h3><h2 id="2-5-数字传输系统"><a href="#2-5-数字传输系统" class="headerlink" title="2.5 数字传输系统"></a>2.5 数字传输系统</h2><h2 id="2-6-宽带接入技术"><a href="#2-6-宽带接入技术" class="headerlink" title="2.6 宽带接入技术"></a>2.6 宽带接入技术</h2><h3 id="2-6-1-ADSL技术"><a href="#2-6-1-ADSL技术" class="headerlink" title="2.6.1 ADSL技术"></a>2.6.1 ADSL技术</h3><h3 id="2-6-2-光纤同轴混合网（HFC网）"><a href="#2-6-2-光纤同轴混合网（HFC网）" class="headerlink" title="2.6.2 光纤同轴混合网（HFC网）"></a>2.6.2 光纤同轴混合网（HFC网）</h3><h3 id="FTTx-技术"><a href="#FTTx-技术" class="headerlink" title="FTTx 技术"></a>FTTx 技术</h3><h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><h2 id="3-1-使用点对点信道的数据链路层"><a href="#3-1-使用点对点信道的数据链路层" class="headerlink" title="3.1 使用点对点信道的数据链路层"></a>3.1 使用点对点信道的数据链路层</h2><h3 id="3-1-1-数据链路和帧"><a href="#3-1-1-数据链路和帧" class="headerlink" title="3.1.1 数据链路和帧"></a>3.1.1 数据链路和帧</h3><h3 id="3-1-2-三个基本问题"><a href="#3-1-2-三个基本问题" class="headerlink" title="3.1.2 三个基本问题"></a>3.1.2 三个基本问题</h3><h2 id="3-2-点对点协议PPP"><a href="#3-2-点对点协议PPP" class="headerlink" title="3.2 点对点协议PPP"></a>3.2 点对点协议PPP</h2><h3 id="3-2-1-PPP协议的特点"><a href="#3-2-1-PPP协议的特点" class="headerlink" title="3.2.1 PPP协议的特点"></a>3.2.1 PPP协议的特点</h3><h3 id="3-2-2-PPP协议的帧格式"><a href="#3-2-2-PPP协议的帧格式" class="headerlink" title="3.2.2 PPP协议的帧格式"></a>3.2.2 PPP协议的帧格式</h3><h3 id="3-2-3-PPP协议的工作状态"><a href="#3-2-3-PPP协议的工作状态" class="headerlink" title="3.2.3 PPP协议的工作状态"></a>3.2.3 PPP协议的工作状态</h3><h2 id="3-3-使用广播信道的数据链路层"><a href="#3-3-使用广播信道的数据链路层" class="headerlink" title="3.3 使用广播信道的数据链路层"></a>3.3 使用广播信道的数据链路层</h2><h3 id="3-3-1-局域网的数据链路层"><a href="#3-3-1-局域网的数据链路层" class="headerlink" title="3.3.1 局域网的数据链路层"></a>3.3.1 局域网的数据链路层</h3><h3 id="3-3-2-CSMA-CD协议"><a href="#3-3-2-CSMA-CD协议" class="headerlink" title="3.3.2 CSMA/CD协议"></a>3.3.2 CSMA/CD协议</h3><h3 id="3-3-3-使用集线器的星型拓扑"><a href="#3-3-3-使用集线器的星型拓扑" class="headerlink" title="3.3.3 使用集线器的星型拓扑"></a>3.3.3 使用集线器的星型拓扑</h3><h3 id="3-3-4-以太网的信道利用率"><a href="#3-3-4-以太网的信道利用率" class="headerlink" title="3.3.4 以太网的信道利用率"></a>3.3.4 以太网的信道利用率</h3><h3 id="3-3-5-以太网的MAC层"><a href="#3-3-5-以太网的MAC层" class="headerlink" title="3.3.5 以太网的MAC层"></a>3.3.5 以太网的MAC层</h3><h2 id="3-4-扩展的以太网"><a href="#3-4-扩展的以太网" class="headerlink" title="3.4 扩展的以太网"></a>3.4 扩展的以太网</h2><h3 id="3-4-1-在物理层扩展以太网"><a href="#3-4-1-在物理层扩展以太网" class="headerlink" title="3.4.1 在物理层扩展以太网"></a>3.4.1 在物理层扩展以太网</h3><h3 id="3-4-2-在数据链路层扩展以太网"><a href="#3-4-2-在数据链路层扩展以太网" class="headerlink" title="3.4.2 在数据链路层扩展以太网"></a>3.4.2 在数据链路层扩展以太网</h3><h3 id="3-4-3-虚拟局域网"><a href="#3-4-3-虚拟局域网" class="headerlink" title="3.4.3 虚拟局域网"></a>3.4.3 虚拟局域网</h3><h2 id="3-5-高速以太网"><a href="#3-5-高速以太网" class="headerlink" title="3.5 高速以太网"></a>3.5 高速以太网</h2><h3 id="3-5-1-100BASE-T以太网"><a href="#3-5-1-100BASE-T以太网" class="headerlink" title="3.5.1 100BASE-T以太网"></a>3.5.1 100BASE-T以太网</h3><h3 id="3-5-2-吉比特以太网"><a href="#3-5-2-吉比特以太网" class="headerlink" title="3.5.2 吉比特以太网"></a>3.5.2 吉比特以太网</h3><h3 id="3-5-3-10吉比特以太网（10GE）和更快的以太网"><a href="#3-5-3-10吉比特以太网（10GE）和更快的以太网" class="headerlink" title="3.5.3 10吉比特以太网（10GE）和更快的以太网"></a>3.5.3 10吉比特以太网（10GE）和更快的以太网</h3><h3 id="3-5-4-使用以太网进行宽带接入"><a href="#3-5-4-使用以太网进行宽带接入" class="headerlink" title="3.5.4 使用以太网进行宽带接入"></a>3.5.4 使用以太网进行宽带接入</h3><h1 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h1><h2 id="4-1-网络层提供的两种服务"><a href="#4-1-网络层提供的两种服务" class="headerlink" title="4.1 网络层提供的两种服务"></a>4.1 网络层提供的两种服务</h2><h2 id="4-2-网际协议IP"><a href="#4-2-网际协议IP" class="headerlink" title="4.2 网际协议IP"></a>4.2 网际协议IP</h2><h3 id="4-2-1-虚拟互连网络"><a href="#4-2-1-虚拟互连网络" class="headerlink" title="4.2.1 虚拟互连网络"></a>4.2.1 虚拟互连网络</h3><h3 id="4-2-2-分类的IP地址"><a href="#4-2-2-分类的IP地址" class="headerlink" title="4.2.2 分类的IP地址"></a>4.2.2 分类的IP地址</h3><h3 id="4-2-3-IP地址与硬件地址"><a href="#4-2-3-IP地址与硬件地址" class="headerlink" title="4.2.3 IP地址与硬件地址"></a>4.2.3 IP地址与硬件地址</h3><h3 id="4-2-4-地址解析协议ARP"><a href="#4-2-4-地址解析协议ARP" class="headerlink" title="4.2.4 地址解析协议ARP"></a>4.2.4 地址解析协议ARP</h3><h3 id="4-2-5-IP数据报的格式"><a href="#4-2-5-IP数据报的格式" class="headerlink" title="4.2.5 IP数据报的格式"></a>4.2.5 IP数据报的格式</h3><h3 id="4-2-6-IP层转发分组的流程"><a href="#4-2-6-IP层转发分组的流程" class="headerlink" title="4.2.6 IP层转发分组的流程"></a>4.2.6 IP层转发分组的流程</h3><h2 id="4-3-划分子网和构造超网"><a href="#4-3-划分子网和构造超网" class="headerlink" title="4.3 划分子网和构造超网"></a>4.3 划分子网和构造超网</h2><h3 id="4-3-1-划分子阿旺"><a href="#4-3-1-划分子阿旺" class="headerlink" title="4.3.1 划分子阿旺"></a>4.3.1 划分子阿旺</h3><h3 id="4-3-2-使用子网时分组的转发"><a href="#4-3-2-使用子网时分组的转发" class="headerlink" title="4.3.2 使用子网时分组的转发"></a>4.3.2 使用子网时分组的转发</h3><h3 id="4-3-3-无分类编址CIDR（构造超网）"><a href="#4-3-3-无分类编址CIDR（构造超网）" class="headerlink" title="4.3.3 无分类编址CIDR（构造超网）"></a>4.3.3 无分类编址CIDR（构造超网）</h3><h2 id="4-4-网际控制报文协议ICMP"><a href="#4-4-网际控制报文协议ICMP" class="headerlink" title="4.4 网际控制报文协议ICMP"></a>4.4 网际控制报文协议ICMP</h2><h3 id="4-4-1-ICMP报文的种类"><a href="#4-4-1-ICMP报文的种类" class="headerlink" title="4.4.1 ICMP报文的种类"></a>4.4.1 ICMP报文的种类</h3><h3 id="4-4-2-ICMP的应用举例"><a href="#4-4-2-ICMP的应用举例" class="headerlink" title="4.4.2 ICMP的应用举例"></a>4.4.2 ICMP的应用举例</h3><h2 id="4-5-互联网的路由选择协议"><a href="#4-5-互联网的路由选择协议" class="headerlink" title="4.5 互联网的路由选择协议"></a>4.5 互联网的路由选择协议</h2><h3 id="4-5-1-有关路由选择学医的几个基本概念"><a href="#4-5-1-有关路由选择学医的几个基本概念" class="headerlink" title="4.5.1 有关路由选择学医的几个基本概念"></a>4.5.1 有关路由选择学医的几个基本概念</h3><h3 id="4-5-2-内部网关协议RIP"><a href="#4-5-2-内部网关协议RIP" class="headerlink" title="4.5.2 内部网关协议RIP"></a>4.5.2 内部网关协议RIP</h3><h3 id="4-5-3-内部网关协议OSPF"><a href="#4-5-3-内部网关协议OSPF" class="headerlink" title="4.5.3 内部网关协议OSPF"></a>4.5.3 内部网关协议OSPF</h3><h3 id="4-5-4-外部网关协议BGP"><a href="#4-5-4-外部网关协议BGP" class="headerlink" title="4.5.4 外部网关协议BGP"></a>4.5.4 外部网关协议BGP</h3><h3 id="4-5-5-路由器的构成"><a href="#4-5-5-路由器的构成" class="headerlink" title="4.5.5 路由器的构成"></a>4.5.5 路由器的构成</h3><h2 id="4-6-IPv6"><a href="#4-6-IPv6" class="headerlink" title="4.6 IPv6"></a>4.6 IPv6</h2><h3 id="4-6-1-IPv6的基本首部"><a href="#4-6-1-IPv6的基本首部" class="headerlink" title="4.6.1 IPv6的基本首部"></a>4.6.1 IPv6的基本首部</h3><h3 id="4-6-2-IPv6的地址"><a href="#4-6-2-IPv6的地址" class="headerlink" title="4.6.2 IPv6的地址"></a>4.6.2 IPv6的地址</h3><h3 id="4-6-3-从IPv4向IPv6过渡"><a href="#4-6-3-从IPv4向IPv6过渡" class="headerlink" title="4.6.3 从IPv4向IPv6过渡"></a>4.6.3 从IPv4向IPv6过渡</h3><h3 id="4-6-4-ICMPv6"><a href="#4-6-4-ICMPv6" class="headerlink" title="4.6.4 ICMPv6"></a>4.6.4 ICMPv6</h3><h2 id="4-7-IP多播"><a href="#4-7-IP多播" class="headerlink" title="4.7 IP多播"></a>4.7 IP多播</h2><h3 id="4-7-1-IP多播的基本概念"><a href="#4-7-1-IP多播的基本概念" class="headerlink" title="4.7.1 IP多播的基本概念"></a>4.7.1 IP多播的基本概念</h3><h3 id="4-7-2-在局域网上进行硬件多播"><a href="#4-7-2-在局域网上进行硬件多播" class="headerlink" title="4.7.2 在局域网上进行硬件多播"></a>4.7.2 在局域网上进行硬件多播</h3><h3 id="4-7-3-网际组管理协议IGMP和多播路由选择协议"><a href="#4-7-3-网际组管理协议IGMP和多播路由选择协议" class="headerlink" title="4.7.3 网际组管理协议IGMP和多播路由选择协议"></a>4.7.3 网际组管理协议IGMP和多播路由选择协议</h3><h2 id="4-8-虚拟专用网VPN和网络地址转换NAT"><a href="#4-8-虚拟专用网VPN和网络地址转换NAT" class="headerlink" title="4.8 虚拟专用网VPN和网络地址转换NAT"></a>4.8 虚拟专用网VPN和网络地址转换NAT</h2><h3 id="4-8-1-虚拟专用网VPN"><a href="#4-8-1-虚拟专用网VPN" class="headerlink" title="4.8.1 虚拟专用网VPN"></a>4.8.1 虚拟专用网VPN</h3><h3 id="4-8-2-网络地址转换NAT"><a href="#4-8-2-网络地址转换NAT" class="headerlink" title="4.8.2 网络地址转换NAT"></a>4.8.2 网络地址转换NAT</h3><h2 id="4-9-多协议标记交换MPLS"><a href="#4-9-多协议标记交换MPLS" class="headerlink" title="4.9 多协议标记交换MPLS"></a>4.9 多协议标记交换MPLS</h2><h3 id="4-9-1-MPLS的工作原理"><a href="#4-9-1-MPLS的工作原理" class="headerlink" title="4.9.1 MPLS的工作原理"></a>4.9.1 MPLS的工作原理</h3><h3 id="4-9-2-MPLS首部的位置与格式"><a href="#4-9-2-MPLS首部的位置与格式" class="headerlink" title="4.9.2 MPLS首部的位置与格式"></a>4.9.2 MPLS首部的位置与格式</h3><h1 id="第五章-运输层"><a href="#第五章-运输层" class="headerlink" title="第五章 运输层"></a>第五章 运输层</h1><h2 id="5-1-运输层协议概述"><a href="#5-1-运输层协议概述" class="headerlink" title="5.1 运输层协议概述"></a>5.1 运输层协议概述</h2><h3 id="5-1-1-进程之间的通信"><a href="#5-1-1-进程之间的通信" class="headerlink" title="5.1.1 进程之间的通信"></a>5.1.1 进程之间的通信</h3><h3 id="5-1-2-运输层的两个主要协议"><a href="#5-1-2-运输层的两个主要协议" class="headerlink" title="5.1.2 运输层的两个主要协议"></a>5.1.2 运输层的两个主要协议</h3><h3 id="5-1-3-运输层的端口"><a href="#5-1-3-运输层的端口" class="headerlink" title="5.1.3 运输层的端口"></a>5.1.3 运输层的端口</h3><h2 id="5-2-用户数据报协议UDP"><a href="#5-2-用户数据报协议UDP" class="headerlink" title="5.2 用户数据报协议UDP"></a>5.2 用户数据报协议UDP</h2><h3 id="5-2-1-UDP概述"><a href="#5-2-1-UDP概述" class="headerlink" title="5.2.1 UDP概述"></a>5.2.1 UDP概述</h3><h3 id="5-2-2-UDP的首部格式"><a href="#5-2-2-UDP的首部格式" class="headerlink" title="5.2.2 UDP的首部格式"></a>5.2.2 UDP的首部格式</h3><h2 id="5-3-传输控制协议TCP概述"><a href="#5-3-传输控制协议TCP概述" class="headerlink" title="5.3 传输控制协议TCP概述"></a>5.3 传输控制协议TCP概述</h2><h3 id="5-3-1-TCP最主要的特点"><a href="#5-3-1-TCP最主要的特点" class="headerlink" title="5.3.1 TCP最主要的特点"></a>5.3.1 TCP最主要的特点</h3><h3 id="5-3-2-TCP的连接"><a href="#5-3-2-TCP的连接" class="headerlink" title="5.3.2 TCP的连接"></a>5.3.2 TCP的连接</h3><h2 id="5-4-可靠传输的工作原理"><a href="#5-4-可靠传输的工作原理" class="headerlink" title="5.4 可靠传输的工作原理"></a>5.4 可靠传输的工作原理</h2><h3 id="5-4-1-停止等待协议"><a href="#5-4-1-停止等待协议" class="headerlink" title="5.4.1 停止等待协议"></a>5.4.1 停止等待协议</h3><h3 id="5-4-2-连续ARQ协议"><a href="#5-4-2-连续ARQ协议" class="headerlink" title="5.4.2 连续ARQ协议"></a>5.4.2 连续ARQ协议</h3><h2 id="5-5-TCP报文段的首部格式"><a href="#5-5-TCP报文段的首部格式" class="headerlink" title="5.5 TCP报文段的首部格式"></a>5.5 TCP报文段的首部格式</h2><h2 id="5-6-TCP可靠传输的实现"><a href="#5-6-TCP可靠传输的实现" class="headerlink" title="5.6 TCP可靠传输的实现"></a>5.6 TCP可靠传输的实现</h2><h3 id="5-6-1-以字节为单位的滑动窗口"><a href="#5-6-1-以字节为单位的滑动窗口" class="headerlink" title="5.6.1 以字节为单位的滑动窗口"></a>5.6.1 以字节为单位的滑动窗口</h3><h3 id="5-6-2-超时重传时间的选择"><a href="#5-6-2-超时重传时间的选择" class="headerlink" title="5.6.2 超时重传时间的选择"></a>5.6.2 超时重传时间的选择</h3><h3 id="5-6-3-选择确认SACK"><a href="#5-6-3-选择确认SACK" class="headerlink" title="5.6.3 选择确认SACK"></a>5.6.3 选择确认SACK</h3><h2 id="5-7-TCP的流量控制"><a href="#5-7-TCP的流量控制" class="headerlink" title="5.7 TCP的流量控制"></a>5.7 TCP的流量控制</h2><h3 id="5-7-1-利用滑动窗口实现流量控制"><a href="#5-7-1-利用滑动窗口实现流量控制" class="headerlink" title="5.7.1 利用滑动窗口实现流量控制"></a>5.7.1 利用滑动窗口实现流量控制</h3><h3 id="5-7-2-TCP的传输效率"><a href="#5-7-2-TCP的传输效率" class="headerlink" title="5.7.2 TCP的传输效率"></a>5.7.2 TCP的传输效率</h3><h2 id="5-8-TCP的拥塞控制"><a href="#5-8-TCP的拥塞控制" class="headerlink" title="5.8 TCP的拥塞控制"></a>5.8 TCP的拥塞控制</h2><h3 id="5-8-1-拥塞控制的一般原理"><a href="#5-8-1-拥塞控制的一般原理" class="headerlink" title="5.8.1 拥塞控制的一般原理"></a>5.8.1 拥塞控制的一般原理</h3><h3 id="5-8-2-TCP的拥塞控制方法"><a href="#5-8-2-TCP的拥塞控制方法" class="headerlink" title="5.8.2 TCP的拥塞控制方法"></a>5.8.2 TCP的拥塞控制方法</h3><h3 id="5-8-3-主动队列管理AQM"><a href="#5-8-3-主动队列管理AQM" class="headerlink" title="5.8.3 主动队列管理AQM"></a>5.8.3 主动队列管理AQM</h3><h2 id="5-9-TCP的运输连接管理"><a href="#5-9-TCP的运输连接管理" class="headerlink" title="5.9 TCP的运输连接管理"></a>5.9 TCP的运输连接管理</h2><h3 id="5-9-1-TCP的连接建立"><a href="#5-9-1-TCP的连接建立" class="headerlink" title="5.9.1 TCP的连接建立"></a>5.9.1 TCP的连接建立</h3><h3 id="5-9-2-TCP的连接释放"><a href="#5-9-2-TCP的连接释放" class="headerlink" title="5.9.2 TCP的连接释放"></a>5.9.2 TCP的连接释放</h3><h3 id="5-9-3-TCP的有限状态机"><a href="#5-9-3-TCP的有限状态机" class="headerlink" title="5.9.3 TCP的有限状态机"></a>5.9.3 TCP的有限状态机</h3><h1 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h1><h2 id="6-1-域名系统DNS"><a href="#6-1-域名系统DNS" class="headerlink" title="6.1 域名系统DNS"></a>6.1 域名系统DNS</h2><h3 id="6-1-1-域名系统概述"><a href="#6-1-1-域名系统概述" class="headerlink" title="6.1.1 域名系统概述"></a>6.1.1 域名系统概述</h3><h3 id="6-1-2-互联网的域名结构"><a href="#6-1-2-互联网的域名结构" class="headerlink" title="6.1.2 互联网的域名结构"></a>6.1.2 互联网的域名结构</h3><h3 id="6-1-3-域名服务器"><a href="#6-1-3-域名服务器" class="headerlink" title="6.1.3 域名服务器"></a>6.1.3 域名服务器</h3><h2 id="6-2-文件传送协议"><a href="#6-2-文件传送协议" class="headerlink" title="6.2 文件传送协议"></a>6.2 文件传送协议</h2><h3 id="6-2-1-FTP概述"><a href="#6-2-1-FTP概述" class="headerlink" title="6.2.1 FTP概述"></a>6.2.1 FTP概述</h3><h3 id="6-2-2-FTP的基本工作原理"><a href="#6-2-2-FTP的基本工作原理" class="headerlink" title="6.2.2 FTP的基本工作原理"></a>6.2.2 FTP的基本工作原理</h3><h3 id="6-2-3-简单文件传送协议TFTP"><a href="#6-2-3-简单文件传送协议TFTP" class="headerlink" title="6.2.3 简单文件传送协议TFTP"></a>6.2.3 简单文件传送协议TFTP</h3><h2 id="6-3-远程终端协议TELNET"><a href="#6-3-远程终端协议TELNET" class="headerlink" title="6.3 远程终端协议TELNET"></a>6.3 远程终端协议TELNET</h2><h2 id="6-4-万维网WWW"><a href="#6-4-万维网WWW" class="headerlink" title="6.4  万维网WWW"></a>6.4  万维网WWW</h2><h3 id="6-4-1-万维网概述"><a href="#6-4-1-万维网概述" class="headerlink" title="6.4.1 万维网概述"></a>6.4.1 万维网概述</h3><h3 id="6-4-2-统一资源定位符URL"><a href="#6-4-2-统一资源定位符URL" class="headerlink" title="6.4.2 统一资源定位符URL"></a>6.4.2 统一资源定位符URL</h3><h3 id="6-4-3-超文本传送协议HTTP"><a href="#6-4-3-超文本传送协议HTTP" class="headerlink" title="6.4.3 超文本传送协议HTTP"></a>6.4.3 超文本传送协议HTTP</h3><h3 id="6-4-4-万维网的文档"><a href="#6-4-4-万维网的文档" class="headerlink" title="6.4.4 万维网的文档"></a>6.4.4 万维网的文档</h3><h3 id="6-4-5-万维网的信息检索系统"><a href="#6-4-5-万维网的信息检索系统" class="headerlink" title="6.4.5 万维网的信息检索系统"></a>6.4.5 万维网的信息检索系统</h3><h3 id="6-4-6-博客和微博"><a href="#6-4-6-博客和微博" class="headerlink" title="6.4.6 博客和微博"></a>6.4.6 博客和微博</h3><h3 id="6-4-7-社交网络"><a href="#6-4-7-社交网络" class="headerlink" title="6.4.7 社交网络"></a>6.4.7 社交网络</h3><h2 id="6-5-电子邮件"><a href="#6-5-电子邮件" class="headerlink" title="6.5 电子邮件"></a>6.5 电子邮件</h2><h3 id="6-5-1-电子邮件概述"><a href="#6-5-1-电子邮件概述" class="headerlink" title="6.5.1 电子邮件概述"></a>6.5.1 电子邮件概述</h3><h3 id="6-5-2-简单邮件传送协议SMTP"><a href="#6-5-2-简单邮件传送协议SMTP" class="headerlink" title="6.5.2 简单邮件传送协议SMTP"></a>6.5.2 简单邮件传送协议SMTP</h3><h3 id="6-5-3-电子邮件的信息格式"><a href="#6-5-3-电子邮件的信息格式" class="headerlink" title="6.5.3 电子邮件的信息格式"></a>6.5.3 电子邮件的信息格式</h3><h3 id="6-5-4-邮件读取协议POP3和IMAP"><a href="#6-5-4-邮件读取协议POP3和IMAP" class="headerlink" title="6.5.4 邮件读取协议POP3和IMAP"></a>6.5.4 邮件读取协议POP3和IMAP</h3><h3 id="6-5-5-基于万维网的电子邮件"><a href="#6-5-5-基于万维网的电子邮件" class="headerlink" title="6.5.5 基于万维网的电子邮件"></a>6.5.5 基于万维网的电子邮件</h3><h3 id="6-5-6-通用互联网邮件扩充MIME"><a href="#6-5-6-通用互联网邮件扩充MIME" class="headerlink" title="6.5.6 通用互联网邮件扩充MIME"></a>6.5.6 通用互联网邮件扩充MIME</h3><h2 id="6-6-动态主机配置协议DHCP"><a href="#6-6-动态主机配置协议DHCP" class="headerlink" title="6.6 动态主机配置协议DHCP"></a>6.6 动态主机配置协议DHCP</h2><h2 id="6-7-简单网路管理协议SNMP"><a href="#6-7-简单网路管理协议SNMP" class="headerlink" title="6.7 简单网路管理协议SNMP"></a>6.7 简单网路管理协议SNMP</h2><h3 id="6-7-1-网络管理的基本概念"><a href="#6-7-1-网络管理的基本概念" class="headerlink" title="6.7.1 网络管理的基本概念"></a>6.7.1 网络管理的基本概念</h3><h3 id="6-7-2-管理信息结构SMI"><a href="#6-7-2-管理信息结构SMI" class="headerlink" title="6.7.2 管理信息结构SMI"></a>6.7.2 管理信息结构SMI</h3><h3 id="6-7-3-管理信息库MIB"><a href="#6-7-3-管理信息库MIB" class="headerlink" title="6.7.3 管理信息库MIB"></a>6.7.3 管理信息库MIB</h3><h3 id="6-7-4-SNMP的协议数据单元和报文"><a href="#6-7-4-SNMP的协议数据单元和报文" class="headerlink" title="6.7.4 SNMP的协议数据单元和报文"></a>6.7.4 SNMP的协议数据单元和报文</h3><h2 id="6-8-应用进程跨越网络的通信"><a href="#6-8-应用进程跨越网络的通信" class="headerlink" title="6.8 应用进程跨越网络的通信"></a>6.8 应用进程跨越网络的通信</h2><h3 id="6-8-1-系统调用和应用编程接口"><a href="#6-8-1-系统调用和应用编程接口" class="headerlink" title="6.8.1 系统调用和应用编程接口"></a>6.8.1 系统调用和应用编程接口</h3><h3 id="6-8-2-几种常用的系统调用"><a href="#6-8-2-几种常用的系统调用" class="headerlink" title="6.8.2 几种常用的系统调用"></a>6.8.2 几种常用的系统调用</h3><h2 id="6-9-P2P应用"><a href="#6-9-P2P应用" class="headerlink" title="6.9 P2P应用"></a>6.9 P2P应用</h2><h3 id="6-9-1-具有集中目录服务器的P2P工作方式"><a href="#6-9-1-具有集中目录服务器的P2P工作方式" class="headerlink" title="6.9.1 具有集中目录服务器的P2P工作方式"></a>6.9.1 具有集中目录服务器的P2P工作方式</h3><h3 id="6-9-2-具有全分布式结构的P2P文件工作程序"><a href="#6-9-2-具有全分布式结构的P2P文件工作程序" class="headerlink" title="6.9.2 具有全分布式结构的P2P文件工作程序"></a>6.9.2 具有全分布式结构的P2P文件工作程序</h3><h3 id="6-9-3-P2P文件分发的分析"><a href="#6-9-3-P2P文件分发的分析" class="headerlink" title="6.9.3 P2P文件分发的分析"></a>6.9.3 P2P文件分发的分析</h3><h3 id="6-9-4-在P2P对等方中搜索对象"><a href="#6-9-4-在P2P对等方中搜索对象" class="headerlink" title="6.9.4 在P2P对等方中搜索对象"></a>6.9.4 在P2P对等方中搜索对象</h3><h1 id="第七章-网络安全"><a href="#第七章-网络安全" class="headerlink" title="第七章 网络安全"></a>第七章 网络安全</h1><h2 id="7-1-网络安全问题概述"><a href="#7-1-网络安全问题概述" class="headerlink" title="7.1 网络安全问题概述"></a>7.1 网络安全问题概述</h2><h3 id="7-1-1-计算机网络面临的安全性威胁"><a href="#7-1-1-计算机网络面临的安全性威胁" class="headerlink" title="7.1.1 计算机网络面临的安全性威胁"></a>7.1.1 计算机网络面临的安全性威胁</h3><h3 id="7-1-2-安全的计算机网络"><a href="#7-1-2-安全的计算机网络" class="headerlink" title="7.1.2 安全的计算机网络"></a>7.1.2 安全的计算机网络</h3><h3 id="7-1-3-数据加密模型"><a href="#7-1-3-数据加密模型" class="headerlink" title="7.1.3 数据加密模型"></a>7.1.3 数据加密模型</h3><h2 id="7-2-两类密码体制"><a href="#7-2-两类密码体制" class="headerlink" title="7.2 两类密码体制"></a>7.2 两类密码体制</h2><h3 id="7-2-1-对称密钥密码体制"><a href="#7-2-1-对称密钥密码体制" class="headerlink" title="7.2.1 对称密钥密码体制"></a>7.2.1 对称密钥密码体制</h3><h3 id="7-2-2-公钥密码体制"><a href="#7-2-2-公钥密码体制" class="headerlink" title="7.2.2 公钥密码体制"></a>7.2.2 公钥密码体制</h3><h2 id="7-3-数字签名"><a href="#7-3-数字签名" class="headerlink" title="7.3 数字签名"></a>7.3 数字签名</h2><h2 id="7-4-鉴别"><a href="#7-4-鉴别" class="headerlink" title="7.4 鉴别"></a>7.4 鉴别</h2><h3 id="7-4-1-报文鉴别"><a href="#7-4-1-报文鉴别" class="headerlink" title="7.4.1 报文鉴别"></a>7.4.1 报文鉴别</h3><h3 id="7-4-2-实体鉴别"><a href="#7-4-2-实体鉴别" class="headerlink" title="7.4.2 实体鉴别"></a>7.4.2 实体鉴别</h3><h2 id="7-5-密钥分配"><a href="#7-5-密钥分配" class="headerlink" title="7.5 密钥分配"></a>7.5 密钥分配</h2><h3 id="7-5-1-对称密钥的分配"><a href="#7-5-1-对称密钥的分配" class="headerlink" title="7.5.1 对称密钥的分配"></a>7.5.1 对称密钥的分配</h3><h3 id="7-5-2-公钥的分配"><a href="#7-5-2-公钥的分配" class="headerlink" title="7.5.2 公钥的分配"></a>7.5.2 公钥的分配</h3><h2 id="7-6-互联网使用的安全协议"><a href="#7-6-互联网使用的安全协议" class="headerlink" title="7.6 互联网使用的安全协议"></a>7.6 互联网使用的安全协议</h2><h3 id="7-6-1-网络层安全协议"><a href="#7-6-1-网络层安全协议" class="headerlink" title="7.6.1 网络层安全协议"></a>7.6.1 网络层安全协议</h3><h3 id="7-6-2-运输层安全协议"><a href="#7-6-2-运输层安全协议" class="headerlink" title="7.6.2 运输层安全协议"></a>7.6.2 运输层安全协议</h3><h3 id="7-6-3-应用层安全协议"><a href="#7-6-3-应用层安全协议" class="headerlink" title="7.6.3 应用层安全协议"></a>7.6.3 应用层安全协议</h3><h2 id="7-7-系统安全：防火墙与入侵检测"><a href="#7-7-系统安全：防火墙与入侵检测" class="headerlink" title="7.7 系统安全：防火墙与入侵检测"></a>7.7 系统安全：防火墙与入侵检测</h2><h3 id="7-7-1-防火墙"><a href="#7-7-1-防火墙" class="headerlink" title="7.7.1 防火墙"></a>7.7.1 防火墙</h3><h3 id="7-7-2-入侵检测系统"><a href="#7-7-2-入侵检测系统" class="headerlink" title="7.7.2 入侵检测系统"></a>7.7.2 入侵检测系统</h3><h2 id="7-8-一些未来的发展方向"><a href="#7-8-一些未来的发展方向" class="headerlink" title="7.8 一些未来的发展方向"></a>7.8 一些未来的发展方向</h2><h1 id="第八章-互联网上的音频-视频服务"><a href="#第八章-互联网上的音频-视频服务" class="headerlink" title="第八章 互联网上的音频/视频服务"></a>第八章 互联网上的音频/视频服务</h1><h2 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h2><h2 id="8-2-流式存储音频-视频"><a href="#8-2-流式存储音频-视频" class="headerlink" title="8.2 流式存储音频/视频"></a>8.2 流式存储音频/视频</h2><h3 id="8-2-1-具有元文件的万维网服务器"><a href="#8-2-1-具有元文件的万维网服务器" class="headerlink" title="8.2.1 具有元文件的万维网服务器"></a>8.2.1 具有元文件的万维网服务器</h3><h3 id="8-2-2-媒体服务器"><a href="#8-2-2-媒体服务器" class="headerlink" title="8.2.2 媒体服务器"></a>8.2.2 媒体服务器</h3><h3 id="8-2-3-实时流式协议RTSP"><a href="#8-2-3-实时流式协议RTSP" class="headerlink" title="8.2.3 实时流式协议RTSP"></a>8.2.3 实时流式协议RTSP</h3><h2 id="8-3-交互式音频-视频"><a href="#8-3-交互式音频-视频" class="headerlink" title="8.3 交互式音频/视频"></a>8.3 交互式音频/视频</h2><h3 id="8-3-1-IP电话概述"><a href="#8-3-1-IP电话概述" class="headerlink" title="8.3.1 IP电话概述"></a>8.3.1 IP电话概述</h3><h3 id="8-3-2-IP电话所需要的几种应用协议"><a href="#8-3-2-IP电话所需要的几种应用协议" class="headerlink" title="8.3.2 IP电话所需要的几种应用协议"></a>8.3.2 IP电话所需要的几种应用协议</h3><h3 id="8-3-3-实时运输协议RTP"><a href="#8-3-3-实时运输协议RTP" class="headerlink" title="8.3.3 实时运输协议RTP"></a>8.3.3 实时运输协议RTP</h3><h3 id="8-3-4-实时运输控制协议RTCP"><a href="#8-3-4-实时运输控制协议RTCP" class="headerlink" title="8.3.4 实时运输控制协议RTCP"></a>8.3.4 实时运输控制协议RTCP</h3><h3 id="8-3-5-H-323"><a href="#8-3-5-H-323" class="headerlink" title="8.3.5 H.323"></a>8.3.5 H.323</h3><h3 id="8-3-6-会话发起协议SIP"><a href="#8-3-6-会话发起协议SIP" class="headerlink" title="8.3.6 会话发起协议SIP"></a>8.3.6 会话发起协议SIP</h3><h2 id="8-4-改进“尽最大努力交付”的服务"><a href="#8-4-改进“尽最大努力交付”的服务" class="headerlink" title="8.4 改进“尽最大努力交付”的服务"></a>8.4 改进“尽最大努力交付”的服务</h2><h3 id="8-4-1-使互联网提供服务质量"><a href="#8-4-1-使互联网提供服务质量" class="headerlink" title="8.4.1 使互联网提供服务质量"></a>8.4.1 使互联网提供服务质量</h3><h3 id="8-4-2-调度和管制机制"><a href="#8-4-2-调度和管制机制" class="headerlink" title="8.4.2 调度和管制机制"></a>8.4.2 调度和管制机制</h3><h3 id="8-4-3-综合服务IntServ与资源预留协议RSVP"><a href="#8-4-3-综合服务IntServ与资源预留协议RSVP" class="headerlink" title="8.4.3 综合服务IntServ与资源预留协议RSVP"></a>8.4.3 综合服务IntServ与资源预留协议RSVP</h3><h3 id="8-4-4-区分服务DiffServ"><a href="#8-4-4-区分服务DiffServ" class="headerlink" title="8.4.4 区分服务DiffServ"></a>8.4.4 区分服务DiffServ</h3><h1 id="第九章-无线网络和移动网络"><a href="#第九章-无线网络和移动网络" class="headerlink" title="第九章 无线网络和移动网络"></a>第九章 无线网络和移动网络</h1><h2 id="9-1-无线局域网WLAN"><a href="#9-1-无线局域网WLAN" class="headerlink" title="9.1 无线局域网WLAN"></a>9.1 无线局域网WLAN</h2><h3 id="9-1-1-无线局域网的组成"><a href="#9-1-1-无线局域网的组成" class="headerlink" title="9.1.1 无线局域网的组成"></a>9.1.1 无线局域网的组成</h3><h3 id="9-1-2-802-11局域网的物理层"><a href="#9-1-2-802-11局域网的物理层" class="headerlink" title="9.1.2 802.11局域网的物理层"></a>9.1.2 802.11局域网的物理层</h3><h3 id="9-1-3-802-11局域网的MAC层协议"><a href="#9-1-3-802-11局域网的MAC层协议" class="headerlink" title="9.1.3 802.11局域网的MAC层协议"></a>9.1.3 802.11局域网的MAC层协议</h3><h3 id="9-1-4-802-11局域网的MAC帧"><a href="#9-1-4-802-11局域网的MAC帧" class="headerlink" title="9.1.4 802.11局域网的MAC帧"></a>9.1.4 802.11局域网的MAC帧</h3><h2 id="9-2-无线个人局域网WPAN"><a href="#9-2-无线个人局域网WPAN" class="headerlink" title="9.2 无线个人局域网WPAN"></a>9.2 无线个人局域网WPAN</h2><h2 id="9-3-无线城域网WMAN"><a href="#9-3-无线城域网WMAN" class="headerlink" title="9.3 无线城域网WMAN"></a>9.3 无线城域网WMAN</h2><h2 id="9-4-蜂窝移动通信网"><a href="#9-4-蜂窝移动通信网" class="headerlink" title="9.4 蜂窝移动通信网"></a>9.4 蜂窝移动通信网</h2><h3 id="9-4-1-蜂窝无线通信技术简介"><a href="#9-4-1-蜂窝无线通信技术简介" class="headerlink" title="9.4.1 蜂窝无线通信技术简介"></a>9.4.1 蜂窝无线通信技术简介</h3><h3 id="9-4-2-移动IP"><a href="#9-4-2-移动IP" class="headerlink" title="9.4.2 移动IP"></a>9.4.2 移动IP</h3><h3 id="9-4-3-蜂窝移动通信网中对移动用户的路由选择"><a href="#9-4-3-蜂窝移动通信网中对移动用户的路由选择" class="headerlink" title="9.4.3 蜂窝移动通信网中对移动用户的路由选择"></a>9.4.3 蜂窝移动通信网中对移动用户的路由选择</h3><h3 id="9-4-4-GSM中的切换"><a href="#9-4-4-GSM中的切换" class="headerlink" title="9.4.4 GSM中的切换"></a>9.4.4 GSM中的切换</h3><h3 id="9-4-5-无线网络对高层协议的影响"><a href="#9-4-5-无线网络对高层协议的影响" class="headerlink" title="9.4.5 无线网络对高层协议的影响"></a>9.4.5 无线网络对高层协议的影响</h3><h2 id="9-5-两种不同的无线上网"><a href="#9-5-两种不同的无线上网" class="headerlink" title="9.5 两种不同的无线上网"></a>9.5 两种不同的无线上网</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机类 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer-networks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机网络：自顶向下方法（原书第六版）》全书知识梳理复习笔记</title>
      <link href="2020/10/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%88%E5%8E%9F%E4%B9%A6%E7%AC%AC%E5%85%AD%E7%89%88%EF%BC%89%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%AE%BA%EF%BC%89/"/>
      <url>2020/10/31/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%88%E5%8E%9F%E4%B9%A6%E7%AC%AC%E5%85%AD%E7%89%88%EF%BC%89%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%AE%BA%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="《计算机网络：自顶向下方法（原书第六版）》全书知识梳理复习笔记"><a href="#《计算机网络：自顶向下方法（原书第六版）》全书知识梳理复习笔记" class="headerlink" title="《计算机网络：自顶向下方法（原书第六版）》全书知识梳理复习笔记"></a>《计算机网络：自顶向下方法（原书第六版）》全书知识梳理复习笔记</h1><p>本章笔记复习材料采用《计算机网络：自顶向下方法（原书第六版）》，目录结构采用自顶向下方法排列。</p><blockquote><p>日常牢记<a href="https://allen-zc.github.io/2020/10/26/Markdown%E8%AF%AD%E6%B3%95/">Markdown语法</a></p></blockquote><h1 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章 概论"></a>第一章 概论</h1><p>最大的计算机网络—因特网（Internet），利用有线和无线传输介质，链接大大小小的计算机系统。它允许用户共享包括文本、图像、音频和视频在内的大量信息，允许用户之间相互发送消息。</p><h2 id="Internet-概览"><a href="#Internet-概览" class="headerlink" title="Internet 概览"></a>Internet 概览</h2><p>Internet不是一个单一的网络，而是一个互联网络（internetwork），多个网络的组合。</p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p><strong>网络（network）：</strong>是由一组具有通信能力的设备相互连接而形成的。<br>    其中包括<br>        1.主机（host,有时也称为端系统（ned system））,如：大型计算机、桌面计算机、笔记本电脑、工作站、无线电话、安全系统等。<br>        2.链接设备，如：连接网络到其他网络的路由器、将设备连接到一起的交换机、变换数据形式的调制解调器等。<br>在一个网络中，这些设备使用有线或无线的传输介质（如电缆或大气）连接起来。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机类 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer-networks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构》C语言版(清华严蔚敏考研版）全书知识梳理笔记</title>
      <link href="2020/10/28/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88-%E6%B8%85%E5%8D%8E%E4%B8%A5%E8%94%9A%E6%95%8F%E8%80%83%E7%A0%94%E7%89%88%EF%BC%89%E5%85%A8%E4%B9%A6%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E7%AC%94%E8%AE%B0/"/>
      <url>2020/10/28/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8BC%E8%AF%AD%E8%A8%80%E7%89%88-%E6%B8%85%E5%8D%8E%E4%B8%A5%E8%94%9A%E6%95%8F%E8%80%83%E7%A0%94%E7%89%88%EF%BC%89%E5%85%A8%E4%B9%A6%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="/">&lt;&lt; 返回博客主页</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个笔记同时使用两本教材：《数据结构：（C语言版）清华严蔚敏 吴伟民》和《数据结构案例教程（C语言版）程海英》，目录结构按照：数据结构（C语言版）严蔚敏排列。</p><h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><p>自1946年第一台计算机问世以来，计算机产业的飞速发展已远远超出人们对它的预料，在某些生产线上，甚至几秒钟就能生产出一台微型计算机。产量猛增，价格低廉，这就使得它的应用范围迅速扩展。如今，计算机已深入到人类社会的各个领域。计算机的应用已不再局限于科学计算，而更多地用于控制、管理及数据处理等非数值计算的处理工作。与此相应，计算机加工处理的对象由纯粹的数值发展到字符、表格和图像等各种具有一定结构的数据，这就给程序设计带来一些新的问题。为了编写一个”好“的程序，必须分析待处理的对象的特性以及各处理对象之间存在的关系。这就是”数据结构“这门学科形成和发展的背景。</p><h2 id="1-1什么是数据结构"><a href="#1-1什么是数据结构" class="headerlink" title="1.1什么是数据结构"></a>1.1什么是数据结构</h2><p>数据结构是一门研究 <strong>非数值计算</strong> 的程序设计问题中计算机的操作对象以及他们之间的关系和操作的学科。<br>数据结构的研究不仅涉及到计算机硬件（特别是编码理论、存储装置和存取方式等）的研究范围，而且和计算机软件的研究有着更密切的关系，无论是编译程序还是操作系统，都涉及到数据元素在存储器中的分配问题。在研究信息检索时也必须考虑如何组织数据，以便查找和存储数据元素更为方便。因此，可以认为”数据结构“是介于数学、计算机硬件和计算机软件三者之间的一门核心课程（如图1.4所示）。<br>   <img data-src="/upload_image/date_structure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%89%80%E5%A4%84%E7%9A%84%E5%9C%B0%E4%BD%8D.png" alt="图1.4”数据结构“所处的地位"><br>在计算机科学中，”数据结构“不仅是一般程序设计（特别是非数值计算的程序设计）的基础，而且是设计和实现编译程序、操作系统、数据库系统及其他信系统程序和大型应用程序的重要基础。</p><h2 id="1-2基本概念和术语"><a href="#1-2基本概念和术语" class="headerlink" title="1.2基本概念和术语"></a>1.2基本概念和术语</h2><p>1.掌握数据、数据元素、抽象数据类型、数据结构、数据的逻辑结构与存储结构等概念。</p><h5 id="什么是数据？"><a href="#什么是数据？" class="headerlink" title="什么是数据？"></a>什么是数据？</h5><p><em><strong>数据（Data）：</strong></em>是对客观事物的<strong>符号</strong>表示，在计算机科学中：指所有能输入到计算机中并被计算机程序处理的符号的总称。它是计算机程序加工的”原料“。<br>例如：一个利用数值分析方法解代数方程的程序，其处理对象是整数和实数；一个编译程序或文字处理程序的处理对象是字符串。因此，对计算机科学而言，数据的含义极为广泛，如图像、声音等都可以通过编码而归之于数据的范畴。</p><h5 id="什么是数据元素？"><a href="#什么是数据元素？" class="headerlink" title="什么是数据元素？"></a>什么是数据元素？</h5><p><em><strong>数据元素（Data Element）：</strong></em>是<strong>数据的基本单位</strong>，在计算机程序中通过作为一个整体进行考虑和处理，有时也称之为<strong>结点</strong>、<strong>顶点</strong>或<strong>记录</strong>。</p><h5 id="什么是数据项？"><a href="#什么是数据项？" class="headerlink" title="什么是数据项？"></a>什么是数据项？</h5><p><em><strong>数据项（Data Item）:</strong></em> 是<strong>数据元素的组成部分</strong>，是对客观事物某一方面特性的<strong>数据描述</strong>，是数据结构中讨论的最小单位，一个数据元素是由若干个数据项组成，有独立含义的、不可分割的最小单位。<br><strong>简单数据项：</strong> 在处理时不能再分割。<br><strong>组合数据项：</strong> 在处理时可进一步分割。</p><h5 id="什么是数据对象？"><a href="#什么是数据对象？" class="headerlink" title="什么是数据对象？"></a>什么是数据对象？</h5><p><em><strong>1.1.1数据对象（Data Object）：</strong></em>是性质相同的数据元素的集合，是数据的一个子集。<br>例如：字母字符对象是集合C = {‘A’ , ‘B’ , … , ‘Z’}。</p><h5 id="什么是数据结构？"><a href="#什么是数据结构？" class="headerlink" title="什么是数据结构？"></a>什么是数据结构？</h5><p>***数据结构（Data Structure）:***是相互之间存在一种或多种特定关系的数据元素和集合。</p><h5 id="四类基本结构"><a href="#四类基本结构" class="headerlink" title="四类基本结构"></a>四类基本结构</h5><p>根据数据元素之间关系的不同特性，通常有下列4类基本结构：<br><strong>（1）集合（Set）</strong> : 结构中的数据元素之间除了“同属性一个集合”的关系外，别无其他关系<em>（这里的关系和数学中的集合概念是一致的）</em>。<br><strong>（2）线性结构（Linear Structure）</strong> : 结构中的数据元素之间存在一个对一个的线性关系。<br><strong>（3）树形结构（Tree Structure）</strong> : 结构中的数据元素之间存在一个对多个的层次关系。<br><strong>（4）图状结构（Graphic Structure）</strong> 或 <strong>网状结构（Reticular Structure）</strong> : 结构中数据元素之间存在多个对多个的任意关系。<br>由于“集合”是数据元素之间关系极为松散的一种结构，因此也可用其他结构来表示它。</p><p>按某种逻辑关系组织起来的一批数据（或称带结构的数据元素的集合）应用计算机语言并按一定的存储表示方法把他们存储在计算机的存储器中，并在其上定义了一个运算的集合。数据结构包含三个方面的内容，即数据的 <strong>逻辑结构</strong> ，数据的 <strong>存储结构</strong> 和对数据进行的 <strong>运算（操作）</strong>。</p><p><strong>三方面的关系为：</strong><br>（1）数据的逻辑结构独立于计算机，是数据本身所固有的。<br>（2）存储结构是逻辑结构在计算机存储器中的映像，必须依赖于计算机。<br>（3）运算是指所施加的一组操作总称。<br>   <img data-src="/upload_image/date_structure/%E4%B8%89%E6%96%B9%E9%9D%A2%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="图1.4”数据结构“所处的地位"></p><p>结构定义中的“关系”描述的是数据元素之间的逻辑关系，因此又称为数据的 <strong>逻辑结构</strong> 。然而，讨论数据结构的目的是为了在计算机中实现对它的操作，因此还需研究如何在计算机中表示它。<br>数据结构在计算机中的表示（又称<strong>映像</strong>）称为数据的 <strong>物理结构</strong> ，又称 <strong>存储结构</strong> 。它包括数据元素的表示和关系的表示。<br>在计算机中表示信息的最小单位是二进制数的一位，叫做位（bit）。<br>在计算机中，我们可以用一个又若干位组合起来形成的一个位串表示一个数据元素（如用一个字长的位串表示一个整数，用8位二进制数表示一个i字符等），通常称这个位串为 <strong>元素（element）</strong> 或 <strong>结点（node）</strong>。当数据元素由若干数据项组成时，位串中对应于各个数据项的子位串称为 <strong>数据域（data field）</strong> .因此，元素或结点可看成是数据元素在计算机中的映像。</p><p>数据元素之间的关系在计算机中由两种不同的表示方法： <strong>顺序映像</strong> 和 <strong>非顺序映像</strong> ，并由此得到两种不同的存储结构： <strong>顺序存储结构</strong> 和 <strong>链式存储结构</strong> 。<br><strong>顺序映像</strong> 的特点是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。<br><strong>非顺序映像</strong> 的特点是借助指示元素存储地址的 <strong>指针（pointer）</strong> 表示数据元素之间的逻辑关系</p><h2 id="1-3抽象数据类型的表示与实现"><a href="#1-3抽象数据类型的表示与实现" class="headerlink" title="1.3抽象数据类型的表示与实现"></a>1.3抽象数据类型的表示与实现</h2><h2 id="1-4算法和算法分析"><a href="#1-4算法和算法分析" class="headerlink" title="1.4算法和算法分析"></a>1.4算法和算法分析</h2><h3 id="1-4-1算法"><a href="#1-4-1算法" class="headerlink" title="1.4.1算法"></a>1.4.1算法</h3><h3 id="1-4-2算法设计的要求"><a href="#1-4-2算法设计的要求" class="headerlink" title="1.4.2算法设计的要求"></a>1.4.2算法设计的要求</h3><h3 id="1-4-3算法效率的度量"><a href="#1-4-3算法效率的度量" class="headerlink" title="1.4.3算法效率的度量"></a>1.4.3算法效率的度量</h3><h3 id="1-4-4算法的存储空间需求"><a href="#1-4-4算法的存储空间需求" class="headerlink" title="1.4.4算法的存储空间需求"></a>1.4.4算法的存储空间需求</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机类 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data-Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机网络》复习笔记</title>
      <link href="2020/10/25/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/10/25/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="《计算机网络》复习笔记"><a href="#《计算机网络》复习笔记" class="headerlink" title="《计算机网络》复习笔记"></a>《计算机网络》复习笔记</h1><p><em>这个笔记同时使用了两本教材：《计算机网络：自顶向下方法（原书第六版）》和《计算机网络（谢希仁 第七版）》， 目录结构按照自顶向下排列。</em></p><blockquote><p>日常牢记<a href="/2020/10/07/Markdown%E8%AF%AD%E6%B3%95/">Markdown语法</a></p></blockquote><h2 id="一、前言：计算机和因特网"><a href="#一、前言：计算机和因特网" class="headerlink" title="一、前言：计算机和因特网"></a>一、前言：计算机和因特网</h2><h3 id="互联网概述"><a href="#互联网概述" class="headerlink" title="互联网概述"></a>互联网概述</h3><ol><li><strong>Internet</strong>两种译名：<ol><li><strong>因特网</strong> （小写字母i开头）是一个通用名词，泛指由多个计算机网络互联而成的计算机网络。</li><li><strong>互联网</strong> （大写字母I开头）是一个专用名词，是指当前全球最大的、开放的、由众多网络相互连接而成的特定互联网，采用TCP/IP协议族作为通信规则。 </li></ol></li><li>定义：计算机网络（简称为网络）有若干结点（node）和连接这些结点的链路（link）组成。结点包括计算机、集线器、交换机、路由器等。</li><li>互联网是“网络的网络”。网络把许多计算机连接在一起，而互联网则把许多网络通过路由器连接在一起。与网络向量的计算机常称为主机。</li><li>区别：计算机网络把许多计算机连接在一起，而互联网则把许多网络连接在一起，是网络的网络。</li><li>互联网基础结构发展的三个阶段：<ol><li>从ARPANET的产生到互联网络的出现</li><li>建成了三级结构的互联网（主干网、地区网和校园网/企业网）</li><li>建成了多层次ISP结构的互联网。ISP（Internet Service Provider）互联网服务提供商。ISP又分为主干ISP、地区ISP和本地ISP。但他们之间不是严格的树形结构，存在<strong>互联网交换点IXP</strong> （Internet eXchange Point）横向连接</li></ol></li><li>制定互联网标准的三个阶段：<ol><li>互联网草案：有效期只有6个月</li><li>建议标准：成为RFC（Request For Comments， 请求评论）文档</li><li>​</li></ol></li></ol><h3 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h3><ol><li>边缘部分<ol><li>组成：所有连接在互联网上的主机</li><li>通信的主体：主机A的某个进程和主机B的某个进程</li><li>几种通信方式：<ol><li>C/S方式</li><li>P2P方式</li></ol></li></ol></li><li>核心部分<ol><li>组成：网络和连接这些网络的<strong>路由器</strong>。路由器是实现分组交换的关键构建，其任务是转发收到的分组。</li><li>电路交换：通信双方之间分配一条专用的物理通路。</li><li>分组交换：采用<strong>存储转发</strong>技术。把整块数据划分为报文，一步步转发，高效灵活迅速可靠。</li></ol></li><li>计算机在我国的发展：<ol><li>中国互联网络信息中心：CNNIC</li></ol></li></ol><h3 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h3><ol><li>广域网WAN（Wide Area Network）</li><li>城域网MAN（Metropolitan Area Network）</li><li>局域网LAN（Local Area Network）</li><li>个人区域网PAN（Personal Area Network）</li></ol><h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><ol><li>速率：单位为bit/s， 前缀为K M G T……</li><li>带宽：表示某信道允许通过的信号频带范围称为带宽，单位为Hz。在计算机网络中可理解为“最高数据率”</li><li>时延<ol><li>发送时延 = 数据帧长度(bit) / 发送速率(bit/s)， 含义为从发送数据帧的第一个bit到最后一个bit发送完成所需时间。</li><li>传播时延 = 信道长度(m) / 电磁波在信道上的传播速率(m/s)， 含义为电磁波在信道中传播一定距离所花费的时间，比光速略低。受传输介质物理性质制约，一般无法提高。</li><li>处理时延：主机或路由器收到分组后处理的时间（例如进行差错检验等）</li><li>排队时延：分组在路由器输出队列中排队的时间。</li><li><strong>总时延等于上述四种时延之和</strong></li></ol></li><li>时延带宽积：时延与带宽的乘积，意义是当第一个bit到达目的地时链路上尚存在多少bit正在传输途中。</li><li>往返时间RTT</li><li>利用率：</li></ol><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><ol><li><p>分层的好处：</p><ol><li>各层之间相互独立</li><li>灵活性好</li><li>结构上可分隔开</li><li>易于实现和维护</li><li>能促进标准化工作（主要功能包括以下：）<ol><li>差错控制</li><li>流量控制</li><li>分段和重装</li><li>复用和分用</li><li>连接建立和释放</li></ol></li></ol></li><li><p>各种体系结构的分层对比</p></li></ol><table><thead><tr><th align="center"></th><th align="center">OSI的体系结构</th><th align="center">TCP/IP的体系结构</th><th align="center">五层协议的体系结构</th></tr></thead><tbody><tr><td align="center">7</td><td align="center">应用层</td><td align="center">应用层</td><td align="center">应用层</td></tr><tr><td align="center">6</td><td align="center">表示层</td><td align="center">↑</td><td align="center">↑</td></tr><tr><td align="center">5</td><td align="center">会话层</td><td align="center">↑</td><td align="center">↑</td></tr><tr><td align="center">4</td><td align="center">运输层</td><td align="center">运输层（TCP或UDP）</td><td align="center">运输层</td></tr><tr><td align="center">3</td><td align="center">网络层</td><td align="center">网际层IP</td><td align="center">网络层</td></tr><tr><td align="center">2</td><td align="center">数据链路层</td><td align="center">网络接口层</td><td align="center">数据链路层</td></tr><tr><td align="center">1</td><td align="center">物理层</td><td align="center">↑</td><td align="center">物理层</td></tr></tbody></table><ol start="3"><li>OSI参考模型：（OSI/RM, Open Systems Interconnection Reference Model）<ol><li>OSI并不是事实标准。</li><li>OSI是七层协议体系结构。</li></ol></li><li>具有五层协议的体系结构内容：（五层协议是折中OSI和TCP/IP的体系结构）<ol><li>应用层（application layer）：任务是通过应用进程间的交互来完成特定网络应用。eg. DNS、HTTP、SMTP</li><li>运输层（transport layer）：任务是负责向两台主机中进程之间的通信提供通用的数据传输服务。主要使用：<ol><li>TCP（Transmission Control Protocol）传输控制协议：提供面向连接的、可靠的数据传输服务，数据传输单位为<strong>报文段</strong>（segment） </li><li>UDP（User Datagram Protocol）用户数据报协议：提供无连接的、尽最大努力的数据传输服务（不保证数据传输的可靠性），数据传输单位为<strong>用户数据报</strong> </li></ol></li><li>网络层（network layer）：负责为分组交换网上的不同主机提供通信服务。使用IP（Internet Protocol）协议，分组也叫<strong>IP数据报</strong> 。</li><li>数据链路层（data link layer）：在两个相邻结点间的链路上传送<strong>帧</strong>（frame）。</li><li>物理层（physical layer）：在物理层上所传数据的单位是bit</li></ol></li><li>TCP/IP并不一定是单指TCP和IP两个协议，而往往是表示互联网所使用的TCP/IP协议族。</li><li><strong>协议</strong>是控制两个对等实体（或多个实体）进行通信的规则的集合。协议是“<strong>水平的</strong>”，即协议是控制对等实体之间通信的规则。服务是“<strong>垂直的</strong>”，即服务是由下层向上层通过层间接口提供的。上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在OSI中称为<strong>服务原语</strong>。</li></ol><h2 id="二、应用层"><a href="#二、应用层" class="headerlink" title="二、应用层"></a>二、应用层</h2><h3 id="域名系统DNS（Domain-Name-System）"><a href="#域名系统DNS（Domain-Name-System）" class="headerlink" title="域名系统DNS（Domain Name System）"></a>域名系统DNS（Domain Name System）</h3><ol><li>功能：将互联网上的主机名字转换为IP地址（因为IP地址不好记）</li><li>域名中的标号由英文字母和数字组成，每一个标号不超过63个字符，不区分大小写字母，不能使用除连字符“-”外的标点符号。完整的域名不超过255字符。</li><li>DNS服务器的四种不同类型：<ol><li>根域名服务器：知道所有顶级域名服务器的IP地址</li><li>顶级域名服务器：知道注册的所有二级域名的权限域名服务器（例如abc.com和y.abc.com各有一个权限域名服务器）</li><li>本地域名服务器：离用户最近的域名服务器，用户首先会请求本地域名服务器</li></ol></li><li>DNS的解析过程：<ol><li>递归查询：</li><li>迭代查询：</li></ol></li></ol><h3 id="文件传送协议FTP（File-Transfer-Protocol）"><a href="#文件传送协议FTP（File-Transfer-Protocol）" class="headerlink" title="文件传送协议FTP（File Transfer Protocol）"></a>文件传送协议FTP（File Transfer Protocol）</h3><ol><li>FTP工作方式：服务器进程打开21端口接受数据连接，打开20端口接受控制连接</li><li>FTP与NFS（网络文件系统）的主要区别：FTP无法远程修改文件（只能下载到本地-修改-上传）而NFS可以</li><li><strong>简单文件传送协议TFTP（Trivial File Transfer Protocol）</strong> </li></ol><h3 id="远程终端协议TELNET"><a href="#远程终端协议TELNET" class="headerlink" title="远程终端协议TELNET"></a>远程终端协议TELNET</h3><ol><li>TELNET是一个简单的远程终端协议，又称为终端仿真协议。定义了NVT（Network Virtual Terminal， 网络虚拟终端）格式，使用7位ASCII码传送数据，高位置1时用作控制指令。</li></ol><h3 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h3><ol><li>万维网（World Wide Web）是一个大规模的、联机式的信息储藏所，英文简称为Web。万维网用链接的方法从互联网上的一个站点访问另一个站点。</li><li>万维网是一个超媒体（hypermedia）系统，他是超文本（hypertext）系统的扩充。</li><li>万维网使用<strong>统一资源定位符URL（Uniform Resource Locator）</strong>来标志万维网上的各种文档。<ol><li>URL格式：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</li><li>常用协议为HTTP和FTP</li><li>端口号默认为80（可不写）</li></ol></li></ol><h3 id="超文本传送协议HTTP"><a href="#超文本传送协议HTTP" class="headerlink" title="超文本传送协议HTTP"></a>超文本传送协议HTTP</h3><ol><li><p>超文本传送协议HTTP（HyperText Transfer Protocol）是一个应用层协议，使用TCP连接进行可靠的传送。</p><ol><li>HTTP是面向事务的应用层协议，使用80端口接受连接。</li><li>HTTP是无连接、无状态的，客户端和服务器之间交换HTTP报文前不需要握手，服务器也并不记得客户端是否曾经访问过。</li><li>HTTP的历史版本：<ol><li>HTTP/1.0：不支持持续连接，每个连接仅传送一个文件</li><li>HTTP/1.1：加入了持续连接，支持流水线方式和非流水线方式（所谓流水线，是指客户不用等待前一个响应的到来就可以发出下一个请求，而非流水线则需要每次收到响应之后才能发出下一个请求）</li></ol></li><li>代理服务器（proxy server）：</li></ol></li><li><p>HTTP报文结构：</p><ol><li>开始行：用于区分是请求报文还是响应报文。在请求报文中叫做请求行，在响应报文中叫做状态行。开始行三个字段之间用空格分开，结尾为CR（回车）和LF（换行）<ol><li>请求行：包括方法、URL、版本</li><li>响应行：包括版本、状态码、短语</li></ol></li><li>首部行：用来说明浏览器、服务器或报文主体的一些信息，可以不止一行。</li><li>实体主体（entity body，也叫实体体）：请求报文一般不用，响应报文中很可能没有这个字段</li></ol></li><li><p>HTTP方法：</p><ol><li>OPTION：请求一些选项的信息</li><li>GET：请求读取由URL所标志的信息</li><li>HEAD：请求读取由URL所标志的信息的首部</li><li>POST：给服务器添加信息</li><li>PUT：在指明的URL下存储一个文档</li><li>DELETE：删除指明的URL所标志的资源</li><li>TRACE：用来进行环回测试的请求报文</li><li>CONNECT：用于代理服务器</li></ol></li><li><p>HTTP响应报文的状态码：三位数字</p><ol><li><p>1xx表示通知信息，如请求收到了或正在进行处理</p></li><li><p>2xx表示成功，如接受或知道了。常见：202 Accepted</p></li><li><p>3xx表示重定向，如要完成请求还必须采取进一步的行动</p></li><li><p>4xx表示客户的差错，如请求中的错误的语法或不能完成。</p><p>常见：400 Bad Request； 404 Not Found</p></li><li><p>5xx表示服务器的差错，如服务器失效无法完成请求</p></li></ol></li><li><p>例：HTTP请求报文</p><p>GET /dir/index/htm HTTP/1.1        开始行：方法为GET，使用相对URL，HTTP版本为1.1</p><p>Host: <span class="exturl" data-url="aHR0cDovL3d3dy54eXouZWR1LmNuLw==">www.xyz.edu.cn<i class="fa fa-external-link-alt"></i></span>                首部行：给出了主机域名</p><p>Connection: close                首部行：告诉服务器发送完请求的文档之后就可以释放链接</p><p>User-Agent: Mozilla/5.0            首部行：表示用户代理是使用火狐浏览器Firefox</p><p>Accept-Language: cn                首部行：表示用户希望优先得到中文版本的文档</p><p>​                                空行：请求报文的最后还有一个空行</p></li><li><p>在服务器上存放用户的信息：服务器在响应报文中给客户端分配一个Cookie作为其识别码</p></li><li><p>超文本标记语言HTML（HyperText Markup Language）</p></li></ol><h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><ul><li>电子邮件系统的组成：</li></ul><ol><li>用户代理UA（User Agent）：用户与电子邮件系统的接口，又称为电子邮件客户端软件。具备以下四个功能：<ol><li>撰写</li><li>显示</li><li>处理（包括发送邮件和接收邮件）</li><li>通信（将邮件发给邮件服务器或是从邮件服务器取回邮件）</li></ol></li><li>邮件服务器<ol><li>邮件从发件人的邮件服务器到收件人的邮件服务器是直达的（两台服务器之间直接通过TCP连接），不经过任何中转。</li></ol></li><li>邮件发送协议和邮件读取协议</li></ol><h4 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）"><a href="#简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）" class="headerlink" title="简单邮件传送协议SMTP（Simple Mail Transfer Protocol）"></a>简单邮件传送协议SMTP（Simple Mail Transfer Protocol）</h4><ol><li>是一个邮件发送协议，仅支持传送可打印的7位ASCII码邮件。SMTP把邮件“<strong>推</strong>”给服务器。</li><li>SMTP使用端口号为25</li><li>使用场景：用户代理将邮件发送给邮件服务器，邮件服务器将邮件发送给目标用户的邮件服务器。</li><li>缺点：<ol><li>发件人的地址不需要经过鉴别</li><li>设计为只传输ASCII码而不是二进制数据（如需传输二进制数据则要编码为7字节的ASCII码）</li><li>传送邮件为明文</li><li>SMTP服务器会拒绝超过一定长度的邮件</li><li>产生扩充的SMTP：“<strong>ESMTP</strong>“ </li></ol></li></ol><h4 id="通用互联网邮件扩充MIME（Multipurpose-Internet-Mail-Extensions）"><a href="#通用互联网邮件扩充MIME（Multipurpose-Internet-Mail-Extensions）" class="headerlink" title="通用互联网邮件扩充MIME（Multipurpose Internet Mail Extensions）"></a>通用互联网邮件扩充MIME（Multipurpose Internet Mail Extensions）</h4><ol><li>在现有的电子邮件程序和协议下传送，但增加了邮件主体的结构，并定义了传送非ASCII码的编码规则。（个人理解相当于在SMTP上加了一个表示层）</li><li>在邮件首部说明邮件的数据类型，可以发送文本、声音、图像、视频等数据。</li><li>对于任意的二进制文件，使用base64编码</li></ol><h4 id="邮局协议POP3（Post-Office-Protocol）第三版"><a href="#邮局协议POP3（Post-Office-Protocol）第三版" class="headerlink" title="邮局协议POP3（Post Office Protocol）第三版"></a>邮局协议POP3（Post Office Protocol）第三版</h4><ol><li>是一个邮件读取协议，仅支持将邮件从服务器“<strong>拉</strong>”回来 （拉完服务器就删除邮件了）</li><li>使用场景：用户代理从邮件服务器那里取回自己的邮件。</li></ol><h4 id="网际报文存取协议IMAP（Internet-Message-Access-Protocol）第四版"><a href="#网际报文存取协议IMAP（Internet-Message-Access-Protocol）第四版" class="headerlink" title="网际报文存取协议IMAP（Internet Message Access Protocol）第四版"></a>网际报文存取协议IMAP（Internet Message Access Protocol）第四版</h4><ol><li>是一个联机协议，客户端通过IMAP可以操纵邮件服务器的邮箱，最大特点是支持多客户端访问邮箱。</li></ol><h3 id="动态主机配置协议DHCP（Dynamic-Host-Configuration-Protocol）"><a href="#动态主机配置协议DHCP（Dynamic-Host-Configuration-Protocol）" class="headerlink" title="动态主机配置协议DHCP（Dynamic Host Configuration Protocol）"></a>动态主机配置协议DHCP（Dynamic Host Configuration Protocol）</h3><ol><li><p>服务器端使用UDP 67端口，客户端使用UDP 68端口。</p></li><li><p>提供的机制：即插即用连网（Plug-and-Play networking）</p></li><li><p>配置的内容：IP地址、子网掩码、默认路由器的IP地址、域名服务器的IP地址</p></li><li><p>使用方法：</p><ol><li>客户端主机接入网络，向DHCP发送一个<strong>发现报文</strong>（0.0.0.0:68 to 255.255.255.255:67）</li><li>DHCP服务器接到报文，发出一个回答报文叫做“<strong>提供报文</strong>”（server IP:67 to 255.255.255.255:68）,提供具有一定租用期T的IP地址（在网络内DHCP服务器可能不止一个）</li><li>客户端挑选一个DHCP提供者，向其发送DHCP<strong>请求报文</strong>（0.0.0.0:68 to server IP:67），请求其作为提供者</li><li>该DHCP服务器回复<strong>确认报文</strong>（server IP:67 to 255.255.255.255:68），告知客户端可以使用其分配的IP地址，这种状态叫做已绑定状态。 </li><li>之后客户端就可以使用该IP地址了。客户端维护两个计时器T1和T2（T1 = 0.5T， T2 = 0.875T），计时器到之后DHCP客户端请求DHCP服务器要求更新租用期。</li><li>若DHCP服务器同意更新，则返回新的确认报文，客户端更新计时器；若DHCP不同意，则返回<strong>否认报文</strong>，这时DHCP客户端必须立即停用原来的IP地址，返回步骤1重新申请。</li><li>DHCP客户可以随时终止租用，只需向DHCP服务器发送<strong>释放报文</strong>。 </li></ol></li></ol><h3 id="简单网络管理协议SNMP"><a href="#简单网络管理协议SNMP" class="headerlink" title="简单网络管理协议SNMP"></a>简单网络管理协议SNMP</h3><p>这一部分貌似没有学过，在谢希仁书297页</p><h2 id="三、运输层"><a href="#三、运输层" class="headerlink" title="三、运输层"></a>三、运输层</h2><p>###运输层概述</p><ol><li>运输层为相互通信的应用进程提供逻辑通信</li><li>运输层提供复用和分用（IP也提供）</li><li>运输层提供差错检测（UDP仅提供检验和）</li><li>运输层的两个协议：<ol><li>传输控制协议TCP（Transmission Control Protocol），提供面向连接的、全双工的可靠信道。传输数据的单位为报文段（segment）</li><li>用户数据报协议UDP（User Datagram Protocol），提供无连接的、不可靠的信道。传输数据的单位为数据报（datagram）</li><li>*流控制传输协议SCTP（Stream Control Transmission Protocol）不常用</li></ol></li><li>UDP承载的常见应用层协议：<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvVENQL1VEUCVFNyVBQiVBRiVFNSU4RiVBMyVFNSU4OCU5NyVFOCVBMSVBOA==">熟知端口号列表（维基百科）<i class="fa fa-external-link-alt"></i></span><ol><li>名字转换：DNS（域名系统）端口53（DNS也可能使用TCP）</li><li>文件传送：TFTP（简单文件传送协议）端口69</li><li>路由选择协议：RIP（路由信息协议）端口520</li><li>IP地址配置：DHCP（动态主机配置协议）服务器：67，客户端：68，DHCPv6客户端：546，DHCPv6服务器：547</li><li>网络管理：SNMP（简单网络管理协议）端口161</li><li>远程文件服务器：NFS（网络文件系统）</li><li>多播：IGMP（网际组管理协议）</li></ol></li><li>TCP承载的常见应用层协议：<ol><li>电子邮件：<ol><li>STMP（简单邮件传送协议）端口25</li><li>IMAP4（网际报文存取协议第四版）端口143</li><li>POP3（邮局协议第三版）端口110</li></ol></li><li>远程终端接入：TELNET（远程终端协议）端口23</li><li>万维网：HTTP（超文本传送协议）端口80</li><li>文件传送：FTP（文件传送协议）数据：20，控制：21</li><li>远程登录：SSH（Secure Shell）端口：22</li></ol></li></ol><h3 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h3><ol><li>UDP的特点<ol><li>仅在IP的数据报服务之上增加了复用和分用的功能以及差错检测的功能（详见UDP报文头部）</li><li>无连接的：发送数据之前不需要建立连接，发送之后也不需要释放</li><li>使用尽最大努力交付：即不保证可靠交付，主机不需要维持复杂的连接状态</li><li>面向报文的：UDP对应用层传来的报文，既不合并，也不拆分，一次交付一个完整报文（若过长，则由IP层对其进行分片）</li><li>没有拥塞控制：一方面会导致不可预测的丢包，另一方面也可以用于绕过TCP的拥塞控制机制而确保低时延</li><li>即可以点对点传送，也可以广播（目的IP地址为255.255.255.255）或多播（目的IP地址为D类组播地址，利用IGMP协议）</li></ol></li><li>UDP的首部格式：总长8字节<ol><li>源端口（2字节）：在需要对方回信时选用，不需要时可用全0</li><li>目的端口（2字节）：接收方如果发现端口号不正确，则返回一个ICMP不可达报文给发送方</li><li>长度（2字节）：最小为8（仅有头部），最大寻址为64KB，也是UDP报文最大长度（65536 - 8 = 65528 Bytes）</li><li>检验和（2字节）：计算时会在报文前加一个<strong>伪首部</strong>，内容包括：源IP地址（4字节）、目的IP地址（4字节）、0（1字节，不知道是什么含义）、17（1字节，17是IP首部中协议字段的值）、UDP长度（2字节，内容与真首部的长度相同）</li></ol></li></ol><h3 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h3><ol><li>这里谢书写的不好，等待用自顶向下书补充</li></ol><h3 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h3><p>####TCP的特点 </p><ol><li>面向连接的协议：使用之前先建立连接，传输完成之后必须释放连接</li><li>点对点的：</li><li>提供全双工通信：</li><li>面向字节流：TCP将上层交付的数据仅仅看成是一连串的无结构的字节流</li><li>每条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。</li></ol><p>####TCP报文段的首部格式</p><p>（首部是<strong>可变长</strong>的，前20字节是固定的，后面可以有选项（按32位对齐））</p><ol><li><p>源端口和目的端口：各占2字节</p></li><li><p>序号（Seq）：4字节，可寻址4GB。TCP传送的字节流中的每一个字节都按顺序编号，首部中的序号字段指的是本报文段所发送数据的第一个字节的序号。</p></li><li><p>确认号（Ack）：4字节，可寻址4GB。是期望收到对方下一个报文段的第一个数据字节的序号（例如A向B发送的msgA1的字节序号为1~200，则B向A发出的报文msgB1的Ack值为201）。若确认号为N，则表示到序号N-1为止的所有数据都已正确收到。</p></li><li><p>数据偏移：4位（0.5字节），表明TCP报文段的数据起始处距离TCP报文段的起始处有多远（实际上该字段指出的是头部长度，但偏移单位为32位，也就是说头部每32字节，数据偏移加1），4bit可以寻址15*4 = 60字节的头部长度（因此TCP首部最短20字节，最长60字节）</p></li><li><p>保留：6位（0.75字节），暂时没有用到，目前置0</p></li><li><p>flag（flag是自己起的名称，并非官方用词）：6位（0.75字节）</p><ol><li>URG（URGent）：紧急指针标志，告诉系统此报文含紧急数据，与紧急指针字段配合使用。</li><li>ACK（ACKnowledgement）：确认标志，连接建立之后所有传送的报文段都必须把ACK置1</li><li>PSH（PuSH）：推送标志，在交互式通信中发送进程希望可以立即发送而不是等待缓存都填满了之后再发，于是发送端接收到上层的数据之后立即发送出去，接收端收到数据之后也立即交给上一层调用</li><li>RST（ReSeT）：复位标志，表明TCP连接中出现严重错误，必须立即释放连接。还用于拒绝一个非法的报文段或拒绝打开一个连接。</li><li>SYN（SYNchronization）：同步标志，在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段（第一次握手），对方若同意建立连接，则响应SYN=1和ACK=1（第二次握手）。</li><li>FIN（FINish）：终止标志，用来释放一个连接。</li></ol></li><li><p>窗口：2字节。窗口的含义是发送方A的接收窗口（而不是发送窗口）。窗口值表明：从本报文段首部的确认号算起，发送方A所允许对方B发送给A的数据量。（例如A发给B的msg1中，Ack=701，窗口=1000，表明A这里的接收缓存空间还剩1000个字节的空余，则B应当只能发Seq为701-1700的数据）。窗口值是动态变化的。</p></li><li><p>检验和：2字节。检验和的计算方法同UDP一样要加一个伪首部，12字节，包括4字节的源IP地址、4字节的目的IP地址、1字节的数字0、1字节的协议号（TCP为6，UDP为17）、2字节的TCP长度（和TCP真头部的长度值相同）</p></li><li><p>紧急指针：2字节。紧急指针仅在URG=1时有意义，它指出本报文段中的紧急数据的字节数（紧急数据之后是普通数据），也就是指出紧急数据的末尾在报文段的位置。PS. 即使窗口为0也可以发送紧急数据。</p></li><li><p>选项。长度可变，0~40个字节都可以，包含选项内容时需要填充对齐到32位。当选项未使用时头部长为20字节。常见选项：</p></li><li><p>最大报文段长度MSS（Maximum Segment Size）选项：表明每一个TCP报文段中数据字段的最大长度（再一次提醒，只含数据，不含头部）。该字段的目的是使TCP单个报文段携带尽可能多的数据，但又不至于报文段大到使IP层将其分片传输，以提高效率。然而不同路由支持的MSS可能不同，因此通信双方各自设置自己能够支持的MSS（两个传送方向可以有不同的MSS）。若双方未填写，则MSS默认值为536字节。因此互联网上所有的设备都应该能接受的报文段长度为536+20=576字节。</p></li><li><p>窗口扩大选项：3字节。TCP首部中的16位窗口字段寻址能力为64KB，可能不够用（例如对于卫星通信而言传播时延和带宽都很大，需要更大的窗口，这种信道又被称为长粗管道long fat pipe），窗口扩大选项其中有一个字节表示<strong>移位值S</strong>，新的窗口值等于TCP首部中的窗口位数从16增到到16+S，移位值S允许的最大值为14，因此窗口最大值为2^30-1。窗口扩大选项可以在TCP连接建立时协商，如果某一段实现了窗口扩大，当其不再需要窗口扩大时可发送S=0，使窗口回到16位。</p></li><li><p>时间戳选项：10字节，包含时间戳值字段（4字节）和时间戳回送回答字段（4字节），其功能为：</p><ol><li>计算往返时间RTT：发送方将当前时间放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回答字段中，当发送方收到确认报文之后便可准确计算出RTT。</li><li>用于处理TCP序号超过2^32的情况，又称为<strong>防止序号绕回PAWS</strong>（Protect Against Wrapped Sequence numbers）。例如以2.5Gbps速率发送数据时，不到14秒序号就会重复。为了使接收方可以区分新的报文段和迟到很久的报文段，需要这种时间戳。（事实证明，设计协议时极端的、看似不可能的情况也需要考虑进去，毕竟TCP设计之初全世界所有的网络加起来也达不到这么高的速率）</li></ol></li><li><p>选择确认（SACK）选项：背景：连续传送的报文段，中间丢掉了几个，因此接收方只确认到最后一次正确收到的那里（丢失的部分之后正确接收的数据也在缓存中放着，因为Seq可以指出它们的正确位置），于是发送方就要按照接收方的ACK指出的位置开始重新开始传输，但断片的毕竟是少数，因此本选项的目的是：让发送方只传送缺少的数据而不重传已经正确到达的数据，即告诉发送方“这一段我已经收到了，你不要再发了”。一个典型的SACK选项包括：1字节指明这是SACK选项字段、1字节表明SACK选项字段的长度、4个字节的起始边界、4个字节的结束边界（起始边界和结束边界的值为这一段数据的ACK值。起始边界和结束边界成对存在，最多5对边界，否则会超出40字节的选项字段容量）。然而SACK文档并没有指明发送方应当怎样响应SACK，因此大多数的实现还是重传<strong>所有</strong>未被确认的数据块（略坑……）。</p></li></ol><p>####TCP可靠传输的实现</p><p>发送方有一个发送窗口，接收方有一个接收窗口，这两个窗口的作用是缓存当前正在传输的数据。</p><ol><li><p>发送窗口：</p><ol><li>发送窗口的大小是根据接收方发来的报文段中首部规定的接收窗口设置，但有时也会小于这个值（受拥塞控制的制约）。发送窗口越大，表明接收方可以一次性确认更多的数据，因此可以提高传输效率。</li><li>发送窗口内存放的是可以发送但尚未被确认收到的数据。</li><li>发送窗口之后的数据全部被确认收到（因此发送窗口不再保留），发送窗口内的数据为允许发送的，发送窗口之前的数据为不允许发送的（因为接收方并没有更多的缓存存放，换言之就是一定会丢失）</li><li>发送窗口内的数据发送完成之后需要等待确认，因此如果没有被确认，则发送窗口不能向前移动，收到确认则可以向前移动到未确认的第一个序号处。</li><li>发送窗口后沿不能向后移动（因为不能撤销已收到的确认），前沿可以向前移动（窗口扩大或窗口前移），可以向后收缩（但TCP标准<strong>强烈不赞成这样做</strong>）。</li><li>发送窗口可以分为两部分：后面一部分为已发送但未收到确认的，前面一部分为允许发送但尚未发送的（也叫可用窗口或有效窗口）。发送方用完可用窗口之后就要停下来等待确认，如果确认超时则要从发送窗口后沿开始重传。</li></ol></li><li><p>接收窗口：</p><ol><li>接收窗口的大小由套接字自己决定，受拥塞控制的制约。</li><li>接收窗口内存放的是已收到的、但尚未交付上层的数据（因为不是连续的）。</li><li>接收窗口之后的数据全部发送确认（因此接收窗口不再保留），接收窗口内的数据为暂未确认的，接收窗口之前的数据为不允许接收的（因为这部分并没有缓存可存放，换言之就是直接丢弃）</li><li>接收窗口内的数据一旦连续了，则可以发出一个确认信息，并将接收窗口前移。接收窗口如果未达到确认条件则一直不移动也不发出确认，造成超时则由发送方重传。（或是发送三个相同的ACK隐式表示NAK）</li><li>接收窗口后沿不能向后移动（因为不能撤销已收到的确认），前沿可以向前移动（窗口扩大或窗口前移），可以向后收缩（但TCP标准<strong>强烈不赞成这样做</strong>）</li><li>TCP要求接收方必须有累积确认的功能，这样可以减少传输开销。接收方不应过分推迟确认，否则会导致发送方不必要的重传（规定不超过0.5秒）</li></ol></li><li><p>超时重传时间的选择</p><ol><li><p>往返时间RTT：</p><p>报文段的往返时间。通过TCP的首部选项字段设置的时间戳完成计算。</p></li><li><p>加权平均往返时间RTTs的计算：</p><p>TCP保留了RTT的一个<strong>加权平均往返时间RTTs</strong>（又称平滑往返时间，S表示Smoothed）。RTTs的计算方法为：</p><p><strong>新的RTTs = （1 - α） × （旧的RTTs）+ α × （新的RTT样本）</strong></p><p>α的推荐值为0.125，当第一次测量时，RTTs的取值即为RTT的值。</p><p>这个公式的含义是，每测算出一个RTT就将其作为八分之一的权重生成新的加权平均值。越新的数据对RTTs的影响越大。</p></li><li><p>偏差加权平均往返时间RTTd的计算：（PS. RTTd中的d应当为下标的大写D，因为Markdown的限制无法写出）</p><p>RTTd表示RTT的偏差的加权平均值，它与RTTs和新的RTT样本之差有关。计算方法为：</p><p><strong>新的RTTd = （1 - β） × （旧的RTTd）+ β × |RTTs - 新的RTT样本|</strong></p><p>β的推荐值为0.25，当第一次测量时，RTTd的取值应为测量到的RTT样本值的一半。</p><p>这个公式的含义是，每测算出一个RTT，将其与RTTs的差（的绝对值）作为四分之一权重生成新的偏差加权平均值。因此RTTd刻画了RTT的波动大小，且越新的数据对RTTd影响越大。</p></li><li><p>超时重传时间RTO（Retransmission Time-Out）应当略大于上面得出的RTTs。TRO计算方法如下：</p><p><strong>TRO = RTTs + 4 × RTTd</strong></p><p>这个公式的含义是，超时重传时间是在加权平均往返时间的基础上，加上四倍的偏差加权平均往返时间。</p></li><li><p>RTO存在的问题：发送方发出msg1，达到超时重传时间仍然没有收到确认，这时发送方重传msg1’，又过了不超过RTO的时间收到了确认，那么这个确认是接收方对msg1的确认还是msg1’的确认？。</p><p>也就是说，发送方和接收方均无法区分这两种情况：情况一是接收方收到了msg1并对msg1进行确认，但此时发送方已经重传，确认报文在重传之后才到达发送方；情况二是msg1在路上丢失，后来发送方重传，接收方收到了msg1‘，并对其进行确认。这两种方法都会导致计算出的RTTs和RTO偏差过大。</p><p>TCP采用这样的方法解决：<strong>在计算加权平均RTTs时，只要报文段重传了，就不采用其往返时间样本。</strong></p><p>但这样无法解决RTT突然增大很多的情况（即此时RTT增大不是偶发性的而是持续性的），按照上述方法将无法永远更新RTO。</p><p>修正方法：<strong>报文段每重传一次，就把RTO增大为原来的2倍，直到不发生重传时再回到原来的计算方式。</strong></p></li></ol></li></ol><p>####TCP的流量控制</p><p>流量控制的目的：让发送方的发送速率不要太快，要让接收方来得及接收。</p><ol><li><p>利用滑动窗口实现流量控制：</p><ol><li>发送方发送窗口不能超过接收方给出的接收窗口。接收方可能将窗口值设为0（即使设置为0，也必须要接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）</li><li>TCP每一个连接都有一个<strong>持续计时器</strong>（在接收方设置接收窗口为0时启动），若时间到了则发送一个<strong>零窗口探测报文段</strong>（仅携带1字节数据），对方在确认中给出现在的接收窗口值。</li></ol></li><li><p>TCP的传输效率</p><ol><li>TCP报文段的发送时机：<ol><li>缓存的数据量大于最大报文段长度MSS（意味着数据可以装满一个报文段了，取出并发送之）</li><li>发送方的应用进程知名要求发送报文段（即TCP支持的推送PUSH操作）</li><li>发送方的一个计时器期限到了，就把缓存中的数据（不大于MSS，否则执行条件1）发送出去</li></ol></li></ol><ul><li>如果是每次都发送小的报文段（例如TELNET，报文段的数据部分甚至短于首部），则要用到以下两种算法：</li></ul><ol><li>Nagle算法：<ol><li>如果数据是逐个字节写入缓存的，则发送方把第一个字节立即发出去，后面到达的字节缓存起来；</li><li>当发送方收到第一个字节的确认之后，再将发送缓存中的所有数据发送出去，在此之后到达的字节继续缓存起来</li><li>只有收到对前一个报文段的确认之后才继续发送下一个报文段</li><li>当待发送的数据已达到发送窗口的一般或已达到MSS时，就立即发送一个报文段</li><li>Nagle在上层交付数据较快而网速较慢的情况下可以明显减少所用的网络带宽。</li></ol></li><li>糊涂窗口综合征（silly window syndrome）：（其实我也被搞糊涂了，这些讲了个啥子喃？）<ol><li>表现：接收方缓存已满，上层应用一次只从接收缓存中取走很少的数据（例如1字节），在确认中设置的窗口也很小（例如1字节），性能极低。</li><li>解决办法：接收方等待一段时间，直到缓存可以容纳下一个最长的报文段，或是缓存已有一半空闲的空间。出现这两种情况之一则接收方可以发出确认报文，并设置窗口大小。此外，发送方也不要发送太小的报文段，而是把数据累积成足够大的报文段，或是达到接收方缓存的一半大小。</li><li>简而言之，就是不要太着急发送小段的数据。</li></ol></li></ol></li></ol><h4 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h4><ol><li>拥塞控制的一般原理：<ol><li>拥塞产生的条件：网络资源有限，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。</li><li>拥塞是一个多因素的、系统性的问题：如果将资源中的某一部分提高容量，并不会改善整个系统的拥塞程度，反而会增大对其他资源的需求，或是造成自身资源的严重浪费。</li><li>拥塞常常趋于恶化：下层链路拥塞会导致上层重传，正反馈机制最终导致系统崩溃。</li><li>拥塞控制是一个动态的问题，是一个全局性的过程。</li></ol></li><li>流量控制：指点对点通信中对通信量的控制，是一个端到端的问题，流量控制所要做的是抑制发送端发送数据的速率，以便接收端来得及接收。（有时发送端的最高发送速率远远高于接收端的最高接收速率，甚至是高于网络本身能够承载的最高传输速率，例如大型服务器向普通个人计算机传送数据，这时就需要限制发送方的发送速率）</li><li>拥塞控制和流量控制的差别：<ol><li>拥塞控制的目的是防止过多数据注入到网络中，这样可以使网络中的路由器或链路不致过载。而流量控制的目的是抑制端到端发送数据的速率。</li><li>拥塞控制所要做的都只有一个前提：网络能够承受现有的网络负荷。</li><li>拥塞控制是一个全局性的过程，而流量控制仅限于通信的两端。</li></ol></li><li>拥塞控制和流量控制的相似性：都是向发送端发送控制报文，告诉发送端让其放慢发送速率。</li><li>解决拥塞控制的原理：寻找使拥塞产生的条件不再满足的方法。<ol><li>增大某些可用资源（增加一些链路，增大带宽等）</li><li>减少一些用户对某些资源的需求（例如拒绝新的建立连接的请求）</li><li>其他……</li></ol></li><li>拥塞控制的方法：<strong>开环控制</strong>和<strong>闭环控制</strong></li><li>监测网络拥塞的指标：<ol><li>由于缺少缓存空间而被丢弃的分组的百分数</li><li>平均队列长度</li><li>超时重传的分组书</li><li>平均分组时延</li><li>分组时延的标准差</li><li>其他……</li></ol></li></ol><h4 id="TCP的拥塞控制方法"><a href="#TCP的拥塞控制方法" class="headerlink" title="TCP的拥塞控制方法"></a>TCP的拥塞控制方法</h4><ul><li>TCP的拥塞控制算法有四种，分别是慢开始、拥塞避免、快重传、快恢复。其中，慢开始和拥塞避免也叫做<strong>基于窗口</strong>的拥塞控制。发送方维持一个叫做<strong>拥塞窗口cwnd</strong>（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。<strong>发送方让自己的发送窗口等于拥塞窗口</strong>。</li><li>发送方控制拥塞窗口的原则：只要网络没有出现拥塞，拥塞窗口就可以再增大一些。但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些。</li><li>发送方判断网络拥塞的依据：没有按时收到确认报文。这是基于网络拥塞会导致报文的丢失或超时这一事实。</li></ul><p><img data-src="/upload_image/computer_network/TCP%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3cwnd%E5%9C%A8%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%97%B6%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.png" alt="TCP拥塞窗口cwnd在拥塞控制时的变化情况"></p><ol><li><p>慢开始（slow-start）：</p></li><li><p>原理：发送数据时由小到大逐渐增大发送窗口（拥塞窗口）的数值</p></li><li><p>拥塞窗口的初始值设置：1<del>2个发送方的最大报文段SMSS（Sender Maximum Segment Size）的值（旧规定），新规定为不超过2</del>4个SMSS的数值。</p></li><li><p>增加值的规定：<strong>拥塞窗口每次的增加量 = min(N，SMSS)</strong></p><p>其中N是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数。因此，当N &lt; SMSS时，拥塞窗口每次的增加量要小于SMSS。 （个人理解：慢开始的目的是尽快找到一个平衡点，这个平衡点附近的拥塞窗口刚好满足接收方尽可能少地确认，且发送方尽可能一次多发送一批数据。若每次增加N，则表示接收方至少具有容纳这N个字节的能力，若每次增加SMSS，则表示还是保守一点，每次只增加一个报文段的量）</p></li><li><p>事实上的表现：2的指数增长形式，因为每一次发送都会收到等量的确认，于是下一次发送的量就是本次发送量的两倍（前期忽略拥塞，因为此时网络还未达到拥塞的程度）</p></li><li><p>慢开始的“慢”并不是指拥塞窗口的增长率慢，而是指在TCP开始发送报文段时先设置一个很小的拥塞窗口，使得发送方在开始时只发送一两个报文段以探测网络的拥塞情况，然后再逐渐增大拥塞窗口。</p></li><li><p><strong>慢开始门限（ssthresh）</strong>状态变量：为了方式拥塞窗口增长过大引起网络拥塞，因此当拥塞窗口超过这个慢开始门限之后改用拥塞避免算法。 </p></li><li><p>拥塞避免（congestion avoidance）：</p><ol><li>思路：让拥塞窗口缓慢增大。具体措施是：每经过一个RTT就把发送方的拥塞窗口+1（加法增大 Additive Increase）。拥塞窗口按线性规律缓慢增长。</li><li>转变：当第一次遇到超时时，拥塞窗口减到1个MSS，慢开始门限也减到拥塞窗口的一半（刚刚发生超时时的窗口值的一半），于是回到慢开始阶段。</li></ol></li><li><p>快重传（fast retransmit）：</p><ol><li>发生时机：接收方对一个相同的报文段确认三次。</li><li>发送方如何处置：立即重传丢失的那个报文段。</li><li>改变：接收方原先收到失序的报文段什么也不做，现在需要用重新确认已收到的报文段提醒发送方。</li><li>快重传的优势：只需要重新发送没收到的报文段，发送方也不会误认为出现了网络拥塞。使用快重传可以使整个网络的吞吐量提高约20%。</li></ol></li><li><p>快恢复（fast recovery）：</p><ol><li>跟快重传同时开始。</li><li>内容：发送方将慢开始门限减到拥塞窗口的一半，将拥塞窗口也减半，并开始执行拥塞避免算法。</li><li>有的快恢复实现是将快恢复开始时的拥塞窗口设置为慢开始门限ssthresh + 3 × MSS的长度，这样做的理由是：发接收方发出了三个ACK，则表明有三个失序的分组已经到达接收方的缓存中，因此网络中并没有堆积三个分组，所以可以适当把拥塞窗口扩大些。</li></ol></li><li><p>四种算法的统一描述：</p><ol><li><p>传输开始时进入<strong>慢开始</strong>阶段，拥塞窗口从1（或者是不大于4）开始倍增</p></li><li><p>发送速率达到慢开始门限，拥塞窗口以及发送速率从指数增长变为线性增长，进入<strong>拥塞避免</strong>阶段 </p></li><li><p>遇到超时，慢开始门限值减为当前发送速率的一半，拥塞窗口减为1，进入慢开始阶段；</p></li><li><p>遇到三个相同的ACK，执行<strong>快重传</strong>算法，立即发送未确认的那个报文段，并将慢开始门限值减为当前发送速率的一般，拥塞窗口也同样减为当前发送速率的一半，发送速率线性增长，进入<strong>快恢复</strong>阶段。 </p></li><li><p>在拥塞避免阶段，拥塞窗口是“<strong>加法增大</strong>”AI（Additive Increase）的，而一旦出现超时或三个重复的ACK，就要把慢开始门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值，这称为“<strong>乘法减小</strong>”MD（Multiplicative Decrease），二者合称为AIMD算法。</p><p><img data-src="/upload_image/computer_network/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="TCP的拥塞控制流程图.png"></p></li><li><p>接收方窗口又称为通知窗口（advertised window），从接收方对发送方的流量控制的角度考虑，<strong>发送方得发送窗口一定不能超过对方给出的接收方窗口值rwnd</strong>。但事实上发送方窗口值不仅受接收方窗口值的约束，还受拥塞窗口cwnd的约束，因此发送方窗口的上限值为：</p><p><strong>发送方窗口的上限值 = min(rwnd, cwnd)</strong> </p></li><li><p>主动队列管理AQM</p><ol><li><p>路由器的队列规则：先进先出FIFO（First In First Out），队列已满则丢弃以后再到达的分组，叫做<strong>尾部丢弃策略</strong>。</p></li><li><p><strong>全局同步</strong>现象：路由器的队列中有承载着来自不同TCP连接的报文段的IP分组，简单的丢弃会导致多个TCP连接进入慢开始状态，于是全网通信量急剧下降，尔后通信量又突然增大许多。</p></li><li><p>主动队列管理原理：不必等到队列已满，在早期就主动丢弃一些到达的分组。通常是在队列已经达到某个值得警惕的数值是就主动丢弃到达的分组，这样可以使发送方提前降低发送速率。</p></li><li><p>AQM的一种早期实现方法：<strong>随机早期检测RED</strong>（Random Early Detection）：</p><p>实现RED需要路由器维护两个参数，最小门限和最大门限。</p><ol><li>队列长度小于最小门限：正常运行</li><li>队列长度大于最小门限，但不大于最大门限：以概率p随机丢弃新到达的分组</li><li>队列长度大于最大门限：丢弃所有新到达的分组</li></ol></li><li><p>RED的丢弃概率p难以确定。RED在2015年之后已被淘汰。但AQM技术仍然是必要的。</p></li></ol></li></ol></li></ol><h4 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h4><p>TCP是面向连接的协议。TCP连接采用C/S模式。</p><ol><li><p>TCP的连接建立：三次握手</p><ol><li>第一次握手：C向S发送。同步位SYN = 1，选择一个Seq = x。TCP规定SYN报文段不携带数据，但要消耗掉一个Seq序号。此时进入<strong>SYN-SENT</strong>（同步已发送）状态。</li><li>第二次握手：S向C发送。如果S同意连接，则同步位SYN = 1， ACK = 1， 选择一个Seq = y， 确认号Ack = x + 1。TCP规定SYN-ACK报文段不携带数据，但要消耗掉一个Seq序号。此时进入<strong>SYN-RCVD</strong>（同步收到）状态。</li><li>第三次握手：C向S发送。同步位取消，ACK = 1（ACK在整个传输生命期内都要为1），Seq = x + 1， Ack = y + 1,。第三次握手可以携带数据，也可以不携带数据。不携带数据则不消耗Seq序号（也就是下一次发送时序号还是Seq = x + 1）。此时C进入<strong>ESTABLISHED</strong>（已建立连接）状态。</li></ol></li><li><p>TCP的连接释放：</p><p><img data-src="/upload_image/computer_network/TCP%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="TCP连接释放的过程.png"></p><ol><li>前提：C和S都处于ESTABLISHED状态。</li><li>第一次握手：C向S发送。（ACK = 0）终止控制位FIN = 1， 需要Seq = u（u等于前面传送完成的最后一个字节的序号+1）。TCP规定FIN报文段即使不携带数据，也要消耗掉一个Seq序号。此时C进入<strong>FIN-WAIT-1</strong>（终止等待1）状态。</li><li>第二次握手：S向C发送。ACK = 1，Seq = v（含义同u），Ack = u + 1。此时S进入<strong>CLOCE-WAIT</strong>（关闭等待）状态。此时从C到S的连接释放，TCP连接处于<strong>半关闭</strong>（half-close）状态，但另一个方向的连接尚未释放，S还可以给C发送数据。</li><li>C收到S的确认之后，进入<strong>FIN-WAIT-2</strong>（终止等待2）状态，等待S发出连接释放报文段。</li><li>若S再无数据发给C，则S向C发送连接释放报文段，FIN = 1，ACK = 1， Seq = w（含义同u），Ack = u + 1。此时S进入<strong>LAST-ACK</strong>（最后确认）状态，等待C确认。</li><li>C必须确认S的这一报文段。ACK = 1，Ack = w + 1，Seq = u + 1。此时C进入<strong>TIME-WAIT</strong>（时间等待）状态。此时连接尚未释放完成，需要经过<strong>时间等待计时器</strong>（TIME-WAIT timer）设置的时间2MSL（最长报文段寿命Maximum Segment Lifetime，建议为2分钟）之后才能进入CLOSED状态。</li></ol></li><li><p>保活计时器（keepalive timer）</p><ol><li>​</li></ol></li><li><p>TCP的有限状态机</p><p><img data-src="/upload_image/computer_network/TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="TCP的有限状态机.png"></p></li></ol><h2 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h2><h2 id="五、链路层"><a href="#五、链路层" class="headerlink" title="五、链路层"></a>五、链路层</h2><h2 id="六、物理层"><a href="#六、物理层" class="headerlink" title="六、物理层"></a>六、物理层</h2><h2 id="七、无线网络和移动网络"><a href="#七、无线网络和移动网络" class="headerlink" title="七、无线网络和移动网络"></a>七、无线网络和移动网络</h2><h2 id="八、多媒体网络"><a href="#八、多媒体网络" class="headerlink" title="八、多媒体网络"></a>八、多媒体网络</h2><h2 id="九、网络安全"><a href="#九、网络安全" class="headerlink" title="九、网络安全"></a>九、网络安全</h2><h1 id="附：《计算机网络（第七版）》（谢希仁著）的课后作业"><a href="#附：《计算机网络（第七版）》（谢希仁著）的课后作业" class="headerlink" title="附：《计算机网络（第七版）》（谢希仁著）的课后作业"></a>附：《计算机网络（第七版）》（谢希仁著）的课后作业</h1><p>1-01 计算机网络可以向用户提供端对端的传输服务，可以是面向连接的、可靠的服务（TCP），也可以是无连接的、不可靠的尽力而为的服务（UDP）。</p><p>1-02 分组交换的要点：暂时未写</p><p>1-03 各自的优缺点：未填完 </p><table><thead><tr><th align="center"></th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">电路交换</td><td align="center">速度快，传输无延迟</td><td align="center">效率低，建立交换需要时间，使用完毕需要拆除连接</td></tr><tr><td align="center">报文交换</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">分组交换</td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机类 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer-networks </tag>
            
            <tag> Review-notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试笔记（一）</title>
      <link href="2020/10/12/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B01/"/>
      <url>2020/10/12/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="24b8e41389ee63592886d40908245f5c7d8a597b153822d17f6004a3e1db4f5f">a4bb622c873cfc4b1410da4193c33141c68ffe8a964c8fe41dd36962c86086278ab76c9718086ee93644509cdde2078553a53eed5c2a783929385cc3dfa08672b5c18766c4e04db17eb7775851590250ffe4169817b1ff0147ba80f6fbd42e04205f00337b9373178e97d543b46e6d11b5f820b73e4a38c047fb2ce22e72382e0a0d0821d2a4691e3cc5d8360d334df7aa622e221d57ac1a890125a378d81e24a06d40529aa1080dbe81d5186b4ac4b3e200a264ab53670f0defcf7130e001e9009c3cf80fb1e0d2296c23e4ae7f60db6d2a23564a551d3378393aaa1ec4e5c5ef84d58d88869301e057ad76540be9b54bc76853b8607dc6b38c7a5118ec9825d8bc2899177557d49d59e81e5fb378e94e69e382545554aea92169127c661558525f985c675a1afda842e542baad2d22e2c00a013a83193f39991d1a7d17345a492446e8c8f5a32699705a70c7f3dba9278a3bce70bc6c56378066cefd27c53ed7dde985d93fb5c827c4fc9689d738cc8e7c4710096f7984e32563f0f662fb01c34a2b4a4c3abbe29a56230a698b7da7e628fa7a1f677317cdb94fdc7a2f63e5b15ef1ef3802a28547e94e33a7b73d53ce4e28f9ca43a709fb2f1710508e4e403b8371f0c35dcf70f7e1bca63be9d3de150518d6fb3140dcd146af93b9550f058b4c846825c1707f82fbc7de527d71f8bf72243e81a814cd5c462a49b712969e47725a79fd1c62612c26420aff1569aee2cc7f84e3e1b56e4370ca7b2f6310539fe1ad4be3eae64530b3a4d45f5609787ae776dd799d25df7b9e7f6432d31e5ae22d853c79000f97c033715524686ea06bd66c2b306c35eeb59572f7386f6d9ddbcee4549f814d98e61bd12c3c0da48365bed321536e561811176d1af58c3a37c7fd0b7c21e431c69dea45cc4c311e98bb5ed3a62739e9d48e3ef058b98bacd52b3334f7613d3a2d5e3996bc16737824f003c9b2bbe76465a732d997b6de583b3158977659d26e579a088cddf214ce02475a25a928a651b8b5792e1de18bd5615170e56c94c3349535e2b873c4ff03c179868950c55db2644c18d0c8377d155cfbdbc77cc939cf8c2eb82ab10828df18c948a5281428b55c9b6d40eb566f0e71ec8bd06a0b9dc985a9e303b4c6b168c6b4b3e11fd97b43a1595deaa49ee4eb8932e1a013fbf5eb38dfacd94b3e4b3babe45b29d87339a6d525dd1b60307ce94a13c71cacd55323e59a749d384dacecf99e64aec098ab0858d9983053f5fb99db44cfd9b6b8f7fba3ff0d86d1d04d5836bb40ed0d9021b2c77864300ccce94265623ea0434b695e9e48874f60e6f05513d84a0022cccf791306881cfa82292dc03366af5c0436a9e0369f5bac5b624d9cef1f7b5521e888910964c77566ac837d8900459ff838293b407da8d7efa588347fa90d82956d2980210e3d38bf0b78e9185838f2adb93cd19530f3a3ac78db8ccf56f9cfc245bc8723a8f5e753476051be5ae288d64274492eb9766596d03ac8dc1fc35ac6c3850d519d19f470a277f7e18a1241410ae6cbe4d1179405916dc7c84827c38b6267e2d447730ce89da83233b0a5edc9892ed91ace33a31636583ee85a2c6b121523b63c4cdc475b8ea735a69ba484d9e648fa0ad9dcb62cc2296ca93fb28d70f9774883c7c4ba9bac79cd0a44bfe70a618f2b2574031aa7a33ffc9785f5f6c08d70bf863ac83cce68064560a3eaad98e48a4a15b3f30b92413fb0f117d08a5be19df23aedb68195aff138ad489e89296f2d672f2e2f6b57a9cd3de465260f7def0e726c3e9759676bdadc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机类 </category>
          
          <category> 网络安全及渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kali-Linux </tag>
            
            <tag> Penetration-test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《计算机基础》复习笔记</title>
      <link href="2020/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
      <url>2020/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="《计算机基础》复习笔记"><a href="#《计算机基础》复习笔记" class="headerlink" title="《计算机基础》复习笔记"></a>《计算机基础》复习笔记</h1><p><em>这个笔记主要记录博主个人学习计算机基础的复习笔记，本章笔记主要针对复习计算机基础、计算机网络、及office办公软件的操作使用，可用于复习专升本、计算机二级使用。</em></p><blockquote><p>日常牢记<a href="/2020/10/07/Markdown%E8%AF%AD%E6%B3%95/">Markdown语法</a></p></blockquote><h1 id="复习笔记"><a href="#复习笔记" class="headerlink" title="复习笔记"></a>复习笔记</h1><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="1-1-1"><a href="#1-1-1" class="headerlink" title="1.1.1"></a>1.1.1</h2><h3 id="1-世界上第一台计算机"><a href="#1-世界上第一台计算机" class="headerlink" title="1.世界上第一台计算机"></a><strong>1.世界上第一台计算机</strong></h3><ol><li>名称：ENIAC （Electronic Numerical Integrator And Computer  电子数字积分计算机）</li><li>时间：1946 地点：美国 </li><li>工作特点：采用十进制工作方式，最初应用于军事科学和科学领域。</li></ol><h3 id="2-世界上第一台具有存储功能的计算机。"><a href="#2-世界上第一台具有存储功能的计算机。" class="headerlink" title="2.世界上第一台具有存储功能的计算机。"></a><strong>2.世界上第一台具有存储功能的计算机。</strong></h3><ol><li>名称：EDVAC （Electronic Discrete Variable Automatic Computer 电子离散变量自动电子计算机）</li><li>时间地点：1946/1952 美国 </li><li>工作特点：由冯诺依曼提出并研发成功，是世界上第一台符合现代计算机工作原理的产品。    1. 计算机硬件采用：运算器、控制器、存储器、输入设备和输出设备五个部分。    2. 计算机内部一律使用二进制表示数据。    3. 计算机采用“程序存储、程序控制”的工作方式。</li></ol><h3 id="3-计算机发展分为四个阶段（四代）"><a href="#3-计算机发展分为四个阶段（四代）" class="headerlink" title="3.计算机发展分为四个阶段（四代）"></a><strong>3.计算机发展分为四个阶段（四代）</strong></h3><h4 id="（一）-第一代计算机-1946-1958"><a href="#（一）-第一代计算机-1946-1958" class="headerlink" title="（一） 第一代计算机(1946-1958)"></a>（一） 第一代计算机(1946-1958)</h4><ol><li>名称：电子管计算机</li><li>硬件中采用的逻辑元件（=电子器件）（=逻辑器件）是电子管</li><li>硬件中使用的存储器是阴极射线管或水印延迟线</li><li>软件中没有操作系统</li><li><strong>【重点】软件中，编程语言和语言处理程序（翻译软件）</strong>    1. 第一代计算机使用了机器语言（第一代编程语言）和汇编语言（第二代编程语言）    2. 机器语言特点：<ol><li>采用二进制数（0或1）表示</li><li>机器语言是计算机能直接识别并执行的语言</li><li>机器语言的编写效率低、执行效率高（最高）</li><li>机器语言的跨平台性、可移植性（最）差（在一种机型上编写的机器语言程序，在另一种机型上无法运行）    3. 汇编语言的特点：</li><li>由于汇编语言采用了助记符（采用了字母语法等，不全是0或1）所以编写效率高，执行效率低（相比机器语言而言）</li><li>采用汇编语言的编写的源程序（用户输入的代码文件）必须经汇编程序转化为机器语言后，才能被计算机执行。<br>【说明】汇编程序是语言处理程序，是翻译。    4. 第一代机器语言和第二代汇编语言都属于低级语言。（最接近硬件设备的低级语言）<br>1958年我国研制了第一台电子管计算机。</li></ol></li></ol><h4 id="（二）第二代计算机"><a href="#（二）第二代计算机" class="headerlink" title="（二）第二代计算机"></a>（二）第二代计算机</h4><ol><li>名称：晶体管计算机</li><li>硬件中：逻辑器件采用晶体管</li><li>硬件中：<ol><li>主存储器（=内存）采用磁芯</li><li>内存储器（=外存）采用磁盘或磁鼓<br>【说明】计算机的存储器分为内存储器（主存）和外存储器（辅存）</li></ol></li><li>软件中，没有操作系统</li><li><strong>【重点】软件中，编程语言和语言处理程序（翻译软件）</strong></li><li>第二代计算机采用第三代编程语言（即高级语言）编写程序。</li><li>特殊的BASIC语言编写的源程序，必须经解释程序（翻译）逐条转化为机器语言以后，才能被计算机执行。<br>【说明】解释程序的特点：解释一条执行一条，下次在执行重新解释（没有目标程序）</li><li>其他高级语言（如C、JAVA等）编写的源程序，必须经编译程序（翻译）转化为目标程序（二进制）后，才能被计算机执行。</li></ol><h4 id="（三）第三代计算机"><a href="#（三）第三代计算机" class="headerlink" title="（三）第三代计算机"></a>（三）第三代计算机</h4><ol><li>名称：集成电路计算机</li><li>电子器件：集成电路</li><li>硬件中，主存储器采用半导体磁性材料（沿用至今），辅存采用磁盘</li><li>软件中出现操作系统，采用高级语言编程</li></ol><h4 id="（四）第四代计算机"><a href="#（四）第四代计算机" class="headerlink" title="（四）第四代计算机"></a>（四）第四代计算机</h4><ol><li>名称：大规模和超大规模集成电路计算机</li><li>逻辑原件：采用大规模和超大规模集成电路</li><li>软件中出现各种操作系统和编程语言</li><li><strong>【特殊的】</strong></li><li>1980年，由IBM公司推出了由一个人即可操作的计算机，个人计算机或微型计算机或PC</li><li>出现多媒体计算机，即通过文字、声音、图形图像视频动画等媒介形式，传播信息</li><li>出现了计算机网络，实现了资源共享和信息通信；Internet（因特网）或互联网是计算机网络的一个重要产品</li><li>出现了超级计算机，中国的“天河二号”是目前世界上运行速度最高的计算机。</li></ol><h2 id="1-1-2-计算机的分类"><a href="#1-1-2-计算机的分类" class="headerlink" title="1.1.2 计算机的分类"></a>1.1.2 计算机的分类</h2><ol><li>按计算机用途分类：通用计算机和专用计算机</li><li>按计算机规模分类：巨型机、大型机、小型机、微型机、工作站、服务器、嵌入式计算机。</li><li>按计算机处理的数据分类：数字计算机、模拟计算机、数字模拟混合计算机。</li><li>按计算机构成器件划分：电子计算机、光子计算机、量子计算机、生物计算机。</li><li>计算机发展趋势：（计算）巨型化、（体积）微型化、（资源）网络化、（处理）智能化。</li><li>各类机型的用途（选择题）：</li><li>巨型机：军事国防、天气海洋、航天等</li><li>大型机：数据库、网络服务</li><li>小型机：科研究所、学校、企业等服务器</li><li>微型机：家庭或者办公使用</li></ol><p>  <strong>【微型机】分为台式机和笔记本。</strong></p><h2 id="1-1-3-计算机的特点"><a href="#1-1-3-计算机的特点" class="headerlink" title="1.1.3 计算机的特点"></a>1.1.3 计算机的特点</h2><ol><li>运算速度快    （运算速度用MIPS(每秒百万条指令)来衡量，是计算机性能指标之一）</li><li>计算精度高    （应用于数值计算）</li><li>自动运行程序    （“程序存储，程序控制”）</li><li>记忆能力强    （计算机存储能力，存储器）</li><li>逻辑判断能力强    （信息检索、图形识别）</li><li>可靠性可用性高    （应用于数据处理 、工业控制、辅助设计、辅助制造、办公自动化）</li></ol><p><strong>【重点说明】</strong></p><ol><li>运算速度是指CPU 每秒运算的次数，即CPU的主频。</li><li>数量级 210=1024=1K<pre><code>220=1024*1024=1024K=1M1024M=1G1024G=1T</code></pre></li></ol><p>  <strong>【提醒】K、M、G、T都是数量级，不是单位。</strong><br>  2. 例如，某PC中CPU的主频是4GHz。<br>      表示：每秒运算4 000 000 000 次<br>      或4* 1024* 1024* 1024次<br>  3. 主频越高，计算机的运行速度越快。<br>2. 计算精度高，指CPU的字长，（第二个主要性能指标）</p><ol><li>字长是CPU每次能处理数据的位（bit）数</li><li>PC机的字长有8/16/32/64位，主流是64位    1. <strong>【重点】</strong><br>计算机数据处理的基本（最小）单位是bit（位）<br>计算机数据存储的基本（最小）单位是Byte（字节）<br>记住：“存储”之外，其他单位一律是bit<br> 1Byte=8bit</li><li>字（word）CPU处理的每组数据，称为字。<br>例如（选择）64位机，一个字的长度是64位。即每次能处理64位二进制数。</li><li>字长越长，运算的精度越高。</li><li>能自动运行的原因？<br>因为采用了“程序存储、程序控制”的工作方式。</li><li>记忆能力是指计算机的存储能力。<br>【复习】存储器=内存+外存</li><li>内存一般是RAM的容量，即内存条容量。<br>例，某PC机内存，8GB。<br>数量级8 000 000 000，存储的单位是Byte（字节）</li><li>外存容量（一般指硬盘容量）1TB<br>数量级1 000 000 000 000 ，单位是Byte</li><li>逻辑判断指逻辑 与和逻辑 或和逻辑 非，运算结果TRUE或FALSE。</li></ol><h2 id="1-1-4计算机的用途？或计算机的应用领域？（注意顺序）"><a href="#1-1-4计算机的用途？或计算机的应用领域？（注意顺序）" class="headerlink" title="1.1.4计算机的用途？或计算机的应用领域？（注意顺序）"></a>1.1.4计算机的用途？或计算机的应用领域？（注意顺序）</h2><ol><li>科学计算                （主要是科学研究等数学计算问题）</li><li>数据处理和信息加工    （非科技方面的数据管理和计算处理）</li><li>自动控制                （多用于航空航天领域）</li><li>计算机辅助设计</li><li>人工智能</li><li>电子商务</li></ol><p><strong>【说明】</strong></p><ol><li>计算机的最主要用途是计算，所以称计算机。科学计算是指数据量大，运算规则简单反复的计算</li><li>数据处理和加工是指各种管理信息系统，图书馆管理系统、工资人事管理系统、办公自动化、教务管理报名系统。</li><li>自动化控制：流水线、工、农、物流业的自动化。</li><li>计算机辅助设计 CAD（Computer Aided Design）<br>计算机辅助制造 CAM（Computer Aided Manufacturing）<br>计算机辅助测试 CAT（Computer Aided Translation）<br>计算机辅助教学 CAI（Computer Aided Instruction）<br>计算机辅助工程 CAE（Computer Aided Engineering）</li><li>人工智能（AI）人机博弈、图形识别、无人驾驶、无人机、高考机器人</li></ol><h2 id="1-2-2-数据、信息和信息编码的概念"><a href="#1-2-2-数据、信息和信息编码的概念" class="headerlink" title="1.2.2 数据、信息和信息编码的概念"></a>1.2.2 数据、信息和信息编码的概念</h2><ol><li>数据不仅指数字、字母、文字和其他特殊字符。而且还包括图形、图像、动画、影像、声音等多媒体数据。</li><li>信息是人们按照预先的目的，通过从各种不同的渠道、不同的角度观察记录反应客观事物状态和特征的某种概念或经过加工后的数据。</li><li>信息强调的是对人有用的数据，这些数据将可能影响到人们的行为与决策。数据是客观存在的事实、概念等，是一种可供加工的特殊表达形式。</li><li>信息编码的基本元素是0和1两个数码，称为二进制。</li></ol><p><strong>【重点】计算机采用二进制表示数据的优点或原因？</strong></p><ol><li><p>电路简单：二进制数的0或1两个数码，很容易地用电器元件的导通和截止来表示。</p></li><li><p>可靠性高：用电器元件的两种状态表示两个数码在传输和运算中不易出错</p></li><li><p>简化运算：二进制的运算，求和法则只有三个。求积法则也只有三个</p></li><li><p>逻辑性强： 二进制的两个数码，正好代表逻辑代数中的TRUE 和FALSE</p></li><li><p>逻辑运算</p></li><li><p>逻辑 与<br>运算符有：∧、∩、×、AND、·<br>运算规则：只有1×1=1，其余全部为0（0表示FALSE，非0表示TRUE）<br>例（填空）以下逻辑运算式的结果是（）<br>101101×1011=<br>【说明】×、＋如果不说明是逻辑运算，默认的算术运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">101101</span><br><span class="line">缺位补0</span><br><span class="line">∩001011</span><br><span class="line">  001001</span><br></pre></td></tr></table></figure></li><li><p>逻辑 或<br>运算符有：＋、∪、∨、OR四个符号<br>运算规则：只有0+0=0，其余全部为1</p></li><li><p>逻辑 非<br>取反<br>例；NOT 1001=0110</p></li><li><p>常用的数制<br>进位制    进位规则    基数    所用的数码    位   权      表示符号<br>二进制    逢二进一    R=2    O,1    2i    B （ Binary ）<br>八进制    逢八进一    R=8    0,1, … ,7    8i    O （ Octal ）<br>十进制    逢十进一    R=10    0,1, … ,9    10i    D(Decimal)<br>十六进制    逢十六进一    R=16    0,1 … ,9,A,.F    16i    H(Hexadecimal)</p></li></ol><p>基数： R 进制的基数 =R<br>位权：在数制中，各位数字所表示值的大小不仅与该数字本身的大小有关，还与该数字所在的位置有关，我们称这关系为数的 位 权 。<br>位权：一个与数字位置有关的常数，位权 =Rn </p><table><thead><tr><th align="center">十进制D(Decimal)</th><th align="center">二进制B(Binary)</th><th align="center">八进制O(Octal)</th><th align="center">十六进制H(Hexadecimal)</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">10</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">3</td><td align="center">11</td><td align="center">3</td><td align="center">3</td></tr><tr><td align="center">4</td><td align="center">100</td><td align="center">4</td><td align="center">4</td></tr><tr><td align="center">5</td><td align="center">101</td><td align="center">5</td><td align="center">5</td></tr><tr><td align="center">6</td><td align="center">110</td><td align="center">6</td><td align="center">6</td></tr><tr><td align="center">7</td><td align="center">111</td><td align="center">7</td><td align="center">7</td></tr><tr><td align="center">8</td><td align="center">1000</td><td align="center">10</td><td align="center">8</td></tr><tr><td align="center">9</td><td align="center">1001</td><td align="center">11</td><td align="center">9</td></tr><tr><td align="center">10</td><td align="center">1010</td><td align="center">12</td><td align="center">A</td></tr><tr><td align="center">11</td><td align="center">1011</td><td align="center">13</td><td align="center">B</td></tr><tr><td align="center">12</td><td align="center">1100</td><td align="center">14</td><td align="center">C</td></tr><tr><td align="center">13</td><td align="center">1101</td><td align="center">15</td><td align="center">D</td></tr><tr><td align="center">14</td><td align="center">1110</td><td align="center">16</td><td align="center">E</td></tr><tr><td align="center">15</td><td align="center">1111</td><td align="center">17</td><td align="center">F</td></tr><tr><td align="center">16</td><td align="center">10000</td><td align="center">21</td><td align="center">F1</td></tr></tbody></table><h2 id="1-4-1-数制转换"><a href="#1-4-1-数制转换" class="headerlink" title="1.4.1 数制转换"></a>1.4.1 数制转换</h2><ol><li><p><strong>二进制（B）与十进制（D）</strong></p></li><li><p>十进制转化为二进制    1. 整数十进制转二进制<br> 运算规则： 整数部分除以2取余，直至商为0。<br> 例：（26）10=（）2    2. 小数十进制转化为二进制<br> 运算规则：小数部分乘以2取整，直至小数部分为0或达到所需精度为止。<br> 0.628D=0.1010000B(十进制小数不一定能精确转化，保留5位）</p></li><li><p>二进制数转十进制<br>运算规则：二进制数按基数，位权数，展开<br>例如：（1011.1）2=（11.5）10<br>1×23+0×22+1×21+1×20+1×2-1=8+0+2+1+0.5=11.5</p></li><li><p><strong>二进制（B）与八进制（O）（1位八进制数对3位二进制数）</strong></p></li><li><p>二级制（B）转八进制（O）<br>运算规则：二进制整数部分，从右向左依次取3位，不足3位，左补0；二进制的小数部分，从左向右依次取3位，不足3位，右补0，取完后，将每组二进制数转化为十进制数。    1. 例如：（1101.01）2=（15.2）8</p><table><thead><tr><th align="center">B</th><th align="center">D</th><th align="center">O</th></tr></thead><tbody><tr><td align="center">001</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">101</td><td align="center">5</td><td align="center">5</td></tr><tr><td align="center">010</td><td align="center">2</td><td align="center">2</td></tr></tbody></table></li></ol><pre><code>2. 例：110110.1B=（156.4）8  |B      |D      |O  | :-: | :-: | :-: |  |001    |1      |1  |101    |5      |5  |110    |6      |6  |100    |4      |4</code></pre><ol start="2"><li><p>八进制（O）转二进制（B）<br>运算规则：将每个八进制数看做十进制数，转二进制数，保持三位。<br>例：（156.4）8=（1101110.1）2</p><table><thead><tr><th align="center">O</th><th align="center">D</th><th align="center">B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">001</td></tr><tr><td align="center">5</td><td align="center">5</td><td align="center">101</td></tr><tr><td align="center">6</td><td align="center">6</td><td align="center">110</td></tr><tr><td align="center">4</td><td align="center">4</td><td align="center">100</td></tr></tbody></table></li><li><p><strong>二进制（B）与十六进制（H）（1个十六进制对应4个二进制）</strong></p></li><li><p>二进制转16进制<br>运算规则：二进制整数部分，从右向左依次取4位，不足4位，左补0；二进制的小数部分，从左向右依次取4位，不足4位，右补0，取完后，将每组二进制数转化为十进制数。超过9的数，分别用ABCDEF表示。<br>例：（1101.01）2=（D.4）16</p><table><thead><tr><th align="center">B</th><th align="center">D</th><th align="center">H</th></tr></thead><tbody><tr><td align="center">1101</td><td align="center">13</td><td align="center">D</td></tr><tr><td align="center">0100</td><td align="center">4</td><td align="center">4</td></tr></tbody></table></li><li><p>十六进制转二进制<br>运算规则：将每个十六进制数，看做十进制，转二进制。<br>3AC.DH=（1110101100.1101）2</p><table><thead><tr><th align="center">H</th><th align="center">D</th><th align="center">B</th></tr></thead><tbody><tr><td align="center">3</td><td align="center">3</td><td align="center">0011</td></tr><tr><td align="center">A</td><td align="center">10</td><td align="center">1011</td></tr><tr><td align="center">C</td><td align="center">12</td><td align="center">1100</td></tr><tr><td align="center">D</td><td align="center">13</td><td align="center">1101</td></tr></tbody></table></li><li><p>十进制与八、十六进制<br>建议：先转二进制，再转相应进制。<br>若直接转<br>十进制转八进制：方法同上。整数部分除以8，小数部分乘以8。<br>十进制转十六进制：方法同上。整数部分除以16，小数部分乘以16。</p></li><li><p><strong>【重点】</strong></p></li><li><p><strong>位 (bit) 或字位：</strong>最小的存储单位（可以容纳0和1其中之一），即用0或1存储数据。</p></li><li><p><strong>字 (word)：</strong>即机器字长，是自然的存储单位，</p></li><li><p><strong>字长 (word length)：</strong>CPU同一时间处理数据的二进制位数。如计算机16位、32位、64位。</p></li><li><p><strong>字节 (Byte) ：</strong>处理数据的基本单位。1字节(Byte) = 8位(bit) （常用的字节是八位的字节，即包含八位的二进制数）</p></li><li><p><strong>常用的字节计数单位：</strong><br>1KB（Kilobyte，千字节）＝ 1024 Byte (210B) ＝2^10B<br>1MB（Megabyte，兆字节，百万字节，简称“兆”） ＝ 1024 KB ＝2^20B<br>1GB（Gigabyte，吉字节，十亿字节，又称“千兆”）＝ 1024 MB ＝2^30B<br>1TB（Terabyte，太字节，万亿字节） ＝ 1024 GB ＝2^40B<br>其他：PB（拍字节），EB（艾字节），ZB（泽字节），YB（尧字节），BB，NB，DB。</p></li></ol><h2 id="1-4-3"><a href="#1-4-3" class="headerlink" title="1.4.3"></a>1.4.3</h2><p><strong>【重点】</strong><br>  机器数：是将符号“数字化”的数，是数字在计算机中二进制表示形式。<br>  机器数的两个特点是：一是符号数字化，二是数的大小受机器字长的限制。</p><p><strong>【说明】</strong>符号（正号或者负号）数字化<br>采用1bit<br>（0）2表示正号（正数）<br>（1）2表示负号（负数）</p><p><strong>【问】1Byte=8bit</strong><br>一个字节长度的存储单元中，能表示的十进制范围。<br><code>0000 0000～1111 1111</code><br><code>0～255</code><br>字长8/16/32/64<br>字长16位，能表示的数据范围0～（216-1）=65535<br>字长32位，能表示的数据范围0～（4G-1）<br>     232=230*22=4G</p><h2 id="1-4-4-数据运算"><a href="#1-4-4-数据运算" class="headerlink" title="1.4.4  数据运算"></a>1.4.4  数据运算</h2><ol><li><p>算术运算：＋、－、*、/<br>二进制算术运算，建议先转十进制后，再转二进制。</p></li><li><p>逻辑运算</p></li><li><p>逻辑 与<br>运算符有：∧、∩、×、AND、·<br>运算规则：只有1×1=1，其余全部为0（0表示FALSE，非0表示TRUE）<br>例（填空）以下逻辑运算式的结果是（）<br>101101×1011=<br>【说明】×、＋如果不说明是逻辑运算，默认的算术运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">101101</span><br><span class="line">缺位补0</span><br><span class="line">∩001011</span><br><span class="line">  001001</span><br></pre></td></tr></table></figure></li><li><p>逻辑 或<br>运算符有：＋、∪、∨、OR四个符号<br>运算规则：只有0+0=0，其余全部为1</p></li><li><p>逻辑 非<br>取反<br>例；NOT 1001=0110</p></li></ol><h2 id="1-4-5-数值-在计算机中的编码形式（存储形式）"><a href="#1-4-5-数值-在计算机中的编码形式（存储形式）" class="headerlink" title="1.4.5 数值  在计算机中的编码形式（存储形式）"></a>1.4.5 数值  在计算机中的编码形式（存储形式）</h2><ol><li><p>整数，编码形式【重点】<br>整数在计算机中采用二进制的补码形式编码。</p></li><li><p>正整数的编码方式    1. 最高（左）位是符号位，用（0）2表示    2. 正整数的原码=反码=补码    3. 例如：求10在计算机中编码方式（占1Byte的空间）？<br>步骤一 求原码=00001010B<br>（10）10=（1010）B<br>【分析】最高位0是符号位，表示正数，占用8bit<br>步骤二 原码=反码=补码<br>【结果】10在计算机中的存储形式是00001010</p></li><li><p>负整数 编码形式    1. 最高（左）位是符号位，用（1）2表示    2. 例如，-10在计算机中的编码形式，（占1Byte）的空间<br>第一步      求原码=1000 1010<br>第二步      求反码=1111 0101<br>【反码是符号位不变，原码取反】<br>第三步     求补码=反码+1=1111 0101+1=1111 0110</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1111 0101</span><br><span class="line">+       1</span><br><span class="line">1111 0110  </span><br></pre></td></tr></table></figure><p>结果1111 0110  是-10在计算机中的编码形式</p></li><li><p>浮点数（小数）<br>采用阶和尾的形式编码</p></li><li><p>101B=0.110101     </p></li><li><p>4=0.1234×103</p></li></ol><p>【拓展（知道就好无需记住范围）】<br>单精度浮点型（Single）: 负数范围:-3.402823E38 ~ -1.401298E-45<br>正数范围:1.401298E-45 ~ 3.402823E38<br>双精度浮点型（Double）: 负数范围:-1.797,693,134,862,32E308 ~-4.940,656,458,412,47E-324<br>正数范围:4.940,656,458,412,47E-324 ~1.797,693,134,862,32E308</p><h2 id="1-4-6-编码形式-西文字符编码和汉字编码"><a href="#1-4-6-编码形式-西文字符编码和汉字编码" class="headerlink" title="1.4.6 编码形式  西文字符编码和汉字编码"></a>1.4.6 编码形式  西文字符编码和汉字编码</h2><p>整数编码形式、浮点编码形式</p><ol><li>西文编码形式</li><li>西文字符在计算机中采用ASCII码形式，《美国标准信息交换代码》</li><li>每个ASCII占用1Byte=（8bit）的存储空间；最高（左）位是检验位（验证数据传输的正确性，默认（0）2；后7位（bit）是编码位，共有27=128种编码形式（0－127），即：共有128个ASCLL字符。<br>210=（10 000 000 000）2=（1024）10<br>27=（10 000 000）2</li><li>其中33个是命令控制字符（DEL、CR等），不能打印输出，其他95个是可打印输出字符（SP、A、c、9等）</li><li>对应ASCII码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">要记住数字0的ASCII码&#x3D;0011 0000B&#x3D;48，则数字8对应的ASCII是56；</span><br><span class="line">要记住字母A的ASCII码&#x3D;0100 0001B&#x3D;65，则字母D对应的ASCII是68；</span><br><span class="line">要记住字母a的ASCII码&#x3D;0110 0001B&#x3D;97，则字母z对应的ASCII 是122。</span><br></pre></td></tr></table></figure>例1：求字母F的ASCII十六进制形式（要求步骤）<br>答：0100 0110B=46H<br>例2：求数字9的ASCII十六进制形式（要求步骤）<br>答：0011 1001B=39H</li><li>ASCII的编码大小顺序<br>SP＜数字＜@＜大写字母＜小写字母＜汉字机内码</li></ol><p><strong>(注意)所有的PC机，必须使用的编码方式是ASCII</strong></p><ol start="2"><li><p> 汉字编码</p></li><li><p>汉字国际码或交换码，是汉字排序。</p></li><li><p>国际码或交换码 不是 汉字在计算机中的编码形式。</p></li><li><p>国际码 将 汉字 和 图形符号（字符）划分为<br>   按拼音排序：</p><pre><code> 一级汉字（常用汉字，按拼音排序）3755个。 二级汉字（不常用汉字，按部首排序）3008个。</code></pre><p>   按部首笔画排序：</p><pre><code> 图形符号682个</code></pre><p>【总结】国际码字符集共有3755+3088=6763个<br>   国际码共有6763+682=7445个编码。<br>   我国制定的国际码标准是GB2312-1980<br>   美国制定的国际码标准是UTF-8</p></li><li><p>区位码<br>①区位码 是汉字排列，按区码（X轴）和位码（Y轴）排列进行编码。<br>不是汉字在计算机中的编码形式；<br>②区码、位码采用十进制表示，取值范围01～94<br>例如：汉字“玻”的区位码是1803，其中区码是18，位码是03。</p></li><li><p><strong>【重点】机内码（汉字机内码，简称：内码）</strong>    1. 机内码是汉字在计算机中的编码形式。    2. 机内码采用二进制编码；每个汉字机内码占用2Byte的存储空间(ASCII码占用1Byte)。两个字节的最高位都是（1）2，实现了机内码与ASCII的区分（因为ASCII的最高位固定是(0)2）    3. 将区位码转机内码方式【重点】<br> 第一步 区码+20H（32D）→交换码（十六进制表示）</p><pre><code>   位码+20H（32D）→交换码（十六进制表示）</code></pre><p> 第二步 区码+20H+80H（128D）→高位机内码（H表示）</p><pre><code>   位码+20H+80H（128D）→低位机内码</code></pre><p> 80H=1000 0000<br> 第三步，答汉字的机内码是高位+地位H<br> （考试时，机内码采用十六进制表示）</p><ol><li>例1：求1803的机内码（以H形式表示）<br>高位机内码=18+32+128=1011    0010B=B2H<br>低位机内码=03+32+128=1010    0011B=A3H<br>【结果】汉字1803机内码是B2A3H</li><li>例2：某文字的区位码是2162，求汉字机内码的十六进制形式（步骤）<br>方法一：<br>机内码高位字节=31+20H+80H=31+32+128=191=1011 1111B=BFH<br>机内码低位字节=62+20H+80H=62+32+128=222=1101 1110B=DEH<br>答：机内码的十六进制是BFHDEH<br>20H=32    80H=128</li></ol></li><li><p>输入码（简称：外码）</p></li><li><p>输入码分为：音码、形码、音形码（混合码）</p></li><li><p>音码是拼音输入法中的输入码<br>形码是五笔输入法中的输入码<br>音形码是五笔+拼音输入法中的输入码</p></li><li><p>字形码（= 字库码 = 字模码）<br>是汉字输出时的字体、字形、字号。</p></li></ol><p><strong>【重点】汉字输出有2种形式</strong></p><ol><li>采用点阵形式：<br>例：某汉字采用16<em>16点阵方式输出，求占用的存储空间？单位是位bit。<br>16</em>16bit/8=32Byte<br>例：1000个32<em>32点阵的汉字，占用的存储空间？<br>32</em>32bit/8*1000=128KB=128000Byte</li><li>采用全真字体（True Type）是矢量图，缩放旋转不会变形    <strong>【区别】汉字机内码（编码）占用的空间2Byte.</strong></li></ol><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="导言【复习】冯氏工作原理第一条"><a href="#导言【复习】冯氏工作原理第一条" class="headerlink" title="导言【复习】冯氏工作原理第一条"></a>导言【复习】冯氏工作原理第一条</h2><ol><li>一套完整的计算机系统=硬件系统+软件系统</li><li>计算机硬件系统=运算器（核心）+控制器+存储器（内存）+输入设备+输出设备</li><li>CPU（中央处理器）=运算器+控制器.<br>CPU芯片（物理设备）=CPU+寄存器<br>（寄存器）是CPU自带的存储器，用于存储运算的中间数据和要执行下一条指令地址</li><li>主机=CPU+内存</li><li>外设（外部设备）=输入设备+输出设备</li><li>计算机的硬件系统=主机+外设</li><li>软件系统=系统软件+应用软件</li><li>软件=程序+文档（+数据）<br>软件完成一个任务。（如汉字处理软件）<br>程序完成一个功能。（如打印）程序是一系列指令的集合。<br>指令完成一个基本操作。</li><li>计算机中所有的功能，都是软件的功能，没有安装软件的计算机，没有任何功能，称“裸机”。</li></ol><h2 id="2-1-1-计算机的硬件系统的功能"><a href="#2-1-1-计算机的硬件系统的功能" class="headerlink" title="2.1.1  计算机的硬件系统的功能"></a>2.1.1  计算机的硬件系统的功能</h2><ol><li>运算器的功能是实现算术运算和逻辑运算（属于计算机的核心功能）（ALU=运算器）<br>例：（判断）计算机实现算术运算功能……….F（两个功能）</li><li>控制器的功能（分三步）p28</li><li>读指令：（从内存中读取）</li><li>译码、解释执行（将指令转为机器语言）</li><li>指挥其他部件协调一致工作。</li></ol><p>  <strong>【说明】CPU中央处理器（简称：处理器）；PC机中使用的CPU，称：微处理器。</strong><br>    1. 微型计算机中的核心设备是微处理器<br>    2. 微处理器的生产商有<br>      Intel        品牌    Pentium core<br>      AMD    品牌    Duron athlon<br>      <strong>微处理器划分年代的依据（断代依据）是：字长</strong><br>3. 存储器的功能（记忆功能）</p><ol><li>存储器=内存（内部存储器或主存）+外存（外部存储器或辅存）</li><li><strong>【重点】内存和外存的区别</strong>    1. 内存中存储的指令（正在运行的程序）和数据，是动态的。内存中的数据既能读，也能写，CPU只能直接访问内存中的指令或数据；内存分为RAM（随机存储器）和ROM（只读存储器）内存容量一般指RAM（内存条）的容量，内存中数据断电后，全部丢失（不能恢复）。    2. 外存中存储的是文件，是静态的。外存中的数据只有先进入内存后，才能被CPU处理；外存指硬盘、光盘、U盘等；外存容量一般指硬盘的容量，外存的数据断电后，不会丢失</li><li><strong>【重点】RAM和ROM的区别</strong>    1. RAM 随机存储器，存储是指令和数据；RAM中的内容，即可读也可写（修改）；断电后信息全部丢失。    2. ROM只读存储器；存储是系统信息；ROM中内容只能读，不能写。断电后，信息不会丢失。</li><li><strong>【重点】RAM分为DRAM（动态RAM）和SRAM（静态RAM）两种材料</strong>    1. DRAM由于需要定期（周期性）刷新，所以速度慢，一般作为制作内存条的材料；    2. SRAM无需刷新，所以工作速度快，SRAM是制作Cache（高速缓存）的材料    <strong>【说明】高速缓存存储器（Cache）的功能：用于解决CPU速度快和内存（RAM）速度慢的速度不匹配问题。而他们中间设置的缓存空间。</strong></li><li>输入设备的功能将外部的程序或数据输入计算机内的<br>常用的输入设备：键盘（必不可少）、鼠标、扫描仪、麦克风等。</li><li>输出设备的功能将计算机处理结果显示在打印机、屏幕等。<br>常用的输出设备有显示器（必不可少）、打印机、绘图仪、仪表等。</li></ol><p><strong>【特别的】</strong>硬盘（外存）即是输入，也是输出设备。<br>将硬盘中的数据读入内存时，是输入设备（打开）<br>将内存中的数据写入硬盘时，是输出设备（保存）</p><h2 id="2-1-2-某专业同学要购置一台PC机，列出要购买的硬件设备及其相应的功能"><a href="#2-1-2-某专业同学要购置一台PC机，列出要购买的硬件设备及其相应的功能" class="headerlink" title="2.1.2 某专业同学要购置一台PC机，列出要购买的硬件设备及其相应的功能"></a>2.1.2 某专业同学要购置一台PC机，列出要购买的硬件设备及其相应的功能</h2><ol><li><p>主板</p></li><li><p>主板是计算机中最大设备（印刷电路板），是其他设备（所有板卡）的载体。</p></li><li><p><strong>【重点】主板上有两个芯片组：</strong>    1. 北桥芯片：控制管理CPU与内存、显存之间数据传输。    2. 南桥芯片：控制管理主机（内存）与外设（输入设备和输出设备）之间数据传输。<br> 主板上有两个芯片：</p><ol><li>BIOS的ROM芯片，存储的是硬件最基本的驱动程序，利用BIOS芯片，Windows系统自动识别新添加的硬件，并自动安装驱动程序（PnP即插即用）</li><li>CMOS的ROM芯片，存储的是配置信息（如，开机密码口令、日期时间、启动顺序等）。计算机断电后，依靠主板上的一块高能电池供电。</li></ol></li><li><p>USB接口（通用串行总线接口）    1. 传输数据    2. 充电</p></li><li><p>CPU=运算器+控制器<br> CPU=CPU+寄存器</p></li><li><p>存储器</p></li><li><p>内存：指内存储器    1. ROM    只读存储器（不能写入）    2. PROM   可编程只读存储器（只能写入一次）    3. EPROM  可擦除可编程只读存储器（可删除可多次写入）    4. EEPROM    带电可擦可编程只读存储器（拥有十万次擦写寿命，如今取代了EPROM）    5. CD-ROM    只读光盘存储器</p></li><li><p>外存：一般指硬盘：硬盘分为机械硬盘和固体硬盘    <strong>机械硬盘性能指标：</strong>    1. 平均寻道时间（磁头访问到存储在磁道和扇区中数据所需时间）    2. 数据传输速率    3. 磁盘转速（盘片转速：5400转/分钟 7200r/m 10000r/m）    4. 高速缓存的容量</p></li><li><p>固体硬盘的特点：    1. 读写速度快    2. 体积小    3. 无噪声    4. 低能耗    5. 防震抗摔能力强    6. 工作温度范围大</p></li><li><p>输入设备P32（在下面）</p></li><li><p>输出设备</p><ol><li>显卡：监视器和显示适配器</li><li><strong>显示器的性能指标</strong></li><li>显示器分为：CRT、LCD（液晶）</li><li>显示器的性能指标     1. 分辨率，指屏幕区域中显示最大像素（px）点的个数。<br> 例如：1024×768，表示屏幕上有1024列*768行个像素。<br> 分辨率越高，图像越清晰     2. 刷新频率，指每秒钟屏幕上显示图像（图片）的帧（张）数。<br> 例如：60Hz，表示每秒钟显示60张图片<br> 刷新频率越高，图像越清晰</li><li>颜色质量（颜色深度），表示每像素中所携带的表示颜色的位（bit）数。<br> 例：32位（bit）表示每个像素可能出现的颜色数232个，<br> 颜色质量越大，色彩越丰富，图像越逼真。</li><li>屏幕尺寸    单位inch（英寸），对角线长度<br> 计算机的颜色采用三原色（RGB（红绿蓝）），每种颜色占用1Byte的空间，三种颜色共占用3Byte的空间。<br> 例（选择）、某显示器的分辨率1024<em>768.，刷新频率60Hz，颜色质量32位，彩色显示，则每秒钟显示图像占的内存空间。<br> 内存空间=1024</em>768<em>32bit/8</em>60<em>3=？Byte<br> =1024</em>768<em>32bit/（8</em>60*3）</li><li>打印机</li><li>分为 击打式打印机 和 非击打式打印机</li><li>击打式打印机指：针式打印机，清晰度由打印机的打印头的撞针数决定。</li><li>非击打式打印机指：喷墨打印机、激光打印机，清晰度由墨点数决定。     <strong>【常识】：</strong><br>显示器的清晰度指标ppi（Px per inch）<br>打印机的清晰度指标dpi（Dot per inch）</li></ol></li></ol><h2 id="2-2-计算机系统-硬件系统-软件系统"><a href="#2-2-计算机系统-硬件系统-软件系统" class="headerlink" title="2.2 计算机系统=硬件系统+软件系统"></a>2.2 计算机系统=硬件系统+软件系统</h2><h2 id="2-2-1-软件系统"><a href="#2-2-1-软件系统" class="headerlink" title="2.2.1 软件系统"></a>2.2.1 软件系统</h2><ol><li>软件系统=系统软件+应用软件</li><li>系统软件=操作系统+编程语言和语言处理系统+数据库管理系统+服务软件+驱动程序</li><li>操作系统</li><li>是最接近硬件的底层软件，是其他软件运行的平台。</li><li>操作系统概念（三句）控制和管理计算机中所有的硬件资源和软件资源，是所有软件运行的平台；是用户与计算机的接口。</li><li>操作系统的功能（五个）：处理器管理（管CPU）、存储管理（管内存）、设备管理（管I/O设备）、文件管理、作业管理（=进程管理，为运行的文件分配CPU资源和内存资源）</li><li>常用的操作系统<br>客户机DOS（字符界面）、Windows7/8/10/XP、<br>服务器Windows2008/2012、Linux、Unix、Novell netware等。<br>移动端 Android、ios等</li><li>编程语言 第一代、第二代、第三代<br>语言处理系统  三个翻译</li><li>数据库系统 ORACLE、SQL server、ACCESS</li><li><strong>【补充】驱动程序</strong></li><li>所有的硬件，使用之前必须先安装驱动程序后才能使用；</li><li>由于主板上有BIOS的ROM芯片，是硬件最基本的驱动程序，所以在Windows中支持PnP（即插即用）功能。Windows自动识别新添加的硬件，并自动为他安装驱动程序。<br>例（判断）：<br>PnP设备无需安装驱动程序。………………….F<br>USB接口无需驱动即可使用。………………….F</li></ol><h2 id="2-2-3-应用软件-P36－P37"><a href="#2-2-3-应用软件-P36－P37" class="headerlink" title="2.2.3 应用软件   P36－P37"></a>2.2.3 应用软件   P36－P37</h2><h2 id="2-3-1-指令"><a href="#2-3-1-指令" class="headerlink" title="2.3.1 指令"></a>2.3.1 指令</h2><ol><li>软件是完成一个任务；软件=程序+文档</li><li>程序是完成一个功能；程序是一系列指令的集合。</li><li>指令完成一个基本操作。</li><li><strong>【重点】指令=操作码+地址码（=操作数=操作对象）</strong></li><li>操作码是指令的功能。</li><li>地址码是指令操作的对象。 </li></ol><h2 id="2-3-2-计算机的工作原理"><a href="#2-3-2-计算机的工作原理" class="headerlink" title="2.3.2 计算机的工作原理"></a>2.3.2 计算机的工作原理</h2><h2 id="2-3-3-BUS和interface"><a href="#2-3-3-BUS和interface" class="headerlink" title="2.3.3 BUS和interface"></a>2.3.3 BUS和interface</h2><ol><li>总线（公共通道）</li><li>计算机中采用总线的原因。    1. 成本低，扩展方便    2. 结构简单，易于维护。</li><li><strong>计算机中系统总线分为：数据总线、地址总线、控制总线。</strong></li><li>计算机內部数据传输采用总线结构（公共通道）</li><li>计算机内部采用总线结构的原因：    1. 优点：结构简单，易于实现，维护方便，成本低    2. 缺点：访问时延大（访问速度慢）<br> 地址总线功能：传输地址信息，是单向的<br> 主板上地址总线的宽度，决定了CPU能访问内存的容量<br>例：地址总线宽度是16位，允许CPU能访问的内存容量216=64KB<br>例：地址总线宽度是32位，允许CPU能访问的内存容量232=4GB</li><li>数据总线功能：传输数据信息是双向的，数据总线宽度决定CPU的字长<br> 例：主板上的数据总线宽度是64位，则允许CPU访问的字长是64位<br>控制总线功能：用于传输控制信息（信号）</li><li>接口（是主机和外设之间的，接口电路或I/O接口电路）<br>主板上的接口电路有显卡（显示适配器）、声卡、网卡、IDE（硬盘和主机的接口、SATA、SCASI、USB通用串总线接口）等。<br>接口的功能：由于主机工作速度快，外设速度慢，所以需要接口电路作为数据的缓存空间。<br>外部设备必须先连接在接口上，接口再挂接在总线结构上之后，才能与主机（中的内存）实现数据传输。</li></ol><h2 id="2-4-2-【重点、简答、多选、判断】计算机性能指标？或影响计算机运行的因素？"><a href="#2-4-2-【重点、简答、多选、判断】计算机性能指标？或影响计算机运行的因素？" class="headerlink" title="2.4.2 【重点、简答、多选、判断】计算机性能指标？或影响计算机运行的因素？"></a><strong>2.4.2 【重点、简答、多选、判断】计算机性能指标？或影响计算机运行的因素？</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">1. 主频</span><br><span class="line">2. 字长</span><br><span class="line">3. 内存容量</span><br><span class="line">4. 外存容量</span><br><span class="line">5. 软件配置</span><br><span class="line">6. 计算机的可靠性。</span><br></pre></td></tr></table></figure><p><strong>【说明】</strong></p><ol><li>主频 字长</li><li>内存RAM的容量，越大，越快。</li><li>外存硬盘的容量，越大，越快。</li><li>计算机的可靠性是指计算机无故障、连续工作时间。</li></ol><h1 id="第三章-操作系统"><a href="#第三章-操作系统" class="headerlink" title="第三章 操作系统"></a>第三章 操作系统</h1><h2 id="3-1-4-操作系统按处理任务的实时性划分"><a href="#3-1-4-操作系统按处理任务的实时性划分" class="headerlink" title="3.1.4 操作系统按处理任务的实时性划分"></a>3.1.4 操作系统按处理任务的实时性划分</h2><ol><li>分时操作系统  是将CPU资源和内存资源划分成若干个等分，平均分配给多个任务，同时执行，特点：资源利用率高，执行效率低</li><li>实时操作系统  预留CPU资源和内存资源，任务一出现，立即执行；特点：资源利用率低，执行效率高。</li><li>网络操作系统  提供网络服务功能。</li></ol><h2 id="3-4-1"><a href="#3-4-1" class="headerlink" title="3.4.1"></a>3.4.1</h2><ol><li>Windows退出（选择）</li><li>注销  释放用户登录占用的系统资源（CPU资源和内存资源），计算机系统取消对用户使用资源的授权。</li><li>切换用户【重点】<br>XP是单用户（每次只允许一个用户登录），多任务操作系统。<br>Windows 7 是多用户（允许同事多个用户登录）、多任务操作系统。<br>切换用户：在多个登录中选择当前用户（可以使用资源的用户）</li></ol><h2 id="3-4-2（输入法“智能”）"><a href="#3-4-2（输入法“智能”）" class="headerlink" title="3.4.2（输入法“智能”）"></a>3.4.2（输入法“智能”）</h2><ol><li><p>键位  功能</p></li><li><p>复制、剪切、粘贴、快捷键（组合键）<br>使用之前，必须选中 <strong>ctrl +C</strong> 复制（将选中的内容，在剪贴板中制作一个副本，剪贴板是内存空间）    <strong>【说明】剪贴板是内存空间</strong>，剪贴板中的内容，可以通过CTRL+V粘贴到指定位置，可被粘贴多次，直到关机。    <strong>Ctrl +X</strong> 剪切（将选中的内容，移动到剪贴板）    <strong>Ctrl +V</strong> 粘贴（将剪贴板中的内容，复制到指定位置）</p></li><li><p><strong>Ctrl +Z</strong> 撤销最近一次的操作    <strong>Ctrl +Y</strong> 回复撤销操作，没有撤销，则没有恢复。</p></li><li><p><strong>delete</strong>  删除<br>在资源管理器中，删除文件是将文件移入回收站。<br>（逻辑删除，回收站是硬盘的空间）<br>在文档中，删除的文字不会进入回收站，</p></li><li><p><strong>shift +Delete</strong> （shift+拖进回收站）<br>是将选中文件直接物理删除（不进回收站，不能恢复）。</p></li><li><p><strong>Alt+F4</strong>  关闭当前窗口（即活动窗口，就是当前正在被操作的窗口），还可以关机。<br>【说明】活动窗口就是当前正在被操作的窗口，任何情况下，只能有一个活动窗口。特点：标题栏颜色深色（不一定是最前面的窗口）<br>窗口是程序运行的界面。</p></li><li><p>活动窗口</p><table><thead><tr><th align="center"><strong>Alt+tab</strong></th><th align="center">选择活动窗口（能将最小化窗口还原）</th></tr></thead><tbody><tr><td align="center"><strong>Alt+Esc</strong></td><td align="center">切换活动窗口（不能还原最小化窗口）</td></tr></tbody></table></li><li><p>功能键</p><table><thead><tr><th align="center">F1</th><th align="center">打开帮助窗口</th></tr></thead><tbody><tr><td align="center">F2</td><td align="center">文件或文件夹重命名（改名）</td></tr><tr><td align="center">F3</td><td align="center">在资源管理器中打开搜索功能</td></tr><tr><td align="center">F4</td><td align="center">定位浏览器中的地址栏</td></tr><tr><td align="center">F5</td><td align="center">刷新</td></tr><tr><td align="center">F6</td><td align="center">选择Windows的启动方式</td></tr><tr><td align="center">F10</td><td align="center">激活窗口菜单（菜单栏）</td></tr></tbody></table></li><li><p>拖动功能 </p><table><thead><tr><th align="center">Ctrl+拖动</th><th align="center">（文件+文字）复制</th></tr></thead><tbody><tr><td align="center">Shift+拖动</td><td align="center">（文件、文字）移动</td></tr></tbody></table></li><li><p>Tab    制表键</p><table><thead><tr><th align="center">Home</th><th align="center">将光标插入点快速定位到当前行的行首</th></tr></thead><tbody><tr><td align="center">End</td><td align="center">将光标插入点快速定位到当前行的行尾</td></tr><tr><td align="center">Capes Lock</td><td align="center">（大写字母锁定键）灯亮，输入大写字母</td></tr><tr><td align="center">Num Lock</td><td align="center">灯亮，输入数字，灯灭，方向键</td></tr><tr><td align="center">Insert</td><td align="center">实现文档中插入和改写两种状态的切换</td></tr><tr><td align="center">Backspace</td><td align="center">退格键，删除光标插入点左侧字符</td></tr><tr><td align="center">Delete</td><td align="center">删除，删除光标插入点右侧字符。</td></tr><tr><td align="center">Shift（上档键）Ctrl（控制键）Alt（交替键）</td><td align="center">属于命令控制键，单独使用没有任何功能。</td></tr><tr><td align="center">Ctrl +Alt +Delete或Ctrl +Shift +ESC</td><td align="center">打开“任务管理器”</td></tr></tbody></table></li><li><p><strong>【补充】任务管理器功能：</strong>    1. 强制终止程序运行，关机    2. 查看CPU和内存资源占用    3. 启动新任务（新程序）    4. 排列桌面窗口<br>窗口在桌面上排列方式有：</p><ol><li>层叠：显示所有窗口的标题栏，只显示一个窗口内容。</li><li>堆叠和并排（平铺）：显示所有窗口标题栏和内容</li></ol></li></ol><pre><code>**【简答】桌面上窗口的排列方法：** 答：右击任务栏空白处，弹出的快捷菜单中选择“层叠、堆叠、并排显示窗口”命令。</code></pre><ol start="11"><li><p>Ctrl+A  全选</p></li><li><p>Ctrl+Esc  打开系统菜单（“开始”菜单）</p></li><li><p>Alt+space  打开当前窗口的系统菜单（“控制”菜单）</p></li><li><p>在文档编辑器中</p><table><thead><tr><th align="center">Ctrl+N</th><th align="center">新建文档</th></tr></thead><tbody><tr><td align="center">Ctrl+O</td><td align="center">打开文档</td></tr><tr><td align="center">Ctrl+S</td><td align="center">保存文档</td></tr><tr><td align="center">Ctrl+P</td><td align="center">打印文档</td></tr></tbody></table></li><li><table><thead><tr><th align="center">enter</th><th align="center">确定或文档中换段</th></tr></thead><tbody><tr><td align="center">ESC</td><td align="center">取消或关闭菜单</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table></li><li><p>输入快捷键</p><table><thead><tr><th align="center">Ctrl+shift</th><th align="center">选择输入法（在各种输入法间切换）</th></tr></thead><tbody><tr><td align="center">Ctrl+space</td><td align="center">打开或关闭中文输入法（中英文输入法切换）</td></tr><tr><td align="center">Shift+space</td><td align="center">全角和半角切换（汉字字符没有全角半角之分，只有ASCII才有）</td></tr><tr><td align="center">Ctrl+·</td><td align="center">中英文的标点符号的切换</td></tr></tbody></table></li><li><p>win键    打开“开始”菜单</p></li><li><p>win+E  打开“资源管理器”或“计算机”（W7）或“我的电脑”。</p></li><li><p>鼠标</p></li><li><p>操作的功能    1. 单击：选择    2. 双击：打开或执行    3. 右击：弹出快捷菜单    4. 指向：选择、菜单命令行或命令按钮。    5. 拖拽：移动或复制</p></li><li><p>鼠标指针的含义P55表3-3    1. “O”忙（鼠标指针含义）          “？”帮助    2. “手形☝”链接选择        “↑O”后台运行</p></li><li><p>鼠标指针的含义：“  O”不可用</p></li><li><p>可调整鼠标的主键和次键（左右手习惯）<br>可调整鼠标指针形状<br>可调整双击时间间隔</p></li></ol><h2 id="3-4-3"><a href="#3-4-3" class="headerlink" title="3.4.3"></a>3.4.3</h2><ol><li>桌面</li><li>不是窗口（是正在运行的程序）；是所有窗口运行的平台；</li><li>桌面组成元素：    1. 系统图标：计算机（或我的电脑）、回收站、网络（或网上邻居）、administrator（或我的文档）等。    2. 桌面背景：可选择任意图片。    3. 任务栏：“开始”菜单，快速启动区，任务栏等。</li><li>“开始”菜单包含了所有功能的快捷方式；通过“开始菜单”可以完成所有的操作<br>【说明】快捷方式是指向文件、文件夹或快捷方式的指针文件。快捷方式可以修改，删除快捷方式不会影响所指向的文件。快捷方式图标左下角箭头。</li><li><strong>【重点】窗口</strong></li><li>窗口是正在运行程序的界面（不是所有的程序运行都有窗口界面）</li><li>窗口组成元素：    1. 标题栏<ol><li>拖动标题栏 是移动窗口</li><li>双击标题栏是窗口最大化（窗口铺满整个屏幕），或还原（将最大化的窗口恢复到原大小、原位置）    2. 标题栏最左侧图标：控制菜单<br>通过控制菜单可精确移动窗口，改变窗口大小，双击控制菜单关闭窗口（Alt+F4）。    3. 标题栏右侧<br>最小化：不显示窗口内容，在任务栏有小图标：程序在后台继续运行<br>最大化（还原）参看上面。<br>关闭：结束程序运行，释放占用的CPU资源和内存资源。</li></ol></li><li>菜单栏（键盘操作）    1. 激活菜单方式Alt+（字母）菜单名后<br> 例：ALT+F 打开“文件”菜单    2. 菜单下命令行，执行命令行（项）直接按命令项后键位。<br> 例：Alt+E+C<br> Alt+E打开“编辑”菜单，C 执行“复制”命令。    3. 命令行左侧<br> ○表示单选按钮，在该组命令中只能选一个，<br> √表示复选按钮，在该组命令中可选择多个。    4. 命令行右侧<br> ▶ 表示有下一级子菜单。<br> …表示弹出对话框。</li><li>滚动条<br>当窗口内容多，窗口不足以显示所有内容时，出现滚动条。</li><li>对话框  是窗口与用户之间交互信息的界面。</li><li>对话框与窗口的区别。    1. 对话框不是窗口，是窗口执行时，与用户交互的界面。    2. 对话框大小不能改变。    3. （P63图3-18）标题栏？按钮，表示显示帮助信息；    4. 对话框中有选项卡（标签）    5. 对话框中<br> ○单选按钮，只能选一个<br> □复选框，可选择多个。<br> P68</li></ol><h2 id="3-5-资源管理器"><a href="#3-5-资源管理器" class="headerlink" title="3.5  资源管理器"></a>3.5  资源管理器</h2><p>操作系统中，资源管理器管理文件的原则：<br>采用 树形 目录结构存储文件。<br>文件按 名 存取。</p><h2 id="3-5-1"><a href="#3-5-1" class="headerlink" title="3.5.1"></a>3.5.1</h2><ol><li>打开方法</li><li>“开始”菜单→“程序”→“附件”→“资源管理器”</li><li>双击“我的电脑”（XP）=计算机（W7）=资源管理器</li><li>右击“开始”菜单，任意文件夹，弹出快捷菜单中选择“资源管理器”命令；</li><li>win+E。</li><li>资源管理器的界面</li><li>左侧是树形目录结构，包括桌面，我的电脑（计算机）、我的文档（administrator、文档）网上邻居（网络）、回收站。</li><li>右侧是左侧某1个选中文件夹下所有的信息（子文件夹和文件）；</li><li>在左侧    1. +或▶表示有下一级子文件夹，且没有展开；    2. -或⊿表示有下一级子文件夹，已经展开    3. 单击。<ol><li>+或▶，变-或⊿，在左侧展开下一级子文件夹，右侧没有变化；</li><li>-或⊿，变+或▶，在左侧树形目录收起，右侧没有变化。</li><li>单击文件夹，则右侧显示，文件夹下所有子文件夹和文件。<br>【文件夹=目录】</li></ol></li><li>查看或改变文件夹下信息显示方式。</li><li>执行资源管理器窗口“查看”菜单</li><li>文件或文件夹排列方式有:“详细信息”显示文件或文件夹的名称（文件名）、大小、类型（文件扩展名或类型名）、修改日期（是文件最近一次修改的日期，不是创建的日期）</li><li>显示或隐藏文件的方法</li><li>文件或文件夹具有存档（默认的）、只读，隐藏属性，如果是操作系统的文件，则还有系统属性（不允许修改）；（P71图3-24）</li><li>隐藏文件的方法:    1. 第一步:右击文件1，快捷菜单中选择“属性”命令，在“属性”对话框√隐藏（复选框）    2. 第二步:在“资源管理器”窗口中，执行“工具”菜单→“文件夹选项”命令，在“文件夹选项”对话框中选择“查看”选项卡。<br> ○不显示隐藏的文件或文件夹（不显示隐藏属性文件）<br> ⊙显示隐藏的文件或文件夹（显示隐藏属性文件）    <strong>【提醒】</strong>隐藏的文件可以用被调用，只要知道路径（存储路径），则可通过“开始”菜单→“运行”命令调用。</li></ol><h2 id="3-5-3"><a href="#3-5-3" class="headerlink" title="3.5.3"></a>3.5.3</h2><ol start="2"><li><p>文件名</p></li><li><p>文件名=文件标识名+扩展名（类型名）<br>例：硬盘1.jpg<br>标识名  扩展名<br>扩展名和类型名 表示文件的类型或打开方式<br>如:</p><table><thead><tr><th align="center">.jpg</th><th align="center">图片类型</th></tr></thead><tbody><tr><td align="center">.mp3</td><td align="center">声音文件</td></tr><tr><td align="center">.docx</td><td align="center">word文档</td></tr><tr><td align="center">.png</td><td align="center">图片文件类型</td></tr></tbody></table></li><li><p><strong>【重点】文件命名规则</strong>    1. 文件名长度不超过255个字符    2. 文件名中不可使用的字符包括<br> /、|、\、＜、＞、:、＂、?、*。共9个，其他都可以。<br> 例如，汉字，空格都可以    3. 在Windows中，文件名字母不区分大小写。</p></li><li><table><thead><tr><th align="center">.mid</th><th align="center">合成音乐文件，是多个文件的集合。</th></tr></thead><tbody><tr><td align="center">.rtf</td><td align="center">写字板文件类型。</td></tr></tbody></table><p> Windows操作系统中默认的：</p><table><thead><tr><th align="center">文件类型</th><th align="center">XP</th><th align="center">win7</th></tr></thead><tbody><tr><td align="center">图形（片）文件类型</td><td align="center">.bmp</td><td align="center">.png</td></tr><tr><td align="center">声音文件类型</td><td align="center">.wav</td><td align="center">.wma</td></tr><tr><td align="center">视频文件类型</td><td align="center">.avi</td><td align="center"></td></tr><tr><td align="center">文本文件类型</td><td align="center">.txt</td><td align="center">纯文本文件类型，可在所有的编辑器中打开。</td></tr></tbody></table></li><li><p>文件名通配符   ？  *</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">？ 可代表任意1个字符，且必须有一个</span><br><span class="line">*  可代表任意0-N个字符</span><br><span class="line">Del.*.*</span><br><span class="line">? C*.* 文件名第2个字符是C是所有文件</span><br></pre></td></tr></table></figure></li><li><p><strong>【问】</strong>文件图标与文件类型之间没有必要联系，文件图标修改了，不会影响文件类型</p></li><li><p>操作文件或（文件夹）</p></li><li><p>选择文件（或文件夹）<br>（对文件的操作，必须先选中，选中方法：单击）    1. 全选：Ctrl+A    2. 选中第一个文件后，shift+单击最后一个选中连续的多个文件；    3. Ctrl+逐个单击，选择不连续文件    4. 反选，先选中一个，Alt+E+I</p><pre><code>           Alt+E     //打开“编辑”           Inverter</code></pre></li><li><p>文件重命名 方法    <strong>（先选中）</strong>    1. F2    2. 单击文件名（单击图标不行）    3. 右击，快捷菜单中选择“重命名”    4. 资源管理器，“文件”菜单→“重命名”命令（必须先选中）。</p></li><li><p>文件复制    1. 在不同的硬盘分区间移动，是复制    2. Ctrl+拖拽，一定是复制    3. Ctrl+C，Ctrl+V（经过剪贴板的复制）</p></li><li><p>文件移动    1. 在同一个磁盘分区中拖动是，移动    2. shift+拖动，一定是移动    3. Ctrl+X、Ctrl+V（经过剪贴板的移动）    4. 共同的，右键移动，在弹出的快捷菜单中</p><ol><li>复制到当前位置</li><li>移动到当前位置</li><li>在当前位置创快捷方式</li></ol></li><li><p>文件删除    1. <strong>【重点】回收站</strong></p><ol><li>回收站是硬盘的空间；即可使用系统盘（C：）的空间，也可使用其他任意磁盘分区的空间；</li><li>回收站的空间可以调整</li><li>进入回收站的文件或文件夹，是逻辑删除；可以恢复（=还原）到之前删除的位置（不一定是桌面或我的文档）</li><li>进入回收站的文件，不能打开；将回收站中的文件删除后，则是物理删除不能还原了。</li><li>直接删除文件（不进入回收站）的情况</li><li>当要删除的文件，超过了回收站的可用空间时，直接物理删除；</li><li>shift+delete或shift+拖进回收，是物理删除<br>【总结】回收站是用于临时存放从硬盘中删除的文件。    2. 文件删除的方法:<br>选中后，delete或shift+delete</li></ol></li><li><p>搜索“文件”方法:<br>在“资源管理器中”    1. 按文件名；如F* 查找所有以F开头的文件    2. 按文件类型；如*.exe 查找所有类型为.exe（可执行文件）的文件    3. 按文件大小    4. 按最后一次，修改日期。    <strong>【提醒】F3是资源管理器中的搜索功能。</strong></p></li><li><p>创建快捷方式:    1. 快捷方式是指向文件、文件夹或快捷方式的指针文件。（哪些对象可创建快捷方式？）    2. 快捷方式文件的特征：图标左下角的箭头；    3. 创建快捷方式的方法:</p><ol><li>右击，快捷菜单中选择“发送到”→“桌面快捷方式”（只能在桌面上创建）</li><li>鼠标右键移动，在弹出快捷菜单中选择“创建快捷方式”</li><li>Alt+拖动，创建快捷方法。</li></ol></li></ol><h2 id="3-5-4-磁盘（硬盘）管理"><a href="#3-5-4-磁盘（硬盘）管理" class="headerlink" title="3.5.4 磁盘（硬盘）管理"></a>3.5.4 磁盘（硬盘）管理</h2><ol><li>硬盘使用之前，必须先分区，在格式化，后才能使用。</li><li>磁盘中的分区分为两类：主分区（必不可少，如C:）和扩展分区（可以没有）；扩展分区分区又可划分若干个逻辑分区（如D:、E:、F：等）</li><li>由于操作系统文件一般安装在主分区（C：）所以又称C：为系统盘；</li><li>分区的格式化，属于高级格式化；<br> 操作方法：资源管理器（或“计算机”）中右击磁盘分区，快捷菜单中选择“格式化”命令。</li><li>分区格式化（高格）的功能是</li><li>删除磁盘分区中所有信息（不可恢复）</li><li>创建文件系统（分区组织文件的方式）格式，文件系统格式有FAT（分件分配表）；ex-FAT、NTFS。</li><li>磁盘命名。</li><li>硬盘维护或磁盘管理</li><li>磁盘清理：删除磁盘中internet缓存文件，临时文件，可安全删除的文件（安装包）等；目的是提高磁盘空间的利用率（或提高磁盘可用空间量）。</li><li>磁盘检查（扫描）检查磁盘中是否有坏扇区或磁道，如果有修复；不能修复，打开标记，不再使用。目的：提高对磁盘访问速度。</li><li>磁盘碎片整理：一是将连续的磁盘存储空间整理为连续空间；二是将存储在不连续空间的文件整理为连续空间 。目的是：提高计算机运行速度。</li><li>磁盘备份：目的是 用于恢复被破坏的文件。</li></ol><h2 id="3-6-控制面板"><a href="#3-6-控制面板" class="headerlink" title="3.6 控制面板"></a>3.6 控制面板</h2><ol><li>凡是安装或卸载程序一律在“开始”菜单→“控制面板”命令，在“控制面板”窗口中，执行“程序和功能”命令。</li><li>凡是添加新硬件，一律“控制面板”窗口中的“设备和打印机”命令</li><li>显示设备</li><li>主题：桌面背景、屏保、窗口颜色、声音等；</li><li>设置方法：“控制面板”窗口中，“外观和个性化”命令；</li><li>桌面背景任意图片；桌面上的系统图标（回收站、计算机、网络等）可隐藏</li><li>屏幕保护程序</li><li>作用：保护桌面内容不被看（不是不被改）</li><li>屏保可选用系统自带方案，可以设置；</li><li>屏保密码就是系统登录密码；去除密码的唯一方式是输入密码。</li><li>【复习】屏幕分辨率，刷新频率，颜色质量，三原色，列计算式子</li><li>双击速度是指两次击打中间的时间间隔，间隔越大，双击的速度可越慢<br>对于行动迟缓的操作，双击速度应设置为慢，即时间间隔大。</li><li>添加或删除输入法</li><li>“控制面板”窗口中，执行“区域和语言”图标；</li><li>“文本服务和输入语言”对话框中“添加”或“删除”输入法。</li><li>网络中共享</li><li>共享文件，必须放在共享文件夹中，访问权限有读取（只能下载），修改，完全控制三个。</li><li>共享打印机共享硬件资源。</li></ol><h2 id="3-7"><a href="#3-7" class="headerlink" title="3.7"></a>3.7</h2><ol><li>记事本 默认的文件类型是.txt（纯文本文件），可在任意编辑器下打开，有文本格式（字体、字号）等。</li><li>画图 只能编辑图片，默认的文件类型:.bmp(XP)   、.png（win7）   （Windows中默认的图片文件类型）</li><li>命令提示符（字符界面的DDS环境）</li><li>进入方式    1. 方法一：“开始”菜单→“程序”→“附件”→“Windows命令提示符”命令；    2. 方法二：“开始”菜单→“运行”命令，在“运行”对话框的文本框中输入CMD，确定；</li><li>退出方式 执行exit命令</li></ol><h1 id="第四章-Word-2010-文字处理软件"><a href="#第四章-Word-2010-文字处理软件" class="headerlink" title="第四章 Word 2010 文字处理软件"></a>第四章 Word 2010 文字处理软件</h1><h2 id="4-1-导言-word-2010支持编程功能，即制作网页文件。支持-html-htm-mht-xml等类型的文件"><a href="#4-1-导言-word-2010支持编程功能，即制作网页文件。支持-html-htm-mht-xml等类型的文件" class="headerlink" title="4.1 导言 word 2010支持编程功能，即制作网页文件。支持.html   .htm   .mht   .xml等类型的文件"></a>4.1 导言 word 2010支持编程功能，即制作网页文件。支持.html   .htm   .mht   .xml等类型的文件</h2><h2 id="4-1-3"><a href="#4-1-3" class="headerlink" title="4.1.3"></a>4.1.3</h2><ol><li>启动Word</li><li>打开Word编辑器，自动创建一个空白文档；</li><li>双击某word.docx文件，打开word编辑器的同时，打开文件。</li><li>退出或关闭</li><li>单击标题栏上的X，是关闭窗口，窗口中的文档也关闭；</li><li>执行“文件”菜单→“退出”命令，关闭编辑器，关文档；</li><li>执行“文件”菜单→“关闭”命令，只关文档，word没有关闭；</li><li>Alt+F4是关闭窗口，即文档和word编辑器同时关闭。</li><li>关闭文档时，如果文档是新创建或修改后没有保存，则弹出对话框</li><li>“保存”保存文档，且关闭文档；</li><li>“不保存”不保存文档，且关闭文档；</li><li>“取消”即不保存，也不关闭文档，回到编辑状态。</li></ol><h2 id="4-1-4"><a href="#4-1-4" class="headerlink" title="4.1.4"></a>4.1.4</h2><ol><li>状态栏</li><li>当前页码 即光标插入点所在页</li><li>总页数</li><li>编辑状态（插入和改写）单击或insert切换</li><li>拼写和语法校验    1. 书√ 表示没有拼写或语法错误    2. 书× 表示有拼写或语法错误</li></ol><h2 id="4-1-5"><a href="#4-1-5" class="headerlink" title="4.1.5"></a>4.1.5</h2><ol><li>word中有五种视图模式页面视图、草稿视图、大纲视图、web版式视图、阅读版式视图。</li><li>各种视图特点</li><li>页面视图：显示所有的排版效果；包括字符格式，段落格式，页面排版格式（页眉和页脚），分栏，首字下沉等，分页采用页面形式。（是默认的视图效果）</li><li>草稿（普通）视图：只显示基本的字符、段落的排版效果，如果没有页面排版效果（页眉和页脚、分栏、首字下沉等）不显示自绘图形效果；分页采用一条长虚线形式表示，（以最简单方式显示排版效果）。</li><li>大纲视图：只显示章节标题，适用于编辑长文档</li><li>Web视图：没有页面排版效果（页眉和页脚等）；以一张长网页的形式显示所有内容（没有分页）；</li><li>阅读版式视图：以左右两页形式显示页面效果；没有页眉和页脚。<br>【说明】切换视图的方法    1. “视图”选项卡（菜单）    2. 状态栏中切换（“视图按键”）</li></ol><h2 id="4-2-文件的管理"><a href="#4-2-文件的管理" class="headerlink" title="4.2 文件的管理"></a>4.2 文件的管理</h2><ol><li>创建新文件</li><li>“文件”菜单→“新建”命令<br>默认使用空格白文档模板，创建新文档；</li><li>可以使用其他模板，创建新文档，如，博客文章、书法字帖等。</li><li>Ctrl+N新建文档。</li><li>打开文件<br>打开图标和Ctrl+0；</li></ol><p>  <strong>【重点】:</strong><br>    “文件”菜单→“最近使用的文档”，列出的是最近使用的文档<br>    设置“最近使用的文档”显示数量的方法，“文件”菜单→“word”选项。<br>3. 保存（“文件”菜单→“保存”命令；单击“保存”命令按钮或Ctrl+S）</p><ol><li>新建的文档，第一次保存，弹出“另存为”对话框（P105图4-13）    1. 默认的保存路径（位置）是“文档”；    2. 文件类型.word支持的文件类型有.docx（默认的文件类型）.dotx（模板文件）.html.htm.mht.xml（网页文件）.txt..rtf（文本文件）.pdf（图文件类型）不是图片。</li><li>对已存在的文档，进行编辑后，保存，则按原文件名，存放在原位置。</li><li>换名保存（“文件”菜单→“另存为”命令）<br>例如，打开ABC.docx文件，修改后，另存为ABD.docx文档，则    1. 当前文档是ABD.docx；ABC.docx文件被关闭；    2. 修改的内容在ABD.docx中，ABC.docx没有被修改；    3. 原文档（ABC.docx）没有被修改，已关闭。</li><li>自动保存</li><li>自动保存时每隔固定时间，自动将修改的内容；不是对文档进行了保存；</li><li>将修改的内容以临时文件的形式存储在硬盘中；用于意外（断电、死机等）发生时，恢复文档使用；</li><li>设置自动保存时间间隔方法<br>“文件”菜单→“word选项”命令下的“保存”项（P105图4-14）</li><li>保护文档（P106图4-15）</li><li>“文件”菜单→“信息”命令；</li><li>可对不同用户，设置不同的使用权限；</li><li>例如:<ol><li>张三用户 只能打开（读取）</li><li>李四用户 修改权限</li><li>王五用户 禁用</li></ol></li></ol><h2 id="4-2-2"><a href="#4-2-2" class="headerlink" title="4.2.2"></a>4.2.2</h2><ol><li>文字输入的原则<br>文字输入到达行尾是，继续输入，自动换行；段落结束时，enter，形成段落。</li><li>选择</li><li>在段落中，    1. 单击，光标插入点定位；    2. 双击，选中一个词；    3. 三击，选中一个段落；    4. Ctrl+单击，选中一句（句的结束标记是。？！……）    5. Alt+拖拽，形成一个矩形区域。</li><li>在文本选定区（左页边距）    1. 单击，选中一行；    2. 双击，选中一个段落；    3. 三击，选中全文。</li><li>其他    1. ctrl+拖动：选中不连续的字符区域；    2. 光标插入点定位到起始位置，shift+单击，选中连续的字符区域；    3. Ctrl+A全选；    4. shift+ctrl+home 选择从光标插入点到文档首全部字符。<br>【home、ctrl+home是快速移动光标插入点，home是到当前行的行首，ctrl+home是到文档首。】    5. shift+ctrl+end 选中从光标插入点到文档尾所有字符；    6. shift+home 选择光标插入点到行首的全部字符；    7. shift+end 选择光标插入点到行尾的全部字符。</li><li>复制、粘贴、剪切</li><li>复制或剪切命令灰色；表示文档中没有选择内容；（必须先选中，后操作）</li><li>粘贴    1. office剪贴板中最多保存最近24次复制或剪切操作；    2. 在一个文档中进行多次复制或剪切操作时，如果office没有关闭，则剪贴板中的24次内容都可被粘贴；如果关闭office，则只有最近一次的内容可被粘贴。</li><li>撤销和恢复</li><li>可撤销连续的多步操作，（不能撤销不连续的操作）；ctrl+2</li><li>恢复是撤销的取消，没有撤销没有恢复，恢复也可恢复连续的多步撤销操作。Ctrl+Y</li><li>查找、替换、定位</li><li>“开始”菜单→“编辑”功能区，“查找”和“替换”。</li><li>查找和替换可按格式，区分大小写，使用通配符（*？）等形式进行。<br>例如，将文件中（Ⅰ色、四号的“ABC”字符，替换为蓝色、加粗的“abc”）</li><li>定位是将光标插入点快速定位到指定位（注意：不是查找）<br>定位的依据可以是书签，页码，节码，段落，图标，脚注等所有对象。<br>Word排版分为字符排版、段落排版、页面排版</li></ol><h2 id="4-3-字符排版"><a href="#4-3-字符排版" class="headerlink" title="4.3 字符排版"></a>4.3 字符排版</h2><ol><li>例，将文档中指定的字符，设置为 楷体，四号，红色，加粗。</li></ol><p>  <strong>答：</strong>1. 选中 文档中“照抄题目指定的”字符<br>  2. 执行“开始”功能区→“字符”命令；（P111图4-21）<br>  3. 在“中文字符”下拉列表中选择“楷体”；在“字号”列表框中选择“四号”；在“字体颜色”下拉列表中选择“红色”；在“字形”列表框中选择“加粗”。<br>  4. 单机“确定”命令按钮。</p><ol start="2"><li>字符间距（字间距）指字符之间的距离<br>字符缩放 指字符本身的宽度（P111 图4-22）</li></ol><h2 id="4-3-2-段落排版"><a href="#4-3-2-段落排版" class="headerlink" title="4.3.2 段落排版"></a>4.3.2 段落排版</h2><ol><li>选中段落的方法<br>在段落中单击：文本选定区双击；段落中三击。<br>选中一个段落的意义=段落中全部字符+字符格式和段落格式+段落结束标识符。</li><li>标尺 功能</li><li>快速缩进段落设置</li><li>快速调速表格的行高和列宽。</li><li>设置制表位（符）</li><li>例如，将文档中指定的段落设置为首行缩进、左右各缩进4个字符；段前段后各1行；行间距1.2倍。</li></ol><p>  <strong>答：</strong>1. 选中 照抄题目要求的段落<br>  2. 执行“开始”功能区→“段落”命令（P112图4-24）<br>  3. 在“段落”对话框的“特殊格式”下拉列表中选择“首行缩进”，在“缩进”的“左侧”设置4字符，“右侧”设置4字符；在“间距”的“段前”1行，“段后”1行，在“行距”下拉列表中选择“多倍行距”，在“设置值”中设置1.2倍。<br>  4. 单击“确定”命令按钮<br>    【说明】<br>    1. 特殊格式有三种，无、首行缩进，悬挂缩进。<br>    2. 行距 有单倍行距、1.5倍行距、2倍行距、多倍行距；固定值（单位 磅）<br>    【总结】间距分为：字符间距、段落间距、行间距。</p><h2 id="4-3-3-边框和底纹"><a href="#4-3-3-边框和底纹" class="headerlink" title="4.3.3 边框和底纹"></a>4.3.3 边框和底纹</h2><ol><li><ol><li>字符边框 是选中字符后，设置，按行显示；</li><li>段落边框  是选中段落后，设置，按段落显示。</li><li>页面边框  默认的，对整个文档中所有的页面设置边框。</li></ol></li><li></li><li>底纹 是背景</li><li>底纹的样式有颜色、图案（不能使用图片底纹）</li></ol><h2 id="4-3-4-样式"><a href="#4-3-4-样式" class="headerlink" title="4.3.4 样式"></a>4.3.4 样式</h2><ol><li>样式是一系列排版命令的集合；</li><li>样式有字符样式和段落样式两种；使用样式命令，可简化排版操作。</li><li>用户创建样式，可修改、可以删除；word中系统自带的样式，不能修改。</li><li>模板文件是将一系列的样式保存为文件格式；默认的文件类型名是.dotx</li></ol><h2 id="4-3-5-项目符号和编号"><a href="#4-3-5-项目符号和编号" class="headerlink" title="4.3.5 项目符号和编号"></a>4.3.5 项目符号和编号</h2><ol><li>以段落为单位，设置符号或编号（不是以行为单位）。</li><li>项目符号或编号可任意设置格式（原格式可以修改）。</li></ol><h2 id="4-3-6-页面排版"><a href="#4-3-6-页面排版" class="headerlink" title="4.3.6 页面排版"></a>4.3.6 页面排版</h2><ol><li>首字下沉 操作后，首字成为文本框，占用若干行；（“页面布局”功能区→“首字下沉”命令项）。</li><li>分栏</li><li>选中连续的字符区域后，执行“页面布局”功能区→“分栏”命令项后，（P115图4-29）</li></ol><p>  <strong>【重点说明】</strong>字符区域 必须是连续的，默认的是对整篇文档进行分类，不一定是以段落为单位进行分栏，可以使段落中的一部分字符。<br>  2. 可设置多栏（最多11栏）<br>  3. 栏宽可以不同，栏间距可以不同<br>  4. 栏间可设置分割线<br>3. 页码</p><ol><li>“插入”功能区（菜单）→“页码”命令</li><li>可将页码放置在页面的任意位置；设置任意格式；</li></ol><p>  <strong>【提醒】</strong>页码除可使用阿拉伯数字外，还可使用罗马字母、汉字数字、字母等。<br>4. <strong>【重点】页面设置（默认的，是对整篇文档进行页面设置）</strong><br>    设置方法:<br>  “页面布局”功能区→“页面设置”命令（P117图4-31）</p><ol><li>“页边距”选项卡的功能。    1. 上、下、左、右的页边距    2. 纸张方向，默认的“纵向”，可设置为“横向”。<br>【补充】同一文档中，要设置不同的页面格式使用插入分节符功能</li><li>“纸张”选项卡    1. “纸张大小”默认的A4；可以设置纸张的任意大小（名片、入场券等）    2. “纸张来源”</li><li>【重点】“版式”选项卡<br> 页眉和页脚<br> □奇偶页不同<br> □首页不同</li><li>“文档网格”选项卡功能    1. “文字方向”（水平或垂直）    2. 分栏    3. 设置每页中的行数和每行中的字符数。</li><li>页眉和页脚</li><li>不是正文区，是页面排版；只有“页面视图”。才显示</li><li>“插入”选项卡（功能区）“页眉”和“页脚”命令。</li><li>其中可添加任意格式的内容，一般放置页码，日期时间等。</li><li>进入页眉和页脚区方法：双击页眉页脚区；<br>退出页眉和页脚区方法：双击正文区。</li><li>删除方法:    1. 删除页眉和页脚区内的内容后，自动删除    2. “插入”功能区→“页眉”→“删除页眉”</li></ol><h2 id="4-4-4"><a href="#4-4-4" class="headerlink" title="4.4.4"></a>4.4.4</h2><ol><li>打印（“文件”菜单→“打印”或ctrl+P）<br>打印范围</li><li>默认的，整篇文档</li><li>选中内容；</li><li>当前页；（光标插入点所在的页）</li><li>设置打印的页码范围，例如，1，3,7-9,12共6页内容。</li><li>打印预览 功能是显示打印的效果，即“所见即得”，目的是显示编辑排版效果，节约打印成本。</li></ol><h2 id="4-5-表格"><a href="#4-5-表格" class="headerlink" title="4.5 表格"></a>4.5 表格</h2><h2 id="4-5-1-插入表格的方法"><a href="#4-5-1-插入表格的方法" class="headerlink" title="4.5.1 插入表格的方法"></a>4.5.1 插入表格的方法</h2><p>先光标插入点定位到要插入表格的位置</p><ol><li>“插入”功能区→“表格”命令项</li><li>拖出表格的行数和列数（图4-37）</li><li>“插入表格”命令（P120图4-36），默认的2行5列</li><li>“绘制表格”命令，可手工绘制不规则的表格。</li><li>“文本转换为表格”命令（图4-38），文本间的分隔符有<br>段落标记：用于换行<br>逗号，空格，制表符：用于分列</li><li>选择</li><li>选中行，行首单击    <strong>【问】如何选择连续多行或不连续多行？</strong>    1. 连续多行？ 先选一行，shift+最后一行    2. 不连续多行？ Ctrl+单击</li><li>选择单元格 单元格左边框单击</li><li>表格左上角“全选”四向箭头    </li><li>插入行（列，单元格）<br>①在行尾回车，增加一行；（在单元格中回车，是增加行高）<br>②在最后一个单元格中，Tab键，是增加一行<br>③选中N行或N列，“表格工具”功能区→“插入行”，增加N行或N列。</li><li>删除行或列、单元格的方法<br>（delete键只能删除单元格中内容）<br>先选中，<br>①“表格工具”功能区→“删除”命令→“删除行，列，单元格表格”子命令；<br>②右击，快捷菜单中选择“删除行或列”。</li><li>合并单元格只能将连续的多个单元格合为一个单元格，并且所有单元格中的所有内容全存于一个单元格中。</li><li>拆分单元格，即在将一个单元格分为N行或N列。</li><li>单元格中内容的对齐方式 上中下，左中右，九种（图4-44）。</li><li>对表格进行设置，右击选择“表格属性”命令，可精确行高，列宽、单元格的宽度</li></ol><h2 id="4-5-4-word的表格公式，必须使用“粘贴函数”方法（“表格工具”→“公式”中）"><a href="#4-5-4-word的表格公式，必须使用“粘贴函数”方法（“表格工具”→“公式”中）" class="headerlink" title="4.5.4 word的表格公式，必须使用“粘贴函数”方法（“表格工具”→“公式”中）"></a>4.5.4 word的表格公式，必须使用“粘贴函数”方法（“表格工具”→“公式”中）</h2><p>公式的结果，不会随引用值得变化而变化</p><h2 id="4-6-页面排版（图文混排）"><a href="#4-6-页面排版（图文混排）" class="headerlink" title="4.6 页面排版（图文混排）"></a>4.6 页面排版（图文混排）</h2><ol><li>插入图片（例如，向文档指定位置插入C：\1.jpg）</li><li>第一步：将光标插入点定位到指定位置。</li><li>第二步：执行“插入”菜单→“图片”命令，选择C：\1.jpg文件；（可以预览）</li><li>第三步：单击“插入”或“链接插入”命令。<br>【区别】“插入”与源文件不再有联系。<br>“链接插入”当源文件发生变化时，随之变化。</li><li>图片在文档中有7种版式（图片与字符的位置关系）</li><li>设置方式：选中图片后，“格式”功能区→“自动换行”命令。</li><li>（P129图4-55）“衬于文字下方”、“浮于文字上方”</li></ol><h2 id="4-6-2-文本框-中文字有水平和垂直两个方向；其版式和图片相同。"><a href="#4-6-2-文本框-中文字有水平和垂直两个方向；其版式和图片相同。" class="headerlink" title="4.6.2 文本框 中文字有水平和垂直两个方向；其版式和图片相同。"></a>4.6.2 文本框 中文字有水平和垂直两个方向；其版式和图片相同。</h2><h2 id="4-6-3-艺术字-“插入”菜单→“艺术字”；创建好的艺术字，他的样式，效果，文字内容都可以修改；有7种版式。"><a href="#4-6-3-艺术字-“插入”菜单→“艺术字”；创建好的艺术字，他的样式，效果，文字内容都可以修改；有7种版式。" class="headerlink" title="4.6.3 艺术字 “插入”菜单→“艺术字”；创建好的艺术字，他的样式，效果，文字内容都可以修改；有7种版式。"></a>4.6.3 艺术字 “插入”菜单→“艺术字”；创建好的艺术字，他的样式，效果，文字内容都可以修改；有7种版式。</h2><h2 id="4-7-1-分节符-：在一篇文档中设置不同的页面格式，则通过插入分节符实现。"><a href="#4-7-1-分节符-：在一篇文档中设置不同的页面格式，则通过插入分节符实现。" class="headerlink" title="4.7.1 分节符 ：在一篇文档中设置不同的页面格式，则通过插入分节符实现。"></a>4.7.1 分节符 ：在一篇文档中设置不同的页面格式，则通过插入分节符实现。</h2><p>方法：“页面布局”功能区→“分隔符”→“分节符”</p><h2 id="4-7-2"><a href="#4-7-2" class="headerlink" title="4.7.2"></a>4.7.2</h2><ol><li>批注：选中文本的当前位置<br>方法“审阅”→“新建批注”</li><li>脚注和尾注<br>脚注在当前页的下方；尾注在文档尾。<br>方法：“引用”→“插入脚注或尾注”</li></ol><h2 id="4-7-4-超链接"><a href="#4-7-4-超链接" class="headerlink" title="4.7.4 超链接"></a>4.7.4 超链接</h2><ol><li>创建超链接工具图标</li><li>设置链接热点的对象：文字、图形、图像等声音和视频不能作为热点。</li><li>链接的目的点（P135图4-65）</li><li>当前文档的任意位置</li><li>任意文件</li><li>任意网页</li><li>任意邮箱地址</li><li>word中激活超链接的方法<br>Ctrl+单击链接热点。</li></ol><h1 id="第五章-Excel电子表格"><a href="#第五章-Excel电子表格" class="headerlink" title="第五章    Excel电子表格"></a>第五章    Excel电子表格</h1><p>导言 与计算有关</p><h2 id="5-1-2-Excel的基础知识"><a href="#5-1-2-Excel的基础知识" class="headerlink" title="5.1.2 Excel的基础知识"></a>5.1.2 Excel的基础知识</h2><ol><li>excel的文件是工作簿（.xlsx）</li><li>工作簿是由工作表组成；新创建的工作簿默认有3张工作表；工作簿至少要有1张工作表，最多255张工作表；工作表的默认的名称是sheet1、sheet2等；</li><li>工作表是由单元格组成，每张工作表中有1048576行和16348列个单元格；<br>单元格地址由列标+行标组成；列表采用大写字母（ABC等），行标采用数字（1、2等）；例如A1是第1个单元格，BC3是第BC列，第3行单元格。</li><li>名称框 显示活动单元格和地址<br>【活动单元格】是被选中、正在被操作的单元，任何情况下，活动单元格只能有一个；被选中的单元格不一定是活动单元格。</li><li>编辑栏中显示的活动单元格中输入的内容；<table><thead><tr><th align="center">×</th><th align="center">取消</th></tr></thead><tbody><tr><td align="center">√</td><td align="center">输入</td></tr><tr><td align="center">Fx</td><td align="center">插入函数</td></tr></tbody></table></li></ol><h2 id="5-2-1-Excel支持的文件类型"><a href="#5-2-1-Excel支持的文件类型" class="headerlink" title="5.2.1 Excel支持的文件类型"></a>5.2.1 Excel支持的文件类型</h2><table><thead><tr><th align="center">默认的</th><th align="center">.xlsx .xls</th></tr></thead><tbody><tr><td align="center">模板文件</td><td align="center">.xltx .xlt</td></tr><tr><td align="center">网页</td><td align="center">.htm  .mht  .html   .xml</td></tr><tr><td align="center">纯文本文件</td><td align="center">.txt</td></tr><tr><td align="center">便携文件类型</td><td align="center">.pdf</td></tr></tbody></table><h2 id="5-2-2"><a href="#5-2-2" class="headerlink" title="5.2.2"></a>5.2.2</h2><ol><li>向单元格中输入数据后，确定输入的方法enter、编辑栏√、tab、↑↓←→组成的光标键</li><li>单元格的选定<br>（鼠标指针形状：空心十字，表示选择功能）</li><li>单击：选中一个单元格；</li><li>拖拽：选中多个连续的单元格区域；</li><li>单击行标：选中行；单击列标，选中列；</li><li>行标和列标交叉：全选按钮（Ctrl+A）</li><li><strong>【重点】单元格中输入数据</strong></li><li>文字（字符，不能参与算术运算）    1. 对齐方式：左对齐    2. 输入字符的长度，超过了单元的宽度时；<br> 情况一，右侧单元格为空；“占用”右侧单元格空间；<br> 情况二，右侧单元格不为空，超出单元格宽度部分不显示。    3. 数字字符，例如，身份证号，手机号，邮政编码，输入方法<ol><li>’9999 结果：左对齐，9999，单元格左上角绿色小三角形</li><li>=’9999 公式法，结果：左对齐9999</li><li>将单元格格式设置为文本，结果：左对齐，左上角绿色三角形<br>方法：“开始菜单”→“格式”命令→“设置单元格格式”子命令</li></ol></li><li>数字输入（可运算）    1. 单元格中 右对齐    2. 单元格中数字的长度，超过了单元格的宽度时，单元格中显示为####<br> 解决方法：加宽单元格    3. 分数输入法  0空格2/3<br> 【说明】直接输入2/3，结果是2月3日。    4. 百分数<br> 直接输入10% 结果10%右对齐<br> 公式法=10%   结果0.1右对齐</li><li>日期（数字）    1. 右对齐    2. 日期输入的格式只有两种<br>   年-月-日或年/月/日    3. 输入系统当前时间ctrl+；</li><li>时间（数字）    1. 右对齐    2. 时间输入的格式：<br> 二十四小时制  时：分：秒<br> 十二小时制    时：分：秒 空格AM或PM    3. 输入系统当前时间 ctrl+shift+；</li><li>连续单元格区域输入相同数据<br>方法：在第一个单元格中输入数据后，选中此单元格，拖动填充柄复制</li><li>不连续区域输入相同数据<br>方法：Ctrl+拖动或单击，选中不连续区域后，输入数据，ctrl+enter（复制输入）</li><li>序列数据的填充（等比或等差）    1. 在A1单元中输入3，在A2单元格中输入8，选中A1，A2单元格后拖动填充柄至A5，则A4中的内容是。    2. 在第一个单元格中输入数据后，选中单元格区域，执行“开始”菜单→“编辑”→“填充”→“系列”，对话框中“等比或等差”步长值，设置等比或等差数列。</li><li>自定义序列（P144图5-7）<br>例如，在A1单元格中输入“星期一”，拖动A1填充柄，到A4，则A4中的值为“星期四”。</li></ol><h2 id="5-3-3"><a href="#5-3-3" class="headerlink" title="5.3.3"></a>5.3.3</h2><ol><li>清除</li><li>单元格中有内容、格式、批注<br>【说明】选中单元格后，执行“审阅”功能区。“新建批注”命令，单元格右上角红色三角形</li><li>“开始”菜单→“清除”命令→“清除”全部、清除内容、清除批注、清除格式</li><li>删除</li><li>是删除行、列、单元格</li><li>删除行是下方的行上移；删除列是右侧的列左移；删除单元格是下方单元格上移或右侧的单元格左移</li><li>“开始”菜单→“删除”→“删除”行、删除列、删除单元格、删除工作表</li></ol><h2 id="5-3-5-重命名工作表方法"><a href="#5-3-5-重命名工作表方法" class="headerlink" title="5.3.5 重命名工作表方法"></a>5.3.5 重命名工作表方法</h2><ol><li>双击工作表标签，重新输入名称</li><li>右击工作表标签，重新输入名称</li></ol><h2 id="5-4"><a href="#5-4" class="headerlink" title="5.4"></a>5.4</h2><h2 id="5-4-1-公式"><a href="#5-4-1-公式" class="headerlink" title="5.4.1 公式"></a>5.4.1 公式</h2><ol><li><p>公式必须以=开头</p></li><li><p>公式中的运算符有三类</p></li><li><p>算数运算符（正负号、%、^、*/、+-）按优先级顺序<br>例如：</p><table><thead><tr><th align="center">=3+10%^2</th><th align="center">结果</th><th align="center">3.01</th><th align="center">右对齐</th></tr></thead><tbody><tr><td align="center">=9*10%^2+10</td><td align="center">结果</td><td align="center">10.09</td><td align="center">右对齐</td></tr></tbody></table></li><li><p>比较运算符 ﹥、﹥=、﹤、﹤=、﹤﹥、=<br>比较运算符只有TRUE和FALSE两个结果<br>例如：</p><table><thead><tr><th align="center">=10=10</th><th align="center">结果</th><th align="center">TRUE</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="center">=10﹥=20</td><td align="center">结果</td><td align="center">FALSE</td><td align="center">居中对齐</td></tr><tr><td align="center">=10﹥=10</td><td align="center">结果</td><td align="center">TRUE</td><td align="center">居中对齐</td></tr></tbody></table></li></ol><pre><code>【分析】第一个=表示公式；第二个=表示比较运算符</code></pre><ol start="3"><li>文本运算行（字符连接运算符）＆<br>例如：<table><thead><tr><th align="center">=20+40</th><th align="center">结果</th><th align="center">60</th><th align="center">右对齐</th></tr></thead><tbody><tr><td align="center">=20&amp;40</td><td align="center">结果</td><td align="center">2040</td><td align="center">左对齐。</td></tr></tbody></table></li><li></li><li>单元格引用符</li><li>单元格区域引用符<br>例如，A1：B2表示 2列×2行=4个<table><thead><tr><th align="center"></th><th align="center">A</th><th align="center">B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">A1</td><td align="center">B1</td></tr><tr><td align="center">2</td><td align="center">A2</td><td align="center">B2</td></tr></tbody></table></li></ol><pre><code>与之等价 A2：B1  B2：A1  B1：A2</code></pre><ol start="2"><li>联合引用<br>例如，A1：B2，C3：D4，15<br>引用了A1，A2，B1，B2，C3，C4，D3，D4，15共9个元素</li><li>交叉引用 空格，取两个区域重合部分。<br>例如，A1：C3  B2：D4<pre><code>   空格            引用B2:C3共4个单元格区域</code></pre></li><li>公式中单元格的引用</li><li>相对引用即A1 例如，=sum（A1：B2）</li><li>绝对引用 $A$1 例如，=sum（$A$1：$B$2）</li><li>混合引用 $A1或A$1  例如，=sum（$A1:B$2）</li></ol><h2 id="5-4-2-公式的复制（不是移动）"><a href="#5-4-2-公式的复制（不是移动）" class="headerlink" title="5.4.2 公式的复制（不是移动）"></a>5.4.2 公式的复制（不是移动）</h2><ol><li><p>公式中单元格相对引用<br>例如，F2=sum（C2：E2），将公式复制到F3=sum（C3：E3）<br>运算规则：=、函数、运算符保持不变；相对引用单元格的偏移量（值）保持不变。<br>列偏移值：F-C=3 F-E=1 行偏移量2-2=0 2-2=0<br>例如，D2=sum（A1：B3），将公式复制到F4=sum（C3：D5）</p><table><thead><tr><th align="center">D-A=3</th><th align="center">D-B=2</th></tr></thead><tbody><tr><td align="center">2-1=1</td><td align="center">2-3=-1</td></tr><tr><td align="center">F-?=3</td><td align="center">F-?=2</td></tr><tr><td align="center">4-?=1</td><td align="center">4-?=-1</td></tr></tbody></table></li><li><p>公式复制时单元格绝对引用<br>运算规则：绝对引用单元格的地址保持不变<br>例如，F3=sum（$A$1：$D$4）将公式复制到H9=sum（$A$1：$D$4）</p></li><li><p>公式复制时单元格的混合引用<br>运算规则：绝对引用部分照抄，相对引用部分照算。<br>例如，F3=sum（$A1：C$3）复制到F4=sum（$A2：C$3）</p></li></ol><h2 id="5-4-3"><a href="#5-4-3" class="headerlink" title="5.4.3"></a>5.4.3</h2><ol><li><p>sum（）统计引用单元区域中数字单元的和值。</p></li><li><p>Average（）统计引用单元格区域中数字单元的平均值。<br>例如：A1=1，A2=2，A3=3</p><table><thead><tr><th align="center">=sum（A1：A3，4）</th><th align="center">结果是10</th><th align="center">右对齐</th></tr></thead><tbody><tr><td align="center">=average（A1：A3，4）</td><td align="center">结果是2.5</td><td align="center">右对齐</td></tr><tr><td align="center">=average（A1+A2+A3，4）</td><td align="center">结果是5</td><td align="center">右对齐</td></tr></tbody></table></li><li><p>count（）统计数字单元格（包括日期和时间）的个数<br>例如，A1=1，A2=2，A3=3</p><table><thead><tr><th align="center">=count（A1：A3）</th><th align="center">结果3</th><th align="center">右对齐</th></tr></thead></table></li></ol><p>  例如，A1=1，A2=2，A3=abc<br>     |=count（A1：A3）|结果2|右对齐<br>     | :-: | :-: | :-: |</p><ol start="4"><li><p>最大值最小值<br>例如：</p><table><thead><tr><th align="center"><code>max（）</code></th><th align="center">求单元格区域中数字的最大值</th><th align="center">null</th></tr></thead><tbody><tr><td align="center"><code>min（）</code></td><td align="center">求单元格区域中数字的最小值</td><td align="center">null</td></tr><tr><td align="center">=max（A1：A3）</td><td align="center">结果3</td><td align="center">右对齐</td></tr></tbody></table></li><li><p>product（）求数字单元格的乘积<br>例如，A1=1，A2=2，A3=3</p><table><thead><tr><th align="center">=product（A1：A3，5）</th><th align="center">结果30</th><th align="center">右对齐</th></tr></thead></table></li></ol><h2 id="5-5-格式化单元格"><a href="#5-5-格式化单元格" class="headerlink" title="5.5 格式化单元格"></a>5.5 格式化单元格</h2><h2 id="5-5-1"><a href="#5-5-1" class="headerlink" title="5.5.1"></a>5.5.1</h2><ol><li>拖动列标之间或行标之间</li><li>隐藏行或列的方法：先选中，执行“开始”菜单→“格式”→“隐藏行、列、工作表”<br>（提醒）被隐藏的单元可以被引用</li></ol><h2 id="5-5-3-【重点】单元格的格式化"><a href="#5-5-3-【重点】单元格的格式化" class="headerlink" title="5.5.3 【重点】单元格的格式化"></a>5.5.3 【重点】单元格的格式化</h2><ol><li>方法：先选中单元格区域后，执行“开始”菜单→“格式”→“设置单元格格式”字命令；（P154图5-21）</li><li>“数字”选项卡，“分类”列表框<br> “数值”设置小数点的位数，有四舍五入。<br> “文本”设置单元格的文本格式，例如，身份证号……..<br> “日期”或“时间”等格式</li><li>“对齐”选项卡</li><li>设置单元格中内容的水平对齐（左中右），垂直对齐（上中下）效果；</li><li>单元格中内容的自动换行，内容随单元格高度和宽度自动换行（假换行）<br>单元格中Alt+enter，是真换行；</li><li>设置内容放置的任意方向，例如，垂直放置内容</li><li>“字体”选项卡，设置单元格中字体格式</li><li>“边框”选项卡</li><li>工作表的网格线默认是不会打印输出<br>打印输出网格线的方法：<br> “页面布局”功能区→“页面设置”命令，“页面设置”对话框的“工作表”选项卡“√网格线”</li><li>先选择单元格区域，在“边框”选项卡中，先选择“线条样式”、“线条颜色”，单击“外边框”或“内部”命令按钮。</li><li>“填充”选项卡</li><li>是背景色，</li><li>只有两种效果，颜色（单色或双色）图案。</li><li>“保护”</li></ol><h2 id="5-6-图表"><a href="#5-6-图表" class="headerlink" title="5.6 图表"></a>5.6 图表</h2><ol><li>图标是图形化的公式，是变量；</li><li>创建图表引用的工作表中的源数据发生变化时，图表会随之变化；</li><li>数据清单中第一行和第一列中的文字，是对数据区域含义的说明；</li><li>创建好的图表，所有的组成元素，都可以修改；</li><li>清除图表中的数据系列，不会影响数据清单中的源数据，</li></ol><h2 id="5-7-打印工作表"><a href="#5-7-打印工作表" class="headerlink" title="5.7 打印工作表"></a>5.7 打印工作表</h2><ol><li>工作表中可设置页眉和页脚（“插入”菜单→“页眉和页脚”命令或“页面布局”菜单→“页眉和页脚”选项卡）只有在打印输出时，显示效果。</li><li>打印范围（选择题）</li><li>当前n工作表 默认的</li><li>整个工作簿</li><li>锁定的区域</li></ol><h1 id="5-8-保护（工作簿）文件"><a href="#5-8-保护（工作簿）文件" class="headerlink" title="5.8 保护（工作簿）文件"></a>5.8 保护（工作簿）文件</h1><ol><li>保护（工作簿）文件，（P169图5-46）</li><li>对不同用户，设置不同的权限；</li><li>对文件设置打开权限密码，修改权限密码；</li><li>保护工作簿（P170图5-47）<br>□结构 不允许增加、移动、复制、删除工作表的操作，实质保护工作表<br>□窗口工作簿在工作区域中，放置的位置和大小不允许改变。</li><li>保护工作表（P170图5-48）<br>实质保护工作表中的单元格不被选择，移动，复制，删除等操作，</li></ol><h2 id="5-9-1-数据清单"><a href="#5-9-1-数据清单" class="headerlink" title="5.9.1 数据清单"></a>5.9.1 数据清单</h2><ol><li>数据清单 工作表中的所有数据，同时显示所有的数据；数据清单第一行，称标题行，是字段名；<br>例如，P17375-51、“Ⅰ号”、“姓名”……<br>标题下是记录</li><li>记录表 只显示一条记录；通过记录单按条件查询记录，添加，删除，修改，浏览记录（P173图5-52）</li></ol><h2 id="5-9-3-【重点】排序"><a href="#5-9-3-【重点】排序" class="headerlink" title="5.9.3 【重点】排序"></a>5.9.3 【重点】排序</h2><ol><li>方法“开始”菜单→“排序和筛选”命令→“升序和降序”子命令</li><li>选中排序关键字字段下的任意一个单元格，则以记录为单位（按行），所有的数据参与排序；</li><li>选中排序关键字字段下的单元格区域（多个单元格），则弹出对话框<br>●扩展选定区域（以记录为单位，所有数据参与排序）<br>○以当前选定区域排序（只对选定区域中的数据排序，没有选中原地不动）</li></ol><h2 id="5-9-4-数据筛选"><a href="#5-9-4-数据筛选" class="headerlink" title="5.9.4 数据筛选"></a>5.9.4 数据筛选</h2><ol><li>将不符合条件的记录，隐藏起来。（不是删除）</li><li>筛选分为自动筛选和高级筛选两种</li><li>“自动筛选”方法，选中数据清单中的任意一单元格；执行“开始”菜单→“排序和筛选”命令的“筛选”命令</li></ol><p>  <strong>【重点】自动筛选或筛选只能对一个字段设置筛选条件（条件可以有两个）</strong><br>4. 如果要同时对多个字段设置筛选条件，则使用“高级筛选”功能；<br>  条件区域 字段名必须与数据清单中一致，<br>         条件在同一行，表示逻辑与<br>         条件在不同行，表示逻辑非<br>  筛选结果放置的位置：<br>    ●在原位置显示筛选结果<br>    ○将筛选的结果显示到其他位置【其他位置只能是当前工作表中的其他位置】</p><h2 id="5-9-5-数据分类汇总"><a href="#5-9-5-数据分类汇总" class="headerlink" title="5.9.5 数据分类汇总"></a>5.9.5 数据分类汇总</h2><ol><li>分类汇总 必须先按关键字分类，后对分类关键字排序（不区分升序或降序），再汇总。</li><li>（P177）分别统计男同学和女同学数字成绩的平均值。</li></ol><p>  <strong>答：</strong></p><ol><li>选中“性别”列中的任一单元格，执行“开始”菜单→“排序和筛选”命令→“升序”梓命令</li><li>执行“数据”菜单→“分类汇总”命令</li><li>在“分类汇总”对话框中，“分类字段”下拉列标中选择“性别”，在“汇总方式”下拉列表中选择“平均值”（还有求和、最大值、最小值、技术……）；在“选定汇总项”中√数字（可以选择多个）；</li><li>单击“确定”命令按钮。<br>【说明】“全部删除”命令按钮；删除汇总，但不能删除排序。</li></ol><h1 id="第八章计算机网络基础知识"><a href="#第八章计算机网络基础知识" class="headerlink" title="第八章计算机网络基础知识"></a>第八章计算机网络基础知识</h1><p>导言 计算机网络是计算机技术和现代通信技术相结合的产物。</p><h2 id="8-1-计算机网络的概念P240"><a href="#8-1-计算机网络的概念P240" class="headerlink" title="8.1 计算机网络的概念P240"></a>8.1 计算机网络的概念P240</h2><h2 id="8-1-1-计算机发展历史"><a href="#8-1-1-计算机发展历史" class="headerlink" title="8.1.1 计算机发展历史"></a>8.1.1 计算机发展历史</h2><ol><li>1969年，美国军方ARPAnet，世界上第一个使用分组交换技术的网络；是现代Internet的起源。</li><li>1980/1982年，建立了局域网标准（IEEE802.3标准/Ethernet标准）</li><li>1985年，ARPAnet→NSFnet→Internet，广泛使用的通信协议是TCP/IP协议。</li><li>计算机网络从逻辑上，划分为通信子网和资源子网。（P241图8-1）</li><li>通信子网 指通信设备和通信线路</li><li>资源子网 指网络中主机，包括客户机和服务器</li></ol><h2 id="8-1-2-计算机网络的概念"><a href="#8-1-2-计算机网络的概念" class="headerlink" title="8.1.2 计算机网络的概念"></a>8.1.2 计算机网络的概念</h2><p>将分布在不同地理位置，功能独立的计算机，使用通信设备和通信线路连接，利用网络软件控制和管理，实现资源共享， 信息通信和协同式（分布式）工作<br>【说明】</p><ol><li>网络中的计算机，统称主机（host），包括客户端的PC机，服务端的服务器等；所有的主机在网络中地位一律平等。</li><li>通信设备</li><li>物理层的集线器（HUB）或中继器（reaptor），功能是扩大网络覆盖的地理范围；</li><li>数据链路层的交换机（switcher）或网络桥（Bridge），功能是过滤，存储转发数据，实现同类网络的互联；数据单位是帧（Frames）</li><li>网络层的路由器（router）或网关（gateway），功能是实现路由选择（路径选择）、存储转发，差错控制等，实现异构（不同网络）之间的互联；数据单位是分组或数据包。</li><li>通信线路（=传输媒体=传输介质）分为有向导体（有线）和无向导体（无线）两类；</li><li>有线包括双绞线、光纤（多来光纤的集合，称为光缆）、同轴电缆等；</li><li>无线指在空气或大气中传播的无线点信号，微博，红外信号等；</li><li>计算机网络的功能【重点 简答、填空、选择】<br>答：①资源共享②信息通信③分布式工作④提高计算机的可靠性和可用性<br>【说明】</li><li>资源共享是计算机网络最主要的功能；资源包括硬件资源、软件资源和数据资源；    1. 硬件资源 指共享打印机，网络磁盘空间（网盘）等    2. 软件资源 指安装包文件，例QQ、微信、office办公自动化软件等。    3. 数据资源 指各种文档，声音（MP3），影片等。</li><li>分布式（协同式）工作；将一个大的任务，划分成若干个小人物，分配给不同的计算机分别完成；</li><li>网络中主机的可靠性：指网络中主机互为后备机，当一台主机停止工作，其他主机继续工作完成相应任务。<br>网络中主机的可用性：网络中任务采用负载均衡的方式，将任务平等分配给主机完成。</li></ol><h2 id="8-2-3-计算机网络的分类"><a href="#8-2-3-计算机网络的分类" class="headerlink" title="8.2.3 计算机网络的分类"></a>8.2.3 计算机网络的分类</h2><ol><li><strong>【重点】按网络覆盖的地理范围</strong>，分为局域网、广域网、城域网</li><li>局域网（LAN）覆盖范围有限，单位或个人拥有的网络；<br>例如，校园网、企业网、园区网、大楼网、办公室网、宿舍网、家庭网等</li><li>广域网（WAN）实现局域网之间的互联，局域网是广域网存在的基础。<br>Internet是世界上最大的广域网.    <strong>中国四大骨干网络（广域网）：</strong><table><thead><tr><th align="center">CHINANET</th><th align="center">中国公用计算机网络</th></tr></thead><tbody><tr><td align="center">CSTNET</td><td align="center">中国科技网</td></tr><tr><td align="center">CERNET</td><td align="center">中国教育科研网</td></tr><tr><td align="center">CHINAGBN</td><td align="center">中国金桥网</td></tr></tbody></table></li></ol><p>  【补充】ISP（Internet服务提供商）是四大骨干网络的运营商，例如，中国电信、中国移动等。<br>2. 按网络的拓扑结构，分为星形拓扑结构网、树形拓扑结构网、总线型拓扑结构网、环形拓扑结构网、网状拓扑结构网。</p><ol><li>网络拓扑结构 是将网络设备抽象为“点”，通信线路抽象为“线”，由点和线组成的几何图形，称网络拓扑结构。</li><li>星型拓扑结构特点:    1. 星型结构是小型局域网使用最广泛的拓扑结构    2. 特点：一个中心节点，向外连接多台设备；<br>优点：成本低，扩展方便，易于管理；<br>缺点：中心节点故障，网络瘫痪。</li><li>树形拓扑结构    1. 大型局域网中使用，是多种拓扑结构的集合；    2. 优点：分层（级）管理；易于维护和扩展</li><li>总线形拓扑结构 一条中心线连接所有主机。<br>成本低、中线路故障，网络瘫痪</li><li>网状拓扑结构，一般用于广域网，实现线路冗余。保障网络连通。成本高。</li><li>按网络功能的逻辑结构、划分为通信子网和资源子网。</li></ol><h2 id="8-5-网络协议体系结构"><a href="#8-5-网络协议体系结构" class="headerlink" title="8.5 网络协议体系结构"></a>8.5 网络协议体系结构</h2><ol><li>计算机网络实现技术最复杂，因此采用分层结构，将复杂的大问题，划分成若干个小问题，逐层解决；</li><li>ISO制定的OSI/RM（开放系统互联/参考模型），采用七层结构；从下而上依次为物理层、数据链路层、网络层、传（运）输层、会话层、表示层、应用层；</li></ol><p>  <strong>【说明】国际标准，但没有被使用。</strong><br>3. <strong>【重点】计算机网络中使用最广泛的TCP/IP体系结构，采用四层结构，从下而上依次是接口层、网络层、传输层、应用层。</strong><br>  接口层又划分为:物理层和数据链路层。<br>4. 常用的网络协议</p><ol><li>数据链路层  PPP或PPPoE<br>PPP        点对点协议<br>PPPoE      基于Ethernet的PPP协议<br>作用：向服务器申请IP地址等信息。</li><li>网络层    1. IP协议（Internet protocol）是所有通信过程，必须使用的通信协议<br> 作用：保证数据到达正确的目的地    2. ARP（地址解析协议），<br> 作用：实现虚拟的IP地址转换为网卡的物理地址。    3. ICMP（Internet control message protocol）<br> 作用：通信状态和差错，报告报文。如，ping连通性测试命令，调用ICMP协议。</li><li>传输层 只有两个协议    1. TCP（传输控制协议），面向连接的，可靠性通信协议，保证到达目的地址的数据是正确的。    2. UDP（用户数据报协议），非连接，不可靠通信协议</li><li>应用层协议    1. HTTP（超文本传输协议）访问网站（web）    2. FTP（文件传输协议）用于文件上传或下载    3. SMTP（简单邮件传输协议）发送邮件    4. POP3（邮局协议第三版）接收邮件</li></ol><h2 id="8-6"><a href="#8-6" class="headerlink" title="8.6"></a>8.6</h2><h2 id="8-6-3-网卡和调制解调器"><a href="#8-6-3-网卡和调制解调器" class="headerlink" title="8.6.3  网卡和调制解调器"></a>8.6.3  网卡和调制解调器</h2><ol><li>两个设备都是主机接入网设备，一头接计算机，另一头接网线</li><li>网卡的局域网设备，作用是实现主机接入局域网；</li><li>调制解调器（MODEM）是广域网设备，作用是实现PC机接入广域网（internet）；采用拨号上网方式接入<br>硬件=PC+电话线+MODEM<br>软件=拨号软件+账号（用户名+密码）+浏览器<br>MODEM实现数字信号和模拟信号之间互转<br>调制：数 转 模<br>解调制：模 转 数</li></ol><h2 id="8-6-4-传输介质"><a href="#8-6-4-传输介质" class="headerlink" title="8.6.4 传输介质"></a>8.6.4 传输介质</h2><ol><li>双绞线</li><li>铜导体</li><li>传输的信号；电磁信号</li><li>线路绞合的目的：抗电磁干扰和防止近端串扰。</li><li>分类：<br>STP 屏蔽双绞线（抗电磁干扰能力强）<br>UTP 非屏蔽双绞线（抗干扰能力较差）<br>常用的双绞线是超五类线（5E）</li><li>光纤</li><li>玻璃纤维材料</li><li>传输光信号</li><li>优点：传输距离远，保密性强，不受外部干扰</li><li>分类：    1. 单模光纤：一条光纤只允许一路信号通过    2. 多模光纤：一条光纤同时允许多路信号通过。<br>集线器、交换机属于 局域网设备<br>路由器或网关属于 广域网设备</li></ol><h1 id="第九章-Internet基础"><a href="#第九章-Internet基础" class="headerlink" title="第九章  Internet基础"></a>第九章  Internet基础</h1><h2 id="9-1-2"><a href="#9-1-2" class="headerlink" title="9.1.2"></a>9.1.2</h2><ol><li>1987年，中国接入Internet；</li><li>1995年，Internet开始使用；</li><li>NCFC=CSTNET</li></ol><h2 id="9-2-1-TCP-IP"><a href="#9-2-1-TCP-IP" class="headerlink" title="9.2.1 TCP/IP"></a>9.2.1 TCP/IP</h2><ol><li>TCP/IP体系结构是目前Internet中广泛使用的通信标准，分为4层，是由多个协议构成；</li><li>其中，传输层的TCP是保证到达目的地的数据是正确的<br>网络IP是保证数据到达正确的目的地。</li></ol><h2 id="9-2-2-IP地址"><a href="#9-2-2-IP地址" class="headerlink" title="9.2.2 IP地址"></a>9.2.2 IP地址</h2><ol><li><p>主机接入Internet，必须至少有一个唯一的二进制地址标识，即IP地址；</p></li><li><p>IP地址分为IPv4和IPv6两个版本，IPv4采用了32bit（位）二进制表示是主流；<br>IPv6采用128bit二进制地址表示。</p></li><li><p>IPv4地址采用点分十进制形式表示；<br>例如，某IP地址</p><table><thead><tr><th align="center">1100 0000.</th><th align="center">1010 1000.</th><th align="center">0000 0000.</th><th align="center">0000 0001</th></tr></thead><tbody><tr><td align="center">192  .</td><td align="center">168  .</td><td align="center">0     .</td><td align="center">1</td></tr></tbody></table></li><li><p>IP地址采用分层（级）结构<br>IP=网络地址（网络号、NID）+主机地址（主机号、HID）；<br>IP地址分为A、B、C、D、E五类；<br>其中A、B、C三类可分配给主机使用，D类是广播地址，E类是保留地址<br>所以说，IP地址一般分为A、B、C三类</p></li><li><p>A类地址第一个字节是网络号，后三个字节是主机号；</p></li><li><p>A类地址第一个字节最高位（左），固定为（0）2，则第一个字节的取值范围是0-127<br>0 000 0000-0 111 1111<br>A类网络地址取值范围1-126<br>网络地址表示的方式是主机号部分全0，因此A类地址网络号的范围    1.0.0.0-126.0.0.0    <strong>【说明】</strong>    0.0.0.0 表示当前网络，不能分配    127.0.0.0 回环测试地址，用于测试主机内部网络连通性，不能分配（ping 127.0.0.1）<br>例如，某企业申请了A类地址 100.0.0.0</p></li><li><p>某A类地址主机号取值范围    0.0.1-255.255.254<br>例如，100.236.65.78、100.0.0.3、100.200.200.200都属于可分配的主机地址。</p></li><li><p>B类地址前二个字节是网络号，后两个字节是主机号；</p></li><li><p>B类地址第一字节最高位固定（10）2，则B类地址的网络号范围是<br>二进制：10 00 0000.0000 0000-10 11 1111.1111 1111<br>十进制：    128  .    0    -    191  .   255<br>例如，某企业申请B类地址？.？171.100.0.0</p></li><li><p>某B类地址主机号取值范围0.1-255.254<br>例如，171.100.0.1、171.100.254.36、是可分配使用的地址    171.100.0.0 表示网络号，不能分配    171.100.255.255 表示广播地址，不能分配</p></li><li><p>C类地址前三个字节是NID，后一个字节是HID</p></li><li><p>则C类地址第一个字节是前三位固定（110）2，则C类地址NID的取值范围是？<br>110 0 0000.0000 0000.0000 0000-110 1 1111.1111 1111.1111 1111<br>.0    .     0   -    223  .    255  .   255<br>例如，某企业申请C类地址 219.229.216.0</p></li><li><p>C类地址第四个字节是HID，取值范围是1-254<br>例如，申请的C类地址可分配主机号范围是    219.229.216.1-219.229.216.254    219.229.216.10、219.229.216.100 主机地址<br>【推论】<br>A类地址有27-2=126个NID，224-2=16M个主机号<br>适用于超大型网络；<br>B类地址有214=16K个NID，216-2=64K个主机号<br>适用于大、中型网络；<br>C类地址有221=2M个NID，28-2=254个主机号<br>适用于中、小型网络。</p></li><li><p>IP地址分为公用IP和私用IP；<br>公用IP要先租后用；私用IP无需租，直接可用。但是，使用私用IP地址的主机不能直接接入Internet，私用IP地址有：<br>A类 10.0.0.0网络（1个网络号）<br>B类 172.16.0.0-172.31.0.0（16个网络号）<br>C类 192.168.0.0-192.168.255.0（256个网络号）<br>例如，10.10.20.30、172.28.6.36、192.168.1.1都属于私用IP地址</p></li><li><p>子网掩码（sunmask）作用：用于表示IP地址中NID部分和HID部分子网掩码长度与IP地址相同，IP地址的NID部分对应submask的部分，用（1）2表示；<br>IP地址的HID部分，对应submask，用（0）2表示<br>A类地址默认的子网掩码 255.0.0.0<br>B类地址默认的子网掩码 255.255.0.0<br>C类地址默认的子网掩码 255.255.255.0</p></li></ol><h2 id="第6章-PPT（不区分版本）"><a href="#第6章-PPT（不区分版本）" class="headerlink" title="第6章     PPT（不区分版本）"></a>第6章     PPT（不区分版本）</h2><ol><li>PPT软件创建的文件是演示文稿（类型名：.ppt或.pptx不是幻灯片）;演示文稿是由幻灯片组成;幻灯片是由对象和版式（布局）组成;<br>【说明】对象包括文字、图表、图形、图像、视频、声音、剪贴画、组织结构图等;<br>版式（布局）是对象在幻灯片中放置的位置；<br>【提醒】word软件是字处理软件，用于文字排版输出；excel 是电子表格软件，用于计算；<br>演示文稿（PPT）用于展示，如学术交流、产品展示、成果汇报、课堂教学等。</li><li>创建演示文稿的方法<br>（“文件”菜单→“新建”命令）</li><li>“空白演示文稿”（默认的）</li><li>“根据设计模板”（设计模板=模版文件）<br>【复习】使用模版文件（.pot或.potx）创建新文档的目的是简化重复排版操作、统一文档风格；</li><li>“根据现有演示文稿”或“根据现有内容”创建与原演示文稿、格式完全一致的新文件（复制，与原文件没有关系了）</li><li>“根据内容提示向导”（根据提示选择模版文件）</li><li>新创建的演示文稿，默认的第一张幻灯片是“标题幻灯片”或“标题版式”</li><li>幻灯片版式（对象在幻灯片中放置的位置）有四类：文字版式、内容版式、文字和内容版式、其他版式</li><li>向演示文稿中添加新幻灯片的方法<br>2003“插入”菜单→“新幻灯片”命令<br>2010“开始”……“新建幻灯片”命令或ctrl➕M（不是ctrl➕N，这个是新建文件）</li><li>修改幻灯片版式的方法<br>2003“格式”菜单→“幻灯片版式”命令<br>2010“开始”……“版式”命令    <strong>【重点】只能为选中幻灯片设置新版式</strong></li><li>向幻灯片中添加对象</li><li>只有文字对象，必须先有占位符，后，才能输入；<br>【说明】“插入”菜单→“文本框”命令，即添加占位符</li><li>向幻灯片中插入图片（参看word）“插入”菜单→“图片”命令（两种插入方式的区别：插入和链接到文件）</li><li>向幻灯片中插入视频（影片）和声音的方法    1. 方法<br> 2003“插入”菜单→“影片和声音”命令→“文件中的影片”或“文件中的声音”子命令<br> 2010“插入”菜单→“视频”或“音频”命令→“文件中的视频”或“文件中的音频”子命令    2. 视频或音频播放的方式<br> 只有在“幻灯片放映”视图模式下，<br> “自动”：当播放到该幻灯片时，自动开始<br> “单击时”：…………单击视频或音频图标</li><li>幻灯片显示视图</li><li>“普通视图”只能显示一张幻灯片，作用是对幻灯片中的对象和版式进行编辑</li><li>“幻灯片视图”以缩略图形式显示幻灯片，可以选择当前幻灯片</li><li>“大纲视图”只显示幻灯片中的章节编号；大纲视图中修改的文字格式，在大纲中不显示；只在普通视图中显示</li><li><strong>【重点】“幻灯片浏览视图”同时显示多张幻灯片；用于查看幻灯片的统一效果；</strong>    1. 不能对幻灯片中的对象进行编辑操作；    2. 一般用于对幻灯片进行操作，例如，添加新幻灯片，移动、复制、删除幻灯片等</li><li>“幻灯片放映视图”以全屏形式，显示幻灯片中所有效果（例如，动画、超链接、音频和视频等）</li><li>“备注页视图”是幻灯片编辑者用于提示自己的文字信息</li><li>创建好的演示文稿，重新选择模版文件（改变演示文档风格）方法</li><li>2003“格式”菜单→“幻灯片设计”命令<br>2010“设计”菜单→“主题”命令</li><li>“配色方案”是设置幻灯片的背景色</li></ol><p><strong>【重点提醒】</strong><br><strong>1. “幻灯片版式”只能对选中的幻灯片设置新版式；</strong><br><strong>2. “幻灯片设计”或“幻灯片主题”是对所有幻灯片设置新模版效果</strong><br><strong>3. “配色方案”即可对所，也可对所有幻灯片设置背景效果</strong></p><p>word中插入超链接<br>7. 插入超链接<br>    1. 先选中热点（不能是音频或视频，一般是文字或图片）<br>    2. 执行“插入”菜单→“超链接”命令或图标<br>    3. 可链接到本演示文稿中的任意幻灯片【不能是幻灯片中的对象】、任意网页、任意邮箱、本机上任意文件<br>    4. 激活超链接方法：在“幻灯片放映”视图方式下单击链接点<br>  2. “动作设置”超链接<br>    1. 激活方式：在“幻灯片放映”视图中，鼠标单击或鼠标移过<br>    2. 可链接的目的点：参看上面超链接<br>8. 向当前演示文稿中插入其他演示文稿文件中的幻灯片</p><ol><li>“插入”菜单→“幻灯片（从文件）”<br>命令</li><li>默认的，新插入的幻灯片使用本演示文稿的模版风格；如果✅保留源格式，则使原演示文稿中的模版格式</li><li>【重点】母版与模版</li><li>模版文件用于统一风格；类型名.pot.potx</li><li>母版：创建好的演示文稿文件有母版；修改母版、影响所有使用此母版的幻灯片；例如，向所有幻灯片中添加logo图，日期时间、页码、幻灯片编号等，都是在母版中实现</li><li>母版分为幻灯片母版（分为幻灯片母版和标题母版）、讲义母版、备注母版</li></ol><p><strong>【说明】</strong><br><strong>1. 讲义母版 用于打印输出幻灯片时使用；A4纸张上允许打印输出的幻灯片张数有1、2、3、4、6、9</strong><br><strong>2. 备注母版 用于打印输出</strong><br>10. 动画分为幻灯片切换动画和幻灯片中对象的动画两种</p><ol><li><p>设置对象的动画    1. 先选中对象    2. 执行<br> 2003“幻灯片放映”菜单→“自定义动画”命令<br> 2010“动画”菜单下    3. 激活动画方式：在“幻灯片放映”视图“单击鼠标”或在上一个动画动作的之前或之后自动发生；    4. 【重点】对一张幻灯片中多个对象设置了动画，动画发生的顺序，可任意变化。</p></li><li><p>幻灯片之间 切换动画    1. 2003“幻灯片放映”菜单→“幻灯片切换”命令<br> 2010“切换”菜单    2. 【重点】默认的，幻灯片切换动画只对选中的幻灯片发挥效果    3. 切换 激活的方式<br> 单击鼠标或设置固定的时间间隔（排练计时）</p></li><li><p>保存（4种情况、参看word）<br>PPT软件支持的文件类型:</p><table><thead><tr><th align="center">默认的文件类型</th><th align="center">.ppt .pptx</th></tr></thead><tbody><tr><td align="center">模版文件</td><td align="center">.pot .potx</td></tr><tr><td align="center"></td><td align="center">.pdf</td></tr><tr><td align="center">打包的播放文件类型</td><td align="center">.pps .ppsx</td></tr><tr><td align="center">将每张幻灯片以独立文件形式存为图片</td><td align="center">.jpg .png</td></tr><tr><td align="center">将演示文稿存为视频文件类型</td><td align="center">.wmv</td></tr><tr><td align="center">文本文件类型</td><td align="center">.rtf</td></tr></tbody></table></li><li><p>幻灯片放映（p205图6−34）<br>“幻灯片放映”菜单→“设置放映方式”命令</p></li><li><p>“放映类型”包括演讲者放映、观众自行浏览、在展台浏览；</p></li><li><p>“放映选项”<br>循环放映<br>放映时不加动画</p></li><li><p>“放映幻灯片”<br>全部“默认的”<br>选择连续的幻灯片区域<br>自定义放映：可选择当前演示文稿中任意幻灯片、按任意顺序播放</p></li><li><p>进入“幻灯片放映”视图<br>F5：从第一张幻灯片开始播放<br>shift➕F5：从当前幻灯片开始播放<br>右击屏幕，选择“指针类型”，可绘制或书写可以“保留”或“放弃”</p></li><li><p>结束放映的方式</p></li><li><p>ESC</p></li><li><p>右击，快捷菜单中选择“结束放映”</p></li><li><p>单击左下角“小方块”按钮</p></li></ol><h2 id="IT（信息技术）DT（数据技术）"><a href="#IT（信息技术）DT（数据技术）" class="headerlink" title="IT（信息技术）DT（数据技术）"></a>IT（信息技术）DT（数据技术）</h2><ol><li>数据与信息的关系 </li><li>先有数据，对数据进行加工整理，获取信息。</li><li>信息是经过加工的数据。不同的数据加工方式，可获取不同的信息。</li><li>信息的特点有：普遍和无限性 可传递性 共享性和依附性 时效性 可处理性 等。</li><li><strong>六次信息革命：</strong></li><li>形成语言 </li><li>形成文字 </li><li>造纸、印刷  </li><li>电报、电话、广播、电视普及应用、传播信息。</li><li>计算机和现代通信技术应用  </li><li>计算机网络、多媒体传播信息</li><li>信息处理 或 数据加工 或 信息加工<br>实质上就是计算机进行数据处理的过程，即通过数据的采集（使用物联网技术）和输入，有效的把数据组织到计算机中（形成大数据）由计算机系统对数据进行一系列的存储，加工和输出（云计算的过程）的操作。</li><li>信息技术<br>利用计算机进行信息处理，利用现代电子通信技术从事信息采集，存储，加工，利用，以及相关产品制造，技术开发，信息服务的新学科。</li><li>信息安全技术与网络安全技术</li><li>为什么需要信息安全或者信息为什么不安全？<br>因为网络有丰富的资源，所以存在信息安全。</li><li>信息安全（或网络安全）的概念<br>信息安全是指防止任何对数据进行未授权访问的措施。防止造成信息有意无意的泄露、破坏、丢失的问题发生，让数据处于远离危险，避免威胁的状态或特征。</li><li>信息安全的三要素：保密性、可完整性、可用性（可靠性、可控性、不可否认性）</li><li>计算机病毒的概念<br>计算机病毒是指编制或者在计算机程序中插入的破坏计算机功能或数据，影响计算机使用并且能够自我复制的一组计算机指令或程序代码。<br>【说明】    1. 计算机病毒是指令或程序代码 是计算机软件    2. 计算机病毒有两种存在形式：单独的程序代码，嵌入在其他程序中的代码</li><li>计算机病毒的特征：传染性、破坏性、隐蔽性、潜伏性、触发性、不可预见性、变异性等</li><li>造成信息不安全的主要威胁：计算机病毒、黑客入侵、非法访问、脆弱口令</li><li>病毒传播的主要途径：计算机网络（Internet 、局域网）移动存储介质（U盘、移动硬盘、光盘）</li><li>常用的杀毒软件（防火墙）：360、瑞星、金山毒霸、KU3000</li><li>防火墙的功能或作用<br>防火墙处理内网和外网之间，用于过滤进、出内网信息的一个软件。防火墙通过制定安全策略，设置允许或禁止通过的数据包策略，抵御外部非法攻击<br>防火墙采用 被动防御 策略</li><li>计算机安全策略（病毒防治措施或方法）（信息安全措施）<br>计算机病毒防治采用“预防为主、查杀结合”    1. 操作系统及时升级、打补丁    2. 安装杀毒软件和防火墙软件、并及时升级    3. 定期查、杀病毒    4. 不使用来历不明的移动存储介质    5. 不访问不良站点，不打开来历不明的邮件，短信等    6. 定期制作系统备份    7. 使用正版软件，抵制盗版行为    8. 制定规章制度，加强宣传教育</li><li>计算机病毒按破坏性分为：良性病毒和恶性病毒</li><li>计算机病毒按类型分为：引导型病毒、文件型病毒和复合型病毒    1. 引导型病毒是破坏硬盘的启动区    2. 文件型病毒是专门破坏.exe（可执行文件）和.com（命令文件）类型的文件。宏病毒专门破坏office软件文档    3. 复合型病毒具有多种病毒特征。</li></ol><h1 id="【补充】"><a href="#【补充】" class="headerlink" title="【补充】"></a>【补充】</h1><h2 id="操作系统的概念和功能"><a href="#操作系统的概念和功能" class="headerlink" title="操作系统的概念和功能"></a><strong>操作系统的概念和功能</strong></h2><ol><li>软件=程序+文档（+数据） 程序一系列的指令的集合。<br>程序完成一个功能 软件是完成任务<br>例：Word软件是完成字处理任务   打印程序完成打印功能</li><li>   CPU任何情况都没有空闲</li><li>   虚拟内存</li><li>虚拟内存是硬盘空间，所有的磁盘分区，都可划分虚拟内存空间</li><li>功能：当内存资源不足时使用硬盘空间临时充当内存空间</li><li>   按网络提供的服务方式分为 单机操作系统 和网络操作系统<br>单机版是运行在PC机中，是服务申请方<br>网络操作系统是运行在服务器中，是服务提供方<br>W7版本<br>初级版，家庭初级版，家庭高级版，专业版，企业版，旗舰版</li></ol><h2 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a><strong>操作系统的分类</strong></h2><ol><li>按允许同时登录的用户数分为 单用户操作系统和多用户操作系统 ：例：XP是单用户 W7/8/9是多用户</li><li>按允许同时执行的任务数分为，单任务操作系统和多任务操作系统 ：例：Windows是多任务操作系统</li><li>按界面，分为字符操作系统和图形化操作系统<br>例：DOS是单用户，单任务，字符界面操作系统<pre><code>W7是多用户，多任务，图形化操作系统Windows操作系统，是真正32位操作系统，多任务图形化界面，与Internet完美结合。</code></pre></li><li>按任务（事务）处理的及时性，分为分时操作系统和实时操作系统</li><li>分时操作系统：将CPU的工作时间划分为若干个时间片，分配给多个事务，轮流处理<br>特点：资源利用率高，事务处理及时性差</li><li>实时操作系统：预留CPU资源，事务出现，及时处理<br>特点：资源利用率低，实时性好<br>例：工农业自动控制，军事，订票系统，联机检索功能</li></ol><h2 id="“开机”菜单→“关机”命令"><a href="#“开机”菜单→“关机”命令" class="headerlink" title="“开机”菜单→“关机”命令"></a><strong>“开机”菜单→“关机”命令</strong></h2><ol><li>   注销：退出当前登录用户账户，释放占用的资源，包括（注册信息，运行程序）</li><li>   切换用户：用于W7是多用户将前一个用户转位后台，另一个用户登录使用（后台用户继续运行，没有注销）</li><li>   锁定：使用登录密码，禁止其他人使用</li></ol><h2 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a><strong>用户界面</strong></h2><ol><li>   桌面</li><li>桌面是程序运行的平台，是Windows启动完成后的整个屏幕，桌面不是窗口（窗口是程序运行的界面）</li><li>桌面组成包括：桌面背景、系统图标、任务栏、“开始”菜单、窗口、对话框等</li><li>桌面背景：可使用任意图片作为桌面背景（墙纸或壁纸）<br> 允许使用网页作为桌面背景，并且会随网页更新自动更新 </li><li>系统图标：计算机（我的电脑）、网络（网上邻居）、回收站、文档（我的文档或administrator）    1. 除回收站图标外，其他图标都可修改，删除    2. “计算机”即“资源管理器”管理磁盘分区 如：D盘 D：    3. “网络”：管理网络（局域网）中主机共享硬件资源（如共享打印机）    4. 回收站<ol><li>   回收站用于存放从硬盘中删除的文件或文件夹 其他的U盘，光盘，移动盘删除的文件不会进入回收站</li><li>   进入回收站的文件不可打开</li><li>   回收站的文件是逻辑删除，可以还原到原来位置</li><li>   删除回收站中的文件，是物理删除，不可还原</li><li>   回收站是硬盘空间，是文件夹，所有磁盘分区，都可划分回收站空间</li><li>   直接物理删除文件，不进入回收站的情况：</li><li>   Shift+delete 或shift+拖进加收站</li><li>   要删除的文件大小，超过了回收站的可用空间，直接物理删除    5. 文档或我的文档 ，默认的，所有Windows中的软件，编辑的文档保存路径（位置）</li></ol></li><li>任务栏<br>任务栏可位于桌面的四边<br>任务栏最大占桌面的1/2，最小自动隐藏不显示</li></ol><h2 id="【简答】隐藏任务栏的方式"><a href="#【简答】隐藏任务栏的方式" class="headerlink" title="【简答】隐藏任务栏的方式"></a><strong>【简答】隐藏任务栏的方式</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答：右击任务栏空白处，快捷菜单中选择“属性”命令，在“任务栏和开始菜单属性”对话框，“任务栏”选项卡中</span><br><span class="line">“√自动隐藏任务栏”，单击“确定”命令按钮</span><br><span class="line">通知区域：可以打开&#x2F;关闭“时钟、音量、网络、电源”</span><br><span class="line">任务栏最右侧，是“显示桌面”图标</span><br><span class="line">任务栏中放置窗口小图标</span><br></pre></td></tr></table></figure><ol start="6"><li>“开始”菜单    1. “开始”菜单中包括所有功能的快捷方式：利用“开始”菜单可实现所有操作    2. “开始”菜单中的快捷方式，可添加、修改、删除等<br>【补充】快捷方式是指向文件、文件夹、快捷方式的指针文件。  快捷方式大小2-4Kb<ol><li>   一个对象 可创建 多个快捷方式</li><li>   一个快捷方式 只能 指向一个对象</li><li>   修改、删除快捷方式，不会影响指向文件</li></ol></li><li>窗口    1. 窗口是正在运行的程序界面，不是所有的程序运行，都有窗口    2. 活动窗口是正在被操作的窗口，任何情况下只能有一个活动窗口。其他窗口在后台继续运行。    3. 窗口组成包括标题栏、菜单栏、工具栏、工作区域、状态栏、滚动条、边框角。    4.    标题栏<ol><li>拖动标题栏，是移动窗口</li><li>双击标题栏，是最大化/还原窗口<br>最大化：窗口铺满屏幕<br>还原：将最大化窗口恢复到原大小、原位置 </li><li>标题栏是最左侧图标是“控制菜单”</li><li>双击“控制菜单”图标，关闭窗口<br>【关闭窗口 结束程序运行，释放程序中占用的CPU资源和内存资源】 </li><li>利用“控制菜单”，可最大化、最小化还原窗口，可移动窗口，可关闭窗口 </li><li>Alt+Space是打开“控制菜单” </li><li>标题栏右侧</li><li>“最小化”不显示窗口内容，窗口在任务栏小图标。最小化窗口在后台继续运行</li><li>“最大化/还原”窗口在后台继续运行</li><li>“关闭X”结束程序运行</li><li>键盘 激活窗口菜单方法（F10或Alt）</li><li>Alt+菜单后字母：是激活菜单<br>Alt+F 打开“文件”菜单<br>Alt+E 打开“编辑”菜单</li><li>执行菜单下命令行（命令项）的方法：在键盘上直接按下命令行后对应的字母<br>Alt+F，S 执行“文件”菜单→“保存”命令<br>Alt+E，I 执行“编辑”菜单→“反向选择”命令<br>【提醒】执行命令行时，不再需要Alt</li><li>命令行左侧     1.  ·表示 一组命令中，只能选中一个命令（单选）命令项左侧有·表示当前功能正在运行中     2.  √表示 一组命令中，允许同时选中多个命令，（复选）命令项左侧有√：表示当前功能正在运行  </li><li>命令行右侧     1. 黑三角：表示有下一级子菜单（级联菜单）     2. ：表示淡出对话框</li><li>工具栏是菜单下命令行的快捷方式</li><li>滚动条 窗口中内容多，窗口小，不足以显示所有内容是，出现水平和垂直滚动条</li><li>拖动窗口四边：改变窗口的高度或宽度<br>拖动窗口四角：同时改变窗口的高度和宽度</li><li>对话框</li><li>对话框 是程序窗口与用户交互的界面</li><li>对话框不能改变大小，可以移动</li></ol></li></ol><h2 id="【简答】启动应用程序或打开窗口的方法"><a href="#【简答】启动应用程序或打开窗口的方法" class="headerlink" title="【简答】启动应用程序或打开窗口的方法"></a>【简答】启动应用程序或打开窗口的方法</h2><ol><li>“开始”菜单→“所有程序”命令</li><li>双击桌面快捷方式</li><li>在“资源管理器”中双击程序图标</li><li>在“任务管理器”中启动新任务</li><li>执行“开始”菜单→“运行”命令，在“运行”对话框文本框中输入完整文件名，“确定”运行<br>【说明】完整文件名包括路径/文件名</li></ol><h2 id="【简答】结束应用程序或关闭窗口的办法"><a href="#【简答】结束应用程序或关闭窗口的办法" class="headerlink" title="【简答】结束应用程序或关闭窗口的办法"></a>【简答】结束应用程序或关闭窗口的办法</h2><ol><li>双击“控制菜单”图标</li><li>单击标题栏“关闭X”按钮</li><li>Alt+F4</li><li>“文件”菜单→“关闭”或“退出”命令</li><li>在“任务管理器”中强制中止程序</li></ol><h2 id="2-4-4"><a href="#2-4-4" class="headerlink" title="2.4.4"></a>2.4.4</h2><ol><li>凡是安装/卸载应用程序，一律在“控制面板”窗口的“程序和功能”命令图标。<br>【说明】应用程序自带的安装程序名是 setup.exe或install.exe<br>应用程序自带的卸载程序名是unins.exe</li><li>   凡是Windows硬件，一律在“控制面板”窗口“设备和打印机”命令图标</li></ol><h2 id="资源管理器"><a href="#资源管理器" class="headerlink" title="资源管理器"></a>资源管理器</h2><p><strong>【简答】打开资源管理器的方法</strong></p><ol><li>执行“开始”菜单→“所有程序”→“附近”→“资源管理器”命令</li><li>双击桌面“计算机”图标</li><li>右击“开始”菜单，快捷菜单中选择“资源管理器”命令</li><li>Windows键+E</li><li>   资源管理器管理文件两个原则</li><li>采用材形目录结构组织和管理文件</li><li>文件按名存取<br>【说明】目录约等于文件夹        名 指 文件名</li><li>   资源管理器界面（P79图2-19）</li><li>资源管理器左侧是树形目录结构，右侧是左侧选中某文件夹下所有信息</li><li>左侧树形目录结构显示    1. 收藏夹:显示“下载、桌面”中的文件和“最近访问位置”的快捷方式    2. “库”中是视频、音频、文档、图片、快捷方式    3. “计算机”    3. “网络”管理网络共享资源</li><li>▶或 + 表示有下一级子文件夹，且没展开<br>△或— 表示有下一级子文件夹，且已经展开</li><li>单击▶或 +，变为 △或— 文件夹展开，右侧没有变化<br>单击▶或 —，变为 △或+ 文件夹收起，右侧没有变化</li><li>单击左侧文件夹（即选择），右侧显示左侧选中文件夹下所有信息。（左侧只能选中一个文件夹）</li><li>改变右侧显示方式<br>“查看”菜单→“详细信息”命令，显示“文件名、文件类型、文件大小、修改日期（不是创建日期）”等四项。可以排序</li></ol><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">####  计算机基础笔记结束#### </span><br><span class="line">#### 此复习笔记资料仅供学习复习使用，请不要拿走用于商业用途#### </span><br><span class="line">#### 笔记都是本人幸苦写出来的#### </span><br><span class="line">#### 如若对您有用我将十分荣幸#### </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机类 </category>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Review-notes </tag>
            
            <tag> Computer-Basics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法说明</title>
      <link href="2020/10/07/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>2020/10/07/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><a href="/" title="博客主页">&lt;&lt; 返回博客主页</a></p><h1 id="日常忘记Markdown语法-QAQ，索性写个笔记记下来-哼"><a href="#日常忘记Markdown语法-QAQ，索性写个笔记记下来-哼" class="headerlink" title="日常忘记Markdown语法 QAQ，索性写个笔记记下来 哼~"></a>日常忘记Markdown语法 QAQ，索性写个笔记记下来 哼~</h1><h1 id="Markdown-语法说明"><a href="#Markdown-语法说明" class="headerlink" title="Markdown 语法说明"></a>Markdown 语法说明</h1><p><strong>NOTE:</strong> This is Simplelified Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to <span class="exturl" data-url="aHR0cHM6Ly9kYXJpbmdmaXJlYmFsbC5uZXQvcHJvamVjdHMvbWFya2Rvd24vc3ludGF4">Markdown: Syntax<i class="fa fa-external-link-alt"></i></span>.</p><h3 id="一、创建文章"><a href="#一、创建文章" class="headerlink" title="一、创建文章"></a>一、创建文章</h3><p>在站点文件夹中打开git bash,输入如下命令创建文章，其中 <code>title</code>为文章的标题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;title&quot;  </span><br></pre></td></tr></table></figure><p>当输入命令后，就会在 <code>source/_post</code> 文件夹下创建一个文件，命名为：<code>title.md</code></p><h3 id="二、编写文章（基于Markdown）"><a href="#二、编写文章（基于Markdown）" class="headerlink" title="二、编写文章（基于Markdown）"></a>二、编写文章（基于Markdown）</h3><h4 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h4 id="2-粗体、斜体、删除线和下划线"><a href="#2-粗体、斜体、删除线和下划线" class="headerlink" title="2.粗体、斜体、删除线和下划线"></a>2.粗体、斜体、删除线和下划线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><h4 id="3-引用块"><a href="#3-引用块" class="headerlink" title="3.引用块"></a>3.引用块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 文字引用</span><br></pre></td></tr></table></figure><h4 id="4-代码块"><a href="#4-代码块" class="headerlink" title="4.代码块"></a>4.代码块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#96;行内代码&#96;</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;</span><br><span class="line">多行代码</span><br><span class="line">多行代码</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure><h4 id="5-公式块"><a href="#5-公式块" class="headerlink" title="5.公式块"></a>5.公式块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">数学公式</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h4 id="6-分割线"><a href="#6-分割线" class="headerlink" title="6.分割线"></a>6.分割线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法一：---</span><br><span class="line"></span><br><span class="line">方法二：+++</span><br><span class="line"></span><br><span class="line">方法三：***</span><br></pre></td></tr></table></figure><h4 id="7-列表"><a href="#7-列表" class="headerlink" title="7.列表"></a>7.列表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表项</span><br><span class="line"></span><br><span class="line">* 无序列表项</span><br><span class="line"></span><br><span class="line">+ 无序列表项</span><br><span class="line"></span><br><span class="line">- 无序列表项</span><br></pre></td></tr></table></figure><h4 id="8-表格"><a href="#8-表格" class="headerlink" title="8.表格"></a>8.表格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表头1|表头2</span><br><span class="line">-|-|-</span><br><span class="line">内容11|内容12</span><br><span class="line">内容21|内容22</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| 表头1|表头2|表头3|表头4</span><br><span class="line">|-| :- | :-: | -: |</span><br><span class="line">|默认左对齐|左对齐|居中对其|右对齐|</span><br></pre></td></tr></table></figure><h4 id="9-超链接"><a href="#9-超链接" class="headerlink" title="9.超链接"></a>9.超链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法一：[链接文字](链接地址 &quot;链接描述&quot;)</span><br><span class="line">例如：[示例链接](https:&#x2F;&#x2F;www.example.com&#x2F; &quot;示例链接&quot;)</span><br><span class="line"></span><br><span class="line">方法二：&lt;链接地址&gt;</span><br><span class="line">例如：&lt;https:&#x2F;&#x2F;www.example.com&#x2F;&gt;</span><br></pre></td></tr></table></figure><h4 id="10-图片"><a href="#10-图片" class="headerlink" title="10.图片"></a>10.图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![图片文字](图片地址 &quot;图片描述&quot;)</span><br><span class="line">例如：![示例图片](https:&#x2F;&#x2F;www.example.com&#x2F;example.PNG &quot;示例图片&quot;)</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>在hexo中插入图片时，请按照以下的步骤进行设置</p><p>   1.将 站点配置文件 中的 <code>post_asset_folder</code> 选项的值设置为 true<br>   2.在站点文件夹中打开 git bash，输入命令 <code>npm install hexo-asset-image --save</code> 安装插件<br>   3.这样，当使用 <code>hexo new title</code> 创建文章时，将同时在 <code>source/_post</code> 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可。<br>    例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <code>![示例图片](title/example.PNG &quot;示例图片&quot;)</code> 添加图片。</p><h3 id="高级设置"><a href="#高级设置" class="headerlink" title="高级设置"></a>高级设置</h3><h4 id="1-模板设置"><a href="#1-模板设置" class="headerlink" title="1.模板设置"></a>1.模板设置</h4><p>当使用命令 <code>hexo new &quot;title&quot;</code> 创建文章时，Hexo 会根据 <code>/scaffolds/post.md</code> 对新文章进行初始化<br>换言之，<code>/scaffolds/post.md</code> 就是新文章的 <strong>模板</strong>，所以我们可以修改它来适应自己的写作习惯<br>一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags: </span><br><span class="line">categories: </span><br></pre></td></tr></table></figure><h4 id="2-头部设置"><a href="#2-头部设置" class="headerlink" title="2.头部设置"></a>2.头部设置</h4><p>在每篇利用 Hexo 创建的文章的开头，都会有对文章进行说明的文字，叫做 <strong>文章头部</strong><br>文章的头部除了可以设置文章标题、发布日期等基础信息外，还可以为文章添加标签、分类等<br>一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: Title</span><br><span class="line">date: YYYY-MM-DD HH:MM:SS</span><br><span class="line">tags: [tag1, tag2, ...]</span><br><span class="line">categories: category</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>属性和属性值之间必须有一个空格，否则会解析错误</p><h4 id="3-首页显示"><a href="#3-首页显示" class="headerlink" title="3.首页显示"></a>3.首页显示</h4><p>在利用 Hexo 框架搭建的博客网站中，首页会显示文章的内容，且默认显示文章的全部内容<br>如果当文章太长的时候就会显得十分冗余，所以我们有必要对其进行精简<br>这时，我们只需在文章中使用 <code>&lt;!--more--&gt;</code> 标志即可，表示只会显示标志前面的内容</p><h3 id="三、部署发布"><a href="#三、部署发布" class="headerlink" title="三、部署发布"></a>三、部署发布</h3><p>在站点文件夹中打开 git bash，输入如下命令部署和发布文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><p><strong>建议：</strong>在使用 <code>hexo g</code> 部署之后，可以先使用 <code>hexo s</code> 运行本地站点，然后在浏览器输入地址 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo0MDAwLw==">http://localhost:4000/<i class="fa fa-external-link-alt"></i></span> 查看运行结果，检查无误后再使用 <code>hexo d</code> 发布.</p><h4 id="博主为了方便的部署和运行"><a href="#博主为了方便的部署和运行" class="headerlink" title="博主为了方便的部署和运行"></a>博主为了方便的部署和运行</h4><p><strong>本地运行</strong><br>当然为了偷懒博主更喜欢在站点文件夹下创建一个<code>go1.bat</code>文件，右键编辑文本输入如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s      </span><br></pre></td></tr></table></figure><p>保存退出，之后若想本地部署可以直接进入站点文件夹下输入 <code>go1</code> 回车即可本地部署.</p><p><strong>发布</strong><br>则同样在站点文件夹下创建一个<code>go.bat</code>文件，右键编辑文本输入如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g --d</span><br></pre></td></tr></table></figure><p>保存退出,之后若想发布可以直接进入站点文件夹下输入 <code>go</code> 回车即可发布.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
